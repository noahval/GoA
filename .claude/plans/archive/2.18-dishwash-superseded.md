# Dishwash Minigame

**Goal**: Simple bar work minigame where player dunks and shakes mugs to earn Holes

**Success Criteria**: Player can wash mugs indefinitely, earn Holes based on mugs processed, and eventually master the job for passive mode

**Status**: IN PROGRESS - Design revised with click-to-bind system and auto-dry timer

---

## Overview

First of the bar work minigames. The player "washes" mugs by dunking them in a basin and shaking off the water. Thematically grim - you're not actually cleaning anything, just making mugs damp-then-dry. The patrons get grimy mugs with the dirt still on them. Fits the poverty aesthetic of the train's underclass.

### Key Design Principles

- Ultra-simple: click-to-bind system (click stack, dunk, click rack)
- Move mug through air to dry faster OR auto-dry after 7 seconds
- Grim theme over cleanliness fantasy
- Foundation for job mastery system (Active -> Passive)
- No session time limits - player controls when to stop

---

## Core Mechanic

### The Loop

1. **Click** dirty mug stack (top left) - binds mug to cursor
2. **Move** mug into basin - spend 2 seconds in water to clean it
3. **Wait 7 seconds OR move mug through air** to dry the mug
4. **Click** drying rack (top right) to place mug and unbind from cursor

Repeat until player clicks "Stop washing" button.

### Input Detection

**Click-to-Bind System**:
- Click dirty stack once -> mug binds to cursor, follows mouse position
- Mug stays bound until clicked on rack (or error occurs)
- No drag-and-hold, just position tracking

**Basin Contact** (bottom middle):
- Basin is a container with translucent brown water
- Mug must spend 2 seconds inside basin hitbox to transition from `dirty` to `wet`
- Water particles spawn when mug enters basin Area2D
- Particle system: CPUParticles2D with brown water droplets, gravity pulls them down naturally
- Mug state changes from `dirty` to `wet` after 2 seconds in basin

**Auto-Dry Timer**:
- After mug leaves water basin area, 7-second timer starts
- If timer completes, mug automatically becomes `dry` state
- Movement can speed up drying significantly

**Air Drying Through Movement** (optional speedup):
- Moving the wet mug through air accelerates evaporation
- Track cumulative distance traveled while wet
- Every 200 pixels moved = 1 second saved off the timer
- Total of ~1400 pixels movement = instant dry (bypasses 7-second wait)
- Thematic: circulating air around wet mug speeds drying

**Rack Placement** (top right):
- Click rack to place mug (only works if mug is `dry`)
- If mug is still `dirty`: show notification "Clean it first!"
- If mug is still `wet`: show notification "Dry it first!"
- Success: mug unbinds from cursor, tracks progress (every 3 mugs awards 1 Hole)

---

## Visual Layout

```
+--------------------------------------------------+
| [Off] -> [Dirty Stack]            [Drying Rack]  |
|  screen    (TOP LEFT)              (TOP RIGHT)   |
|         ___  ___  ___               |__|__|__|   |
|        |___||___||___|              |__|__|__|   |
|      (conveyor belt                 |__|__|__|   |
|       of mugs)                                   |
|                                                  |
|                   [Basin]                        |
|                 (BOTTOM MID)                     |
|                  ~~~~~~~~~                       |
|          [brown water + particles]               |
|                                                  |
|                                                  |
|              [Stop washing]                      |
|                                                  |
+--------------------------------------------------+
```

- **Dirty stack** (top left): Conveyor belt effect - 3+ `mug-dirty.png` overlapped horizontally
  - Mugs come from offscreen left (origin point)
  - When player clicks, all mugs slide left to fill the gap
  - Creates illusion of continuous supply from offscreen source
- **Basin** (bottom middle): Container with brown water and particle system
  - CPUParticles2D spawns brown water droplets when mug enters
  - Particles naturally fall back down via gravity (no collision box needed)
- **Drying rack** (top right): Click target to place dried mugs - uses `drying-rack.png` sprite
- **Holes Earned**: Total Holes earned this session
- "Stop washing" button (AffirmativeButton) to end session

---

## Bar Scene Integration

### UI Buttons

**Location**: Buttons appear in the bar scene's right-side menu (33% width area)

**"Wash mugs" Button**:
- Style: `theme_type_variation = "AffirmativeButton"` (gold/amber theme from 1.x-default-theme.md)
- Behavior: Shows minigame in play area, becomes disabled during session

**"Stop washing" Button**:
- Style: `theme_type_variation = "AffirmativeButton"`
- Behavior: Ends session, re-enables "Wash mugs" button
- Hidden by default, shown only during washing session

### Minigame Placement

- Minigame renders inside the bar scene's play area (66% width, left side - see 1.x-responsive-layout.md)
- Fills play area while active
- Play area dimensions calculated by ResponsiveLayout at runtime

---

## Test-Driven Development Plan

**BIBLE Requirement**: All new features must follow TDD methodology (RED-GREEN-REFACTOR cycle)

**Reference**: [programming-principles.md#test-driven-development-tdd](c:\Goa\.claude\docs\programming-principles.md#test-driven-development-tdd)

### Test Strategy

Write tests FIRST, then implement. Follow RED-GREEN-REFACTOR:
1. **RED**: Write failing test
2. **GREEN**: Write minimal code to pass
3. **REFACTOR**: Clean up implementation

### Unit Tests Required

**State Machine Tests** (`test_dishwash_state_machine.gd`):
- Test DIRTY -> WET transition after 2 seconds in basin
- Test WET -> DRY transition after 7 seconds auto-dry
- Test WET -> DRY transition with movement acceleration
- Test invalid transitions (e.g., DIRTY -> DRY directly)
- Test state preservation when unbinding mug

**Timer Logic Tests** (`test_dishwash_timers.gd`):
- Test basin soak timer accumulates only when in basin
- Test dry timer starts only after leaving basin in WET state
- Test dry timer doesn't start for DIRTY mugs leaving basin
- Test movement distance calculation (distance per frame)
- Test movement-to-time conversion (200px = 1 second saved)

**Currency Award Tests** (`test_dishwash_currency.gd`):
- Test 1 Hole awarded every 3 mugs completed
- Test partial progress tracked (0/3, 1/3, 2/3, 0/3 cycle)
- Test Level1Vars.mugs_washed increments correctly
- Test currency signal emission

**Mastery Unlock Tests** (`test_dishwash_mastery.gd`):
- Test mastery unlocks at exactly 150 mugs
- Test mastery doesn't unlock before 150 mugs
- Test mastery unlock only fires once
- Test Level1Vars.dishwash_mastery_unlocked flag set

**Input Handling Tests** (`test_dishwash_input.gd`):
- Test click on dirty stack binds mug
- Test click on rack with DIRTY mug shows error
- Test click on rack with WET mug shows error
- Test click on rack with DRY mug completes cycle
- Test rapid clicking doesn't bind multiple mugs

### Integration Tests Required

**Full Wash Cycle Test** (`test_dishwash_integration.gd`):
- Test complete cycle: click stack -> dunk 2s -> wait 7s -> click rack
- Test complete cycle with movement drying instead of waiting
- Test error notification display and timeout
- Test session start/stop button states

### Test Execution Order

1. Write state machine tests (core logic)
2. Write timer tests (mechanics)
3. Write currency tests (rewards)
4. Write mastery tests (progression)
5. Write input tests (UI interaction)
6. Write integration tests (end-to-end)

**Implementation Rule**: No production code without a failing test first.

---

## Implementation Tasks

### 1. Scene Structure

Create dishwash minigame as embedded Control node in bar scene's play area:

```
BarScene
├── PlayArea (66% width, left side - from scene template)
│   └── DishwashMinigame (Control, hidden by default)
│       ├── Background (ColorRect) # 20% opacity orange - Color(1.0, 0.5, 0.0, 0.2)
│       ├── DirtyStack (Area2D) # top left click target
│       │   ├── CollisionShape2D # click detection
│       │   └── Mugs (Node2D) # container for mug sprites
│       │       ├── Mug1, Mug2, Mug3 (Sprite2D) # mug-dirty.png, horizontally offset
│       │       └── (optional: AnimationPlayer for conveyor slide)
│       ├── Basin (Area2D) # bottom middle hitbox for soaking
│       │   ├── CollisionShape2D # defines basin area
│       │   ├── WaterVisual (ColorRect) # brown translucent water
│       │   └── WaterParticles (CPUParticles2D) # brown droplets
│       ├── DryingRack (Area2D) # top right click target
│       │   ├── CollisionShape2D # click detection
│       │   └── RackSprite (Sprite2D) # drying-rack.png
│       ├── BoundMug (Area2D) # follows cursor when bound
│       │   ├── CollisionShape2D # for basin overlap detection
│       │   └── MugSprite (Sprite2D) # visual representation
│       └── ErrorNotification (Label) # "Clean it first!" / "Dry it first!"
└── Menu (33% width, right side - from scene template)
    ├── WashMugsButton (Button) # shows minigame, theme_type_variation = "AffirmativeButton"
    └── StopWashingButton (Button) # ends session, hidden by default
```

**IMPORTANT**: Mark `WashMugsButton` and `StopWashingButton` as scene-unique names (% flag in Godot editor) to enable safe access via `get_node("%NodeName")` from nested nodes.

### 2. Mug State Machine

```gdscript
enum MugState { DIRTY, WET, DRY }

var current_mug_state: MugState = MugState.DIRTY
var mug_bound_to_cursor: bool = false
var basin_soak_timer: float = 0.0  # Tracks time spent in basin
var dry_timer_start: float = 0.0  # Timestamp when drying started
var last_mug_position: Vector2 = Vector2.ZERO  # For distance tracking

const REQUIRED_SOAK_TIME: float = 2.0  # Must soak 2 seconds in basin
const AUTO_DRY_DURATION: float = 7.0  # Auto-dry after 7 seconds
const PIXELS_PER_SECOND_SAVED: float = 200.0  # Movement acceleration

# Texture preloads (const at class level, not runtime)
const MUG_DIRTY_TEXTURE = preload("res://level1/icons/mug-dirty.png")
const MUG_WET_TEXTURE = preload("res://level1/icons/mug-wet.png")
const MUG_CLEAN_TEXTURE = preload("res://level1/icons/mug-clean.png")
```

State transitions:
- `DIRTY` -> `WET`: Mug spends 2 seconds in basin
- `WET` -> `DRY`: Movement shortens timer OR 7 seconds elapsed after leaving basin
- `DRY` -> (racked): Click rack to place and unbind

### 3. Basin Soaking & Air Drying

```gdscript
var time_saved_by_movement: float = 0.0  # Seconds shaved off timer by moving
var mug_in_basin: bool = false  # Track basin overlap state

func _ready():
    # Connect Area2D signals for basin collision
    $Basin.area_entered.connect(_on_basin_area_entered)
    $Basin.area_exited.connect(_on_basin_area_exited)

func _process(delta):
    # Don't process when minigame is hidden
    if not visible:
        return

    # Update mug position to follow cursor if bound
    if mug_bound_to_cursor:
        $BoundMug.global_position = get_global_mouse_position()

    # Basin soaking timer (DIRTY -> WET transition)
    if current_mug_state == MugState.DIRTY and mug_in_basin:
        basin_soak_timer += delta
        if basin_soak_timer >= REQUIRED_SOAK_TIME:
            transition_to_wet()

    # Air drying through movement (optional speedup)
    if mug_bound_to_cursor and current_mug_state == MugState.WET:
        var current_pos = get_global_mouse_position()
        var distance_moved = current_pos.distance_to(last_mug_position)

        # Convert distance to time saved
        time_saved_by_movement += distance_moved / PIXELS_PER_SECOND_SAVED

        # CRITICAL: Update position for next frame (prevents accumulating from bind point)
        last_mug_position = current_pos

    # Auto-dry timer (WET -> DRY transition)
    if current_mug_state == MugState.WET and dry_timer_start > 0.0:
        var elapsed = (Time.get_ticks_msec() / 1000.0) - dry_timer_start
        var adjusted_time = elapsed + time_saved_by_movement

        if adjusted_time >= AUTO_DRY_DURATION:
            transition_to_dry()

func _on_basin_area_entered(area: Area2D):
    # Only respond to BoundMug entering basin
    if area == $BoundMug and mug_bound_to_cursor and current_mug_state == MugState.DIRTY:
        mug_in_basin = true
        basin_soak_timer = 0.0
        $Basin/WaterParticles.emitting = true

func _on_basin_area_exited(area: Area2D):
    # Only respond to BoundMug leaving basin
    if area == $BoundMug:
        mug_in_basin = false
        $Basin/WaterParticles.emitting = false
        # CRITICAL: Only start drying timer if mug is WET (not DIRTY)
        if current_mug_state == MugState.WET:
            dry_timer_start = Time.get_ticks_msec() / 1000.0
            time_saved_by_movement = 0.0  # Reset movement timer

func transition_to_wet():
    current_mug_state = MugState.WET
    basin_soak_timer = 0.0
    $BoundMug/MugSprite.texture = MUG_WET_TEXTURE

func transition_to_dry():
    current_mug_state = MugState.DRY
    dry_timer_start = 0.0
    time_saved_by_movement = 0.0
    $BoundMug/MugSprite.texture = MUG_CLEAN_TEXTURE
```

### 4. Session Flow & Click Handling

```gdscript
var mugs_this_session: int = 0
var mugs_toward_hole: int = 0

# References to buttons in Menu (use scene-unique names for safety)
@onready var wash_mugs_button = get_node("%WashMugsButton")
@onready var stop_washing_button = get_node("%StopWashingButton")

func _ready():
    # Connect button signals
    wash_mugs_button.pressed.connect(start_washing)
    stop_washing_button.pressed.connect(stop_washing)

    # Connect Area2D input signals for clickable areas
    $DirtyStack.input_event.connect(_on_dirty_stack_clicked)
    $DryingRack.input_event.connect(_on_rack_clicked)

    # Hide stop button initially
    stop_washing_button.visible = false

func start_washing():
    mugs_this_session = 0
    mugs_toward_hole = 0
    visible = true  # Show DishwashMinigame
    wash_mugs_button.disabled = true
    stop_washing_button.visible = true

func stop_washing():
    # Clean up if mug is currently bound
    if mug_bound_to_cursor:
        mug_bound_to_cursor = false
        $BoundMug.visible = false

    # Reset ALL state to prevent corruption between sessions
    current_mug_state = MugState.DIRTY
    basin_soak_timer = 0.0
    dry_timer_start = 0.0
    time_saved_by_movement = 0.0
    mug_in_basin = false

    visible = false  # Hide DishwashMinigame
    wash_mugs_button.disabled = false
    stop_washing_button.visible = false

func _on_dirty_stack_clicked(_viewport, event, _shape_idx):
    if event is InputEventMouseButton and event.pressed and event.button_index == MOUSE_BUTTON_LEFT:
        if not mug_bound_to_cursor:
            bind_mug_to_cursor()
            slide_conveyor_belt()
        else:
            show_error_notification("Finish current mug first!")

func _on_rack_clicked(_viewport, event, _shape_idx):
    if event is InputEventMouseButton and event.pressed and event.button_index == MOUSE_BUTTON_LEFT:
        if mug_bound_to_cursor:
            attempt_rack_placement()

func bind_mug_to_cursor():
    mug_bound_to_cursor = true
    current_mug_state = MugState.DIRTY
    last_mug_position = get_global_mouse_position()
    time_saved_by_movement = 0.0
    basin_soak_timer = 0.0
    mug_in_basin = false
    $BoundMug.visible = true
    $BoundMug/MugSprite.texture = MUG_DIRTY_TEXTURE

func slide_conveyor_belt():
    # TODO: Implement conveyor belt animation
    # Slide all mugs left to create conveyor effect
    # New mug appears from offscreen left
    # This is optional polish - can be deferred to later iteration
    pass

func attempt_rack_placement():
    if current_mug_state == MugState.DIRTY:
        show_error_notification("Clean it first!")
        return
    elif current_mug_state == MugState.WET:
        show_error_notification("Dry it first!")
        return
    elif current_mug_state == MugState.DRY:
        complete_mug()

func show_error_notification(message: String):
    $ErrorNotification.text = message
    $ErrorNotification.visible = true
    await get_tree().create_timer(1.0).timeout
    $ErrorNotification.visible = false

func complete_mug():
    mugs_this_session += 1
    mugs_toward_hole += 1
    Level1Vars.mugs_washed += 1

    # Unbind mug
    mug_bound_to_cursor = false
    $BoundMug.visible = false
    basin_soak_timer = 0.0
    dry_timer_start = 0.0
    time_saved_by_movement = 0.0
    mug_in_basin = false

    # Award Holes directly to currency (every 3 mugs)
    if mugs_toward_hole >= 3:
        mugs_toward_hole = 0
        Level1Vars.add_currency("holes", 1.0)
        # Play coin sound, flash UI

    check_mastery_unlock()

func check_mastery_unlock():
    if Level1Vars.mugs_washed >= 150 and not Level1Vars.dishwash_mastery_unlocked:
        Level1Vars.dishwash_mastery_unlocked = true
        # TODO: Implement notification system integration
        # Global.show_notification("Dishwashing mastered! Passive mode unlocked.", "positive")
        print("Dishwashing mastery unlocked!")
```

### 5. Water Particle Configuration

```gdscript
# Basin/WaterParticles (CPUParticles2D) configuration:
$Basin/WaterParticles.emitting = false  # Controlled by basin entry/exit
$Basin/WaterParticles.amount = 20
$Basin/WaterParticles.lifetime = 0.5
$Basin/WaterParticles.explosiveness = 0.3

# Brown muddy water color
$Basin/WaterParticles.color = Color(0.4, 0.3, 0.2, 0.6)

# Emission shape - spawn along top of basin
$Basin/WaterParticles.emission_shape = CPUParticles2D.EMISSION_SHAPE_RECTANGLE
$Basin/WaterParticles.emission_rect_extents = Vector2(40, 5)  # Wide, shallow

# Movement - splash up then fall naturally
$Basin/WaterParticles.direction = Vector2(0, -1)  # Initial upward
$Basin/WaterParticles.spread = 45.0  # Degrees of variance
$Basin/WaterParticles.gravity = Vector2(0, 200)  # Pull down
$Basin/WaterParticles.initial_velocity_min = 30
$Basin/WaterParticles.initial_velocity_max = 80

# Particle size
$Basin/WaterParticles.scale_amount_min = 2.0
$Basin/WaterParticles.scale_amount_max = 4.0
```

### 6. Feedback Systems

**Audio**:
- Mug pickup: ceramic clink
- Basin splash: water slosh
- Mug dries: water droplet sounds (optional)
- Rack placement: solid thunk
- Hole earned: coin jingle
- Error: negative buzz

**Visual**:
- Conveyor belt slide animation when mug picked up (optional polish)
- Brown water particles (CPUParticles2D) spawn when mug enters basin
- Particles fall back down naturally via gravity
- Mug sprite changes: dirty -> wet -> dry (change $BoundMug texture)
- Error notification pops up above rack, fades after 1 second
- Currency display updates when Hole earned (handled by Level1Vars signal)

---

## Job Mastery System

### Active Mode (Default)

Player performs all actions manually. Earns 1 Hole per 3 mugs.

### Passive Mode (Unlocked via Mastery)

After washing 150 total mugs (`Level1Vars.mugs_washed >= 150`), player can assign character to dishwashing without input.

**Passive Rate**: 2 Holes per minute (1 Hole every 30 seconds)

**Level1Vars additions required**:
```gdscript
# Add to level_1_vars.gd:
var mugs_washed: int = 0  # Lifetime total for mastery tracking
var dishwash_mastery_unlocked: bool = false
```

---

## Payment & Economy

| Parameter | Value | Notes |
|-----------|-------|-------|
| Holes per mugs | 1 per 3 mugs | Must complete 3 to earn |
| Session limit | None | Player stops when they want |
| Mastery threshold | 150 mugs total | Tracked in Level1Vars |
| Passive rate | 2 Holes / minute | 1 Hole every 30 seconds when passive mode selected |

---

## Mug Sprite

**Status**: COMPLETE - Assets added to project

**Style**: 2D glass mug with baked-in transparency effect
- Simple silhouette with handle
- ~20-30% opacity fill (glass look)
- Static white highlight on upper left (light reflection)
- Subtle darker edge on right for depth

**Variants needed**:
1. **Dirty** - brown smudges/grime overlay
2. **Wet** - blue tint, drip shapes
3. **Clean** - base transparent mug

**Image prompt used**:
```
2D game sprite sheet, side-by-side comparison of the same glass beer mug, left side dirty with brown grime and smudges, right side clean and transparent, simple cartoon style, white highlight reflection on upper left of each mug, transparent glass material, plain flat background, pixel art or vector style, game asset, icon style, matching proportions
```

---

## Asset Files

**Added**:
- `game/v0.1/level1/icons/mug-clean.png` - Clean mug sprite
- `game/v0.1/level1/icons/mug-dirty.png` - Dirty mug sprite
- `game/v0.1/level1/icons/drying-rack.png` - Drying rack target area (top right)

**Still Needed**:
- `game/v0.1/level1/icons/mug-wet.png` - Wet mug sprite (or derive from clean with blue tint shader)
- Basin uses ColorRect with brown color for water visual + CPUParticles2D for splashing

**Note**: Dirty stack uses 3+ `mug-dirty.png` sprites in conveyor belt formation with slide animation

## BIBLE References

Before implementing, consult these documentation sources:
- **1.x-default-theme.md** - Button theme variations (AffirmativeButton styling)
- **1.x-responsive-layout.md** - Play area structure and menu layout
- **Programming principles** - TDD methodology (write tests first)
- **Game design principles** - Knowledge-based progression (how players learn the mechanic)

## Files to Modify

- `c:\Goa\game\v0.1\level1\bar.tscn` - Scene structure:
  - Add DishwashMinigame Control node inside PlayArea
  - Add WashMugsButton and StopWashingButton in Menu (right side)
  - Buttons use `theme_type_variation = "AffirmativeButton"`
- `c:\Goa\game\v0.1\level1\dishwash_minigame.gd` - CREATE NEW SCRIPT with all dishwash logic (attach to DishwashMinigame node)
- `c:\Goa\game\v0.1\level1\level_1_vars.gd` - Add `mugs_washed: int = 0` and `dishwash_mastery_unlocked: bool = false`

---

## Design Values

| Parameter | Value | Notes |
|-----------|-------|-------|
| Mugs per Hole | 3 | Batch payment |
| Session time limit | None | Unlimited washing |
| Basin soak time | 2 seconds | Time in water to clean mug |
| Auto-dry timer | 7 seconds | After leaving basin |
| Movement drying rate | 200 pixels/second saved | Distance shortens timer |
| Total distance to instant-dry | ~1400 pixels | Achievable with circular movement |
| Mastery threshold | 150 mugs | Lifetime total |
| Passive rate | 2 Holes / min | 1 Hole every 30s when selected |
| Dirty stack mug scale | 0.25 | Small mugs in stack |
| Bound mug scale | 0.3 | Cursor-bound mug |
| Drying rack scale | 0.3 | Top right corner |
| Dirty stack position | 15%, 15% | Top-left (relative to control size) |
| Basin position | 50%, 80% | Center-bottom (relative to control size) |
| Drying rack position | 85%, 15% | Top-right (relative to control size) |

---

## Testing Strategy

### Manual Test Criteria

- [ ] "Wash mugs" button shows minigame, hides itself
- [ ] "Stop washing" button ends session, shows "Wash mugs" again
- [ ] Click dirty stack binds mug to cursor
- [ ] Mug follows cursor position while bound
- [ ] Basin spawns particles when mug enters
- [ ] Particles fall naturally (no escape upward)
- [ ] Mug transitions from dirty -> wet after 2 seconds in basin
- [ ] Auto-dry timer completes after 7 seconds outside basin
- [ ] Moving wet mug shortens dry timer (200px = 1 second saved)
- [ ] Click rack with dirty mug shows "Clean it first!" error
- [ ] Click rack with wet mug shows "Dry it first!" error
- [ ] Click rack with dry mug successfully places it
- [ ] Hole awarded to currency every 3 mugs
- [ ] Currency display updates in real-time
- [ ] `Level1Vars.mugs_washed` increments correctly
- [ ] Mastery unlocks at 150 mugs
- [ ] Passive mode generates 2 Holes / minute (future feature)

---

## Open Questions

- [x] ~~Visual style for mugs~~ - 2D glass with baked transparency
- [x] ~~How does player access this minigame~~ - "Wash mugs" button in bar
- [x] ~~Session limits~~ - No limit, player chooses when to stop
- [x] ~~What does the bar scene play area look like? Where does minigame render?~~ - Minigame renders in play area (66% width, left side). See 1.x-responsive-layout.md for structure

---

## Notes & Decisions

**Decision: Click-to-bind system over drag-and-drop**
- Rationale: Simpler input model - one click to bind, one click to place
- Reduces accidental drops and cursor precision issues
- Mug follows cursor position until successfully placed on rack

**Decision: 7-second auto-dry timer with movement-based acceleration**
- Rationale: Fallback mechanism ensures players can always complete the task
- Moving wet mug through air speeds drying (thematic: air circulation)
- Simple distance tracking (200px = 1 second saved)
- More forgiving than wiggle reversals - any movement helps
- Timer starts after mug leaves basin area

**Decision: Error notifications for invalid rack placement**
- Rationale: Clear feedback when player tries to rack dirty/wet mugs
- Prevents confusion about why placement isn't working
- "Clean it first!" for dirty mugs, "Dry it first!" for wet mugs

**Decision: CPUParticles2D with natural gravity**
- Rationale: Brown water particles add visual feedback when mug enters basin
- Gravity naturally pulls particles back down - no collision box needed
- Simpler implementation, fits grim aesthetic (dirty water splashing)

**Decision: Conveyor belt animation for dirty stack**
- Rationale: Visual polish - makes infinite supply more believable
- All mugs slide left when one is picked up
- New mug appears from offscreen left
- Creates illusion of continuous supply chain from offscreen source

**Decision: Passive rate at 2 Holes/minute**
- Rationale: Makes passive mode significantly less efficient than active play
- Active: ~6.67 Holes/min (assuming 3s per mug)
- Passive: 2 Holes/min (1 every 30s)
- Incentivizes active play while still rewarding mastery

**Decision: Active/Passive only, no Auto**
- Rationale: User specified. Keeps bar work as character-committed activity.

**Decision: No session time limit**
- Rationale: User requested. Player washes as long as they want.
- "Stop washing" button ends session manually.

**Decision: 1 Hole per 3 mugs**
- Rationale: User specified. Batched payment.

**Decision: Mastery at 150 mugs (not 10 sessions)**
- Rationale: User specified. Tracks lifetime progress in Level1Vars.

**Decision: 2D sprite with baked glass effect**
- Rationale: Simpler than shader-based glass. Static highlight, transparency in PNG.

**Decision: Direct currency increment instead of session tracking**
- Rationale: Simpler code - no `holes_earned` variable or signal emission
- Real-time feedback - currency updates immediately when Hole earned
- Fewer moving parts, less state management
- Use `Level1Vars.add_currency("holes", 1.0)` directly

**Decision: Unified Area2D collision system**
- Rationale: All collision detection uses Area2D with CollisionShape2D
- BoundMug is Area2D (not Sprite2D) for basin overlap detection
- DirtyStack and DryingRack are Area2D for click detection
- Basin uses `area_entered`/`area_exited` signals (not `body_entered`/`body_exited`)
- Consistent approach throughout, cleaner signal handling
- Avoids mixing position-based and collision-based detection

**Decision: Buttons in right-side menu**
- Rationale: Follows scene template structure (see 1.x-responsive-layout.md)
- Menu is 33% width on right side, standard location for controls
- Play area (66% left) reserved for minigame visualization
- DishwashMinigame visibility controlled by `visible` property
- Buttons disable/enable rather than show/hide to maintain layout consistency

---

## Bug Fixes Applied

**2026-01-12 (Initial revision)**:
1. **Distance tracking**: Added `last_mug_position = current_pos` after distance calculation to prevent accumulation from bind point
2. **Dry timer logic**: Added state check to only start timer for WET mugs leaving basin, not DIRTY mugs
3. **Runtime preloads**: Moved all `preload()` calls to const declarations at class level instead of inside functions
4. **Fragile node paths**: Changed button references from `../../Menu/Button` to `%Button` using scene-unique names
5. **Missing implementations**: Added `pass` and TODO comments to `slide_conveyor_belt` and implemented `check_mastery_unlock` with placeholder notification
6. **TDD requirement**: Added complete Test-Driven Development Plan section with unit and integration test specifications

**2026-01-12 (Second revision - critical bug fixes)**:
1. **Script file ambiguity**: Clarified that dishwash logic goes in NEW FILE `dishwash_minigame.gd` (not bar.gd)
2. **_process() runs when hidden**: Added visibility check at start of _process() to prevent wasted CPU and state corruption
3. **Incomplete state reset**: Added full state reset in `stop_washing()` to prevent broken state between sessions (resets all timers, state variables)

---

**Last Updated**: 2026-01-12
