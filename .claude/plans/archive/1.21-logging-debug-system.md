# Logging and Debug System Plan

## Overview
Session-based logging system with optional bug reporting for playtesters. Captures errors and events to files for debugging, with cloud storage for external tester feedback.

## Core Goals
1. Persistent session-based logging with automatic rotation
2. Adjustable log levels for development vs production
3. Simple bug report UI for playtesters (optional - only if needed)
4. Screenshot capture with bug reports
5. Local backup for failed submissions

---

## Part 1: Session-Based Logger (DebugLogger Autoload)

### What It Does
- Creates new log file per session (preserves history)
- Automatically rotates old logs (keeps last 10 sessions)
- Batch flushes to prevent performance hits
- Always buffers DEBUG logs in memory for bug reports
- Writes filtered logs to disk based on level

### Log Levels Explained
- **ERROR** (level 3): Crashes, broken features, critical failures
- **WARN** (level 2): Something's wrong but game keeps running
- **INFO** (level 1): Normal events worth tracking (purchases, stat changes)
- **DEBUG** (level 0): Detailed traces (only kept in memory buffer)

### File: debug_logger.gd (Autoload)
```gdscript
extends Node

# Configuration
var disk_log_level: int = 1  # 0=DEBUG, 1=INFO, 2=WARN, 3=ERROR (what gets written to file)
var enable_logging: bool = true
var log_directory: String = "user://logs/"
var current_log_file: String = ""

var log_file: FileAccess = null
var recent_logs: Array[Dictionary] = []  # Always captures everything for bug reports
const MAX_RECENT_LOGS = 300  # Keep last 300 entries in memory
const MAX_LOG_FILES = 10  # Keep last 10 session logs

var flush_timer: float = 0.0
const FLUSH_INTERVAL: float = 2.0  # Batch flush every 2 seconds

func _ready():
	if enable_logging:
		_setup_log_directory()
		_rotate_old_logs()
		_open_new_session_log()

func _process(delta):
	# Batch flush instead of flushing every write
	if log_file and flush_timer > 0:
		flush_timer += delta
		if flush_timer >= FLUSH_INTERVAL:
			log_file.flush()
			flush_timer = 0.0

func _exit_tree():
	_close_log_file()

func _setup_log_directory():
	var dir = DirAccess.open("user://")
	if not dir.dir_exists("logs"):
		dir.make_dir("logs")

func _open_new_session_log():
	# Create session-specific log file: goa_2025-12-09_14-30-45.log
	var datetime = Time.get_datetime_dict_from_system()
	current_log_file = log_directory + "goa_%04d-%02d-%02d_%02d-%02d-%02d.log" % [
		datetime.year, datetime.month, datetime.day,
		datetime.hour, datetime.minute, datetime.second
	]

	log_file = FileAccess.open(current_log_file, FileAccess.WRITE)
	if log_file:
		var separator = "=".repeat(60)
		log_file.store_line(separator)
		log_file.store_line("GoA Debug Log - Session Started")
		log_file.store_line("Time: " + Time.get_datetime_string_from_system())
		log_file.store_line("Platform: " + OS.get_name())
		log_file.store_line("Godot Version: " + Engine.get_version_info().string)
		log_file.store_line("Disk Log Level: " + ["DEBUG", "INFO", "WARN", "ERROR"][disk_log_level])
		log_file.store_line(separator)
		log_file.flush()
		flush_timer = 0.0
	else:
		push_error("Failed to create log file: " + current_log_file)

func _close_log_file():
	if log_file:
		var separator = "=".repeat(60)
		log_file.store_line(separator)
		log_file.store_line("Session Ended: " + Time.get_datetime_string_from_system())
		log_file.store_line(separator)
		log_file.flush()
		log_file.close()

func _rotate_old_logs():
	# Delete oldest logs if we exceed MAX_LOG_FILES
	var dir = DirAccess.open(log_directory)
	if not dir:
		return

	var log_files: Array[String] = []
	dir.list_dir_begin()
	var file_name = dir.get_next()
	while file_name != "":
		if file_name.begins_with("goa_") and file_name.ends_with(".log"):
			log_files.append(file_name)
		file_name = dir.get_next()
	dir.list_dir_end()

	# Sort by name (timestamp is in filename)
	log_files.sort()

	# Delete oldest if we have too many
	while log_files.size() >= MAX_LOG_FILES:
		var oldest = log_files.pop_front()
		dir.remove(oldest)
		info("Deleted old log file: " + oldest, "LOGGER")

# Main logging function
func write_log(message: String, level: int = 1, category: String = "GENERAL"):
	if not enable_logging:
		return

	var level_name = ["DEBUG", "INFO", "WARN", "ERROR"][level]
	var timestamp = Time.get_datetime_string_from_system()
	var formatted = "[%s] [%s] [%s] %s" % [timestamp, level_name, category, message]

	# Always add to memory buffer (for bug reports)
	recent_logs.append({
		"timestamp": timestamp,
		"level": level_name,
		"category": category,
		"message": message,
		"formatted": formatted
	})

	# Trim buffer if too large
	if recent_logs.size() > MAX_RECENT_LOGS:
		recent_logs.pop_front()

	# Write to disk file only if level is high enough
	if level >= disk_log_level and log_file:
		log_file.store_line(formatted)
		flush_timer = 0.01  # Mark dirty for next flush

	# Also print errors to console
	if level >= 3:
		push_error(message)
	elif level == 2:
		push_warning(message)

# Convenience functions
func debug(message: String, category: String = "DEBUG"):
	write_log(message, 0, category)

func info(message: String, category: String = "INFO"):
	write_log(message, 1, category)

func warn(message: String, category: String = "WARN"):
	write_log(message, 2, category)

func error(message: String, category: String = "ERROR"):
	write_log(message, 3, category)

# Get recent logs for bug reports (returns all levels from buffer)
func get_recent_logs(count: int = 150) -> Array[Dictionary]:
	var start_index = max(0, recent_logs.size() - count)
	return recent_logs.slice(start_index)

# Get errors and warnings only
func get_error_logs(count: int = 50) -> Array[Dictionary]:
	var errors = recent_logs.filter(func(log): return log.level == "ERROR" or log.level == "WARN")
	var start_index = max(0, errors.size() - count)
	return errors.slice(start_index)

# Force immediate flush (call before critical operations)
func force_flush():
	if log_file:
		log_file.flush()
		flush_timer = 0.0
```

### Where to Add It
Add to project.godot autoload section:
```
DebugLogger="*res://debug_logger.gd"
```

---

## Part 2: Integration Points

### When to Log Things

#### Game Startup/Shutdown
```gdscript
# In loading_screen.gd _ready():
DebugLogger.info("Game started - Loading screen displayed", "GAME")

# When scene changes:
DebugLogger.info("Scene changed to: " + scene_name, "SCENE")

# Before saving:
DebugLogger.force_flush()  # Ensure logs are written before save
```

#### Errors and Warnings
```gdscript
# Critical failures:
if not player_data_loaded:
	DebugLogger.error("Failed to load player data", "SAVE")

# Suspicious states:
if coins < 0:
	DebugLogger.warn("Coins went negative: " + str(coins), "CURRENCY")

# Caught exceptions:
if not resource_loaded:
	DebugLogger.error("Resource load failed: " + path, "RESOURCES")
```

#### Important Game Events
```gdscript
# Player actions:
DebugLogger.info("Player bought shovel upgrade level " + str(level), "SHOP")

# Stat changes:
DebugLogger.info("Strength increased to " + str(strength), "STATS")

# Currency changes:
DebugLogger.info("Copper earned: " + str(amount) + " | Total: " + str(total), "CURRENCY")

# Network events:
DebugLogger.info("Authenticated as: " + username, "NETWORK")
DebugLogger.warn("Cloud save failed, using local fallback", "NETWORK")
```

#### Debug Traces (Development Only)
```gdscript
# Function entry/exit:
DebugLogger.debug("calculate_damage() called with base=" + str(base), "COMBAT")

# State transitions:
DebugLogger.debug("Shop state changed: " + old_state + " -> " + new_state, "SHOP")

# Variable checks:
DebugLogger.debug("ATM unlock check: has_copper=" + str(has_copper) + ", threshold=" + str(threshold), "ATM")
```

### Strategic Placement
- **Global.gd**: Scene changes, stat changes, game state transitions
- **Shop scenes**: Purchases, currency transactions
- **Save/Load systems**: Save/load success/failure with details
- **NakamaClient**: Authentication, cloud operations, network errors
- **Combat/progression**: Stat calculations, upgrades, level-ups
- **Currency systems**: All currency operations (especially negative checks)

---

## Part 3: Bug Report System (Optional - Only if You Have External Playtesters)

### 3.1 Debug Panel in Settings

Add "Report Bug" button to settings that opens bug report panel.

### 3.2 Debug Panel UI (debug_panel.tscn)

**Components**:
- **Recent Errors Display** (Label, scrollable) - Shows last 10 errors/warnings
- **Screenshot Preview** (TextureRect) - Shows captured screenshot
- **Description TextEdit** - Player describes issue
- **Submit Button** - Send to Nakama with screenshot
- **Close Button**

**Simplified Layout**:
```
[Bug Report Panel - Fills Play Area]
+----------------------------------------+
| Recent Errors:                         |
| [14:23:45] ERROR: Null reference...    |
| [14:24:12] WARN: Negative copper       |
| ...                                    |
+----------------------------------------+
| Screenshot (auto-captured):            |
| [                                    ] |
| [      Game screenshot preview       ] |
| [                                    ] |
+----------------------------------------+
| What were you doing when this happened?|
| [                                    ] |
| [        Description text box        ] |
| [                                    ] |
+----------------------------------------+
| [Submit Bug Report]  [Close]           |
+----------------------------------------+
```

### 3.3 Debug Panel Script (debug_panel.gd)

```gdscript
extends Control

@onready var error_display = $ErrorDisplay
@onready var screenshot_preview = $ScreenshotPreview
@onready var description_box = $DescriptionBox
@onready var submit_button = $SubmitButton
@onready var close_button = $CloseButton

var captured_screenshot: Image = null

func _ready():
	submit_button.pressed.connect(_on_submit_pressed)
	close_button.pressed.connect(_on_close_pressed)

	visible = false

func show_panel():
	# Capture screenshot first
	_capture_screenshot()

	# Load recent errors
	_refresh_error_display()

	show()

func _capture_screenshot():
	# Capture current viewport
	await RenderingServer.frame_post_draw
	captured_screenshot = get_viewport().get_texture().get_image()

	# Show preview
	var texture = ImageTexture.create_from_image(captured_screenshot)
	screenshot_preview.texture = texture

func _refresh_error_display():
	var errors = DebugLogger.get_error_logs(10)

	error_display.text = ""

	if errors.is_empty():
		error_display.text = "No recent errors or warnings."
	else:
		for log in errors:
			var time = log.timestamp.split(" ")[1]  # Extract HH:MM:SS
			error_display.text += "[%s] %s: %s\n" % [time, log.level, log.message]

func _on_submit_pressed():
	var description = description_box.text.strip_edges()

	if description.is_empty():
		# Show error feedback
		submit_button.text = "Please add a description!"
		await get_tree().create_timer(2.0).timeout
		submit_button.text = "Submit Bug Report"
		return

	submit_button.disabled = true
	submit_button.text = "Submitting..."

	# Prepare bug report
	var bug_report = {
		"description": description,
		"timestamp": Time.get_datetime_string_from_system(),
		"game_version": "1.0",  # TODO: Pull from version manager
		"recent_logs": DebugLogger.get_recent_logs(150),
		"error_logs": DebugLogger.get_error_logs(50),
		"system_info": _get_system_info(),
		"player_stats": _get_current_stats(),
		"player_progress": _get_current_progress(),
		"screenshot": _screenshot_to_base64()
	}

	# Submit to Nakama (with local backup)
	var success = await BugReporter.submit_bug_report(bug_report)

	if success:
		submit_button.text = "Submitted! Thank you!"
		description_box.text = ""
		await get_tree().create_timer(2.0).timeout
		hide()
	else:
		submit_button.text = "Failed - saved locally"
		await get_tree().create_timer(2.0).timeout

	submit_button.disabled = false
	submit_button.text = "Submit Bug Report"

func _get_system_info() -> Dictionary:
	return {
		"os": OS.get_name(),
		"os_version": OS.get_version(),
		"godot_version": Engine.get_version_info().string,
		"viewport_size": str(get_viewport().size),
		"current_scene": get_tree().current_scene.scene_file_path
	}

func _get_current_stats() -> Dictionary:
	return {
		"strength": Global.strength,
		"constitution": Global.constitution,
		"dexterity": Global.dexterity,
		"wisdom": Global.wisdom,
		"intelligence": Global.intelligence,
		"charisma": Global.charisma
	}

func _get_current_progress() -> Dictionary:
	return {
		"copper": Level1Vars.currency.copper,
		"silver": Level1Vars.currency.silver,
		"gold": Level1Vars.currency.gold,
		"platinum": Level1Vars.currency.platinum,
		"shovel_lvl": Level1Vars.shovel_lvl
	}

func _screenshot_to_base64() -> String:
	if not captured_screenshot:
		return ""

	# Convert to PNG buffer
	var png_buffer = captured_screenshot.save_png_to_buffer()

	# Convert to base64
	return Marshalls.raw_to_base64(png_buffer)

func _on_close_pressed():
	hide()
```

---

## Part 4: Bug Reporter System

### 4.1 BugReporter Autoload (bug_reporter.gd)

```gdscript
extends Node

const LOCAL_BACKUP_DIR = "user://bug_reports/"

func _ready():
	# Ensure backup directory exists
	var dir = DirAccess.open("user://")
	if not dir.dir_exists("bug_reports"):
		dir.make_dir("bug_reports")

# Submit bug report with local backup
func submit_bug_report(report_data: Dictionary) -> bool:
	# Generate unique report ID
	var report_id = _generate_report_id()
	report_data["report_id"] = report_id

	# Save local backup first (always succeeds)
	_save_local_backup(report_id, report_data)

	# Try to submit to Nakama
	if not NakamaClient.is_authenticated:
		DebugLogger.warn("Cannot submit bug report: Not authenticated", "BUG_REPORT")

		# Try device authentication
		await NakamaClient.authenticate_device()

		if not NakamaClient.is_authenticated:
			DebugLogger.info("Bug report saved locally: " + report_id, "BUG_REPORT")
			return false

	# Add user metadata
	report_data["user_id"] = NakamaClient.user_id
	report_data["username"] = NakamaClient.username
	report_data["platform"] = OS.get_name()

	# Submit to Nakama
	var result = await NakamaClient.write_storage("bug_reports", report_id, report_data)

	if result:
		DebugLogger.info("Bug report submitted to cloud: " + report_id, "BUG_REPORT")
		return true
	else:
		DebugLogger.error("Cloud submission failed, local backup saved", "BUG_REPORT")
		return false

func _generate_report_id() -> String:
	var timestamp = Time.get_unix_time_from_system()
	var random_suffix = randi() % 10000
	return "bug_%d_%04d" % [timestamp, random_suffix]

func _save_local_backup(report_id: String, report_data: Dictionary):
	var file_path = LOCAL_BACKUP_DIR + report_id + ".json"
	var file = FileAccess.open(file_path, FileAccess.WRITE)

	if file:
		file.store_string(JSON.stringify(report_data, "\t"))
		file.close()
		DebugLogger.info("Bug report backed up locally: " + file_path, "BUG_REPORT")
	else:
		DebugLogger.error("Failed to save local backup for: " + report_id, "BUG_REPORT")

# Retry failed submissions (call manually or on game start if network available)
func retry_failed_submissions() -> int:
	var dir = DirAccess.open(LOCAL_BACKUP_DIR)
	if not dir:
		return 0

	var retry_count = 0
	dir.list_dir_begin()
	var file_name = dir.get_next()

	while file_name != "":
		if file_name.ends_with(".json"):
			var file_path = LOCAL_BACKUP_DIR + file_name
			var report_data = _load_local_backup(file_path)

			if report_data:
				# Try to submit again
				var report_id = report_data.get("report_id", "unknown")
				var result = await NakamaClient.write_storage("bug_reports", report_id, report_data)

				if result:
					# Success - delete local backup
					dir.remove(file_name)
					retry_count += 1
					DebugLogger.info("Retried bug report submission: " + report_id, "BUG_REPORT")

		file_name = dir.get_next()

	dir.list_dir_end()
	return retry_count

func _load_local_backup(file_path: String) -> Dictionary:
	var file = FileAccess.open(file_path, FileAccess.READ)
	if not file:
		return {}

	var json_string = file.get_as_text()
	file.close()

	var json = JSON.new()
	var error = json.parse(json_string)

	if error == OK:
		return json.data
	else:
		DebugLogger.error("Failed to parse bug report backup: " + file_path, "BUG_REPORT")
		return {}
```

Add to project.godot autoload:
```
BugReporter="*res://bug_reporter.gd"
```

---

## Part 5: Reviewing Bug Reports

### Simple Manual Workflow

When you want to check for new bug reports:

1. **You tell me:** "Check for new bug reports"

2. **I query Nakama manually** using the Nakama REST API or by telling you to export them

3. **You paste the bug report JSON** into our chat

4. **I analyze:**
   - Player description
   - Recent error logs
   - System info
   - Player stats/progress
   - Screenshot (if included)

5. **I suggest fixes:**
   - Identify the issue
   - Propose solution
   - Ask for approval

6. **You approve, and I implement the fix**

### Alternative: Export from Nakama Console
- Log into Nakama console
- Navigate to Storage > bug_reports
- Export reports as JSON
- Share with me for analysis

No automated monitoring needed - just check periodically when you have time.

---

## Part 6: Implementation Workflow

### Phase 1: Core Logging (Do First)
- [ ] Create debug_logger.gd with session-based logs
- [ ] Add to project.godot autoload
- [ ] Test log file creation and rotation
- [ ] Add logging to Global.gd key events
- [ ] Add logging to shop scenes
- [ ] Add logging to save/load systems
- [ ] Add logging to NakamaClient operations

### Phase 2: Bug Reporter (Only if Needed)
- [ ] Create bug_reporter.gd autoload
- [ ] Add to project.godot autoload
- [ ] Test local backup functionality
- [ ] Test Nakama submission

### Phase 3: Bug Report UI (Only if Needed)
- [ ] Create debug_panel.tscn scene
- [ ] Create debug_panel.gd script
- [ ] Add screenshot capture
- [ ] Test full submission flow
- [ ] Add "Report Bug" button to settings

---

## Success Criteria

### Core Logging (Always)
- [ ] Session log files created with timestamps
- [ ] Old logs automatically rotated (keeps last 10)
- [ ] Disk writes batched (no performance impact)
- [ ] Memory buffer captures all levels for bug reports
- [ ] Can adjust disk_log_level for production vs development
- [ ] Logs survive crashes (batch flush works)

### Bug Reporting (If Implemented)
- [ ] Screenshot captured with bug reports
- [ ] Local backup always saves (even if offline)
- [ ] Can retry failed submissions later
- [ ] Bug reports successfully stored in Nakama
- [ ] Can manually review reports when needed

---

## Notes

### Performance
- Batch flushing prevents frame stutters
- DEBUG logs only in memory (not written to disk by default)
- Log rotation prevents unbounded disk usage

### Development vs Production
- **Development**: Set `disk_log_level = 0` to write everything
- **Production**: Set `disk_log_level = 2` to only write warnings/errors

### Bug Reports
- Only implement Part 2-4 if you have external playtesters
- For solo development, just use the logs directly
- Local backups ensure no bug reports are lost

### Log File Location
Logs stored in `user://logs/` which maps to:
- **Windows**: `%APPDATA%\Godot\app_userdata\GoA\logs\`
- **Linux**: `~/.local/share/godot/app_userdata/GoA/logs/`
- **macOS**: `~/Library/Application Support/Godot/app_userdata/GoA/logs/`

---

## Dependencies

**Before This**:
- None (logging is standalone)
- Nakama integration only needed if implementing bug reporter

**After This**:
- All future systems should add logging at key points
- Error handling can reference log files

---

## Files to Create

### Always Create:
- `debug_logger.gd` - Core session-based logger

### Optional (Only if Bug Reporting Needed):
- `bug_reporter.gd` - Bug submission with local backup
- `debug_panel.gd` / `debug_panel.tscn` - Bug report UI

---

## Quick Reference: Logging Best Practices

### Do Log:
- All errors and warnings
- State transitions (scene changes, game state changes)
- Currency transactions (with before/after values)
- Player actions (purchases, upgrades)
- Network operations (auth, cloud saves)
- Save/load operations

### Don't Log:
- Every frame in `_process()`
- Frequent position updates
- Mouse movements
- Render updates
- Trivial getter calls

### Categories to Use:
- `GAME` - Game lifecycle events
- `SCENE` - Scene transitions
- `CURRENCY` - All currency operations
- `SHOP` - Purchases and unlocks
- `STATS` - Stat changes and level-ups
- `SAVE` - Save/load operations
- `NETWORK` - Nakama operations
- `BUG_REPORT` - Bug reporting system
- `LOGGER` - Logger internal operations
