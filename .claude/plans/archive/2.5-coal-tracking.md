# Coal Tracking

**Goal**: Track coal pieces that are delivered to the furnace vs dropped along the way.

**Success Criteria**:
- Level1Vars has coal_dropped and coal_delivered counters
- Coal entering delivery zone increments coal_delivered
- Coal settling below furnace increments coal_dropped
- Each coal piece only increments counters once
- Coal leaving playarea cleans up without tracking
- All tracking is null-safe

## Overview

This phase adds the tracking logic to count coal that successfully makes it into the furnace versus coal that drops along the way. Delivery detection uses Area2D signals (event-based), dropped detection uses position + velocity polling (simpler than Area2D + timer combo). Each coal piece tracks whether it's been counted to prevent duplicates.

---

## Implementation Tasks

### 1. Level1Vars Variables

Add tracking counters to the Level1Vars autoload.

**In autoloads/level1_vars.gd:**
```gdscript
extends Node

# Coal tracking (from 2.2-shovelling-gameplay)
var coal_dropped: int = 0
var coal_delivered: int = 0

# ... (other level1 variables)

func reset_coal_tracking():
    coal_dropped = 0
    coal_delivered = 0
```

**Notes:**
- These are simple integers that increment
- Reset function provided for convenience (e.g., starting new shift)
- Null-safe access in coal_piece.gd (check if Level1Vars exists)

### 2. Delivery Zone Detection

Add Area2D inside furnace opening to detect coal delivery.

**In furnace.tscn:**
- Add Area2D named "DeliveryZone" under playarea/FurnaceWall
- Add CollisionShape2D with RectangleShape2D
- Position inside furnace opening gap
- Size: Full opening height (200px) x 60px wide

**In furnace.gd:**
```gdscript
@onready var delivery_zone: Area2D = $playarea/FurnaceWall/DeliveryZone

func _ready():
    # ... (previous setup)

    # Setup delivery zone
    var delivery_shape = delivery_zone.get_node("CollisionShape2D")
    delivery_shape.position = Vector2(30, furnace_opening_top + (furnace_opening_height / 2))
    delivery_shape.shape.size = Vector2(60, furnace_opening_height)

    # Connect signal
    delivery_zone.body_entered.connect(_on_delivery_zone_entered)

func _on_delivery_zone_entered(body):
    # Check if it's a coal piece
    if body.has_method("_on_entered_delivery_zone"):
        body._on_entered_delivery_zone()
```

**Design values:**
- Zone position X: 30px past furnace line (inside opening)
- Zone width: 60px (generous capture area)
- Zone height: 200px (matches opening height)
- Zone center Y: furnace_opening_top + (furnace_opening_height / 2)

### 3. Boundary Cleanup Zone

Add Area2D around entire playarea to cleanup escaped coal.

**In furnace.tscn:**
- Add Area2D named "BoundaryZone" under playarea
- Add CollisionShape2D with RectangleShape2D
- Set monitoring to false, monitorable to true
- Set to detect body_exited signal

**In furnace.gd:**
```gdscript
@onready var boundary_zone: Area2D = $playarea/BoundaryZone

func _ready():
    # ... (previous setup)

    # Setup boundary zone (covers entire playarea)
    var viewport_size = get_viewport_rect().size
    var boundary_shape = boundary_zone.get_node("CollisionShape2D")
    boundary_shape.position = Vector2(viewport_size.x / 2, viewport_size.y / 2)
    boundary_shape.shape.size = viewport_size

    # Connect signal
    boundary_zone.body_exited.connect(_on_boundary_zone_exited)

func _on_boundary_zone_exited(body):
    # Cleanup coal that left playarea
    if body.has_method("_on_exited_playarea"):
        body._on_exited_playarea()
```

### 4. Coal Tracking Logic

Add tracking state and detection logic to coal pieces.

**In coal_piece.gd:**
```gdscript
extends RigidBody2D

signal coal_delivered
signal coal_dropped

const COAL_PHYSICS_MAT = preload("res://level1/coal_physics_material.tres")
const VELOCITY_THRESHOLD: float = 50.0  # px/sec - below this is "slow"
const SETTLE_DURATION: float = 0.5  # seconds - must be still this long

var has_been_tracked: bool = false
var settle_timer: float = 0.0
var furnace_opening_bottom: float  # Set by furnace.gd when spawned

func _ready():
    # Setup physics properties
    mass = 0.8
    gravity_scale = 1.0
    linear_damp = 0.8
    angular_damp = 1.5

    # Use shared physics material
    physics_material_override = COAL_PHYSICS_MAT

func _physics_process(delta):
    # Don't track if already counted
    if has_been_tracked:
        return

    # Simple dropped detection: below furnace opening and barely moving
    if global_position.y > furnace_opening_bottom:
        var current_speed = linear_velocity.length()

        if current_speed < VELOCITY_THRESHOLD:
            settle_timer += delta
            if settle_timer >= SETTLE_DURATION:
                # Confirmed dropped
                _track_as_dropped()
        else:
            settle_timer = 0.0  # Reset if still moving

# Called by Area2D signal when entering delivery zone
func _on_entered_delivery_zone():
    if has_been_tracked:
        return

    _track_as_delivered()

# Called by Area2D signal when leaving playarea
func _on_exited_playarea():
    queue_free()  # Cleanup without tracking

func _track_as_delivered():
    if Level1Vars:
        Level1Vars.coal_delivered += 1
    has_been_tracked = true
    coal_delivered.emit()
    queue_free()

func _track_as_dropped():
    if Level1Vars:
        Level1Vars.coal_dropped += 1
    has_been_tracked = true
    coal_dropped.emit()
    # Schedule deletion after delay for visual feedback
    get_tree().create_timer(1.0).timeout.connect(queue_free)
```

### 5. Pass Furnace Data to Coal

When spawning coal, pass the furnace opening position for dropped detection.

**In furnace.gd (modify spawn_coal_at_shovel):**
```gdscript
func spawn_coal_at_shovel():
    # Spawn positions relative to shovel
    var spawn_offsets = [-30, -15, 0, 15, 30]

    for offset_x in spawn_offsets:
        var coal = coal_piece_scene.instantiate()
        $playarea.add_child(coal)

        # Set position slightly above shovel
        coal.global_position = shovel.global_position + Vector2(offset_x, -10)

        # Set initial downward velocity
        coal.linear_velocity = Vector2(0, 100)

        # Pass furnace data to coal
        coal.furnace_opening_bottom = furnace_opening_bottom

        # Track coal piece
        active_coal_pieces.append(coal)
```

---

## Testing Checklist

### Level1Vars Tests
- [ ] Level1Vars.coal_dropped exists and initializes to 0
- [ ] Level1Vars.coal_delivered exists and initializes to 0
- [ ] reset_coal_tracking() function resets both to 0

### Delivery Zone Tests
- [ ] DeliveryZone Area2D exists in furnace.tscn
- [ ] DeliveryZone positioned inside furnace opening
- [ ] DeliveryZone size matches opening (200px tall, 60px wide)
- [ ] Coal entering zone triggers _on_delivery_zone_entered
- [ ] Coal calling _on_entered_delivery_zone increments coal_delivered
- [ ] Delivered coal is removed (queue_free)
- [ ] Delivered coal sets has_been_tracked = true

### Boundary Zone Tests
- [ ] BoundaryZone Area2D exists in furnace.tscn
- [ ] BoundaryZone covers entire playarea
- [ ] Coal leaving playarea triggers _on_boundary_zone_exited
- [ ] Coal calling _on_exited_playarea calls queue_free
- [ ] Boundary cleanup does NOT increment counters

### Dropped Detection Tests
- [ ] Coal below furnace_opening_bottom starts settle timer
- [ ] Coal with velocity >= 50 px/sec resets settle timer
- [ ] Coal with velocity < 50 px/sec accumulates settle timer
- [ ] Settle timer reaching 0.5s triggers _track_as_dropped
- [ ] Dropped coal increments coal_dropped
- [ ] Dropped coal sets has_been_tracked = true
- [ ] Dropped coal delays queue_free by 1 second

### Double-Tracking Prevention Tests
- [ ] Coal delivered once cannot be delivered again
- [ ] Coal dropped once cannot be dropped again
- [ ] Coal delivered cannot subsequently be counted as dropped
- [ ] has_been_tracked flag prevents all duplicate tracking

### Null-Safety Tests
- [ ] Coal tracking doesn't crash if Level1Vars is null
- [ ] Code uses `if Level1Vars:` before accessing properties

### Signal Tests
- [ ] coal_delivered signal emits when delivered
- [ ] coal_dropped signal emits when dropped
- [ ] Signals can be connected to for future UI updates

---

## Integration Testing Guide

**Test 1: Successful Delivery**
1. Reset counters: `Level1Vars.reset_coal_tracking()`
2. Scoop coal from pile
3. Slowly move shovel to furnace opening
4. Tilt shovel to let coal slide into opening
5. Expected:
   - coal_delivered increases
   - Coal pieces disappear immediately
   - No increase in coal_dropped

**Test 2: Dropped Coal**
1. Reset counters
2. Scoop coal from pile
3. Move shovel rapidly to make coal fall off
4. Wait for coal to settle on ground (below furnace opening)
5. Wait 0.5+ seconds
6. Expected:
   - coal_dropped increases
   - Coal pieces disappear after 1 second delay
   - No increase in coal_delivered

**Test 3: Mixed Results**
1. Reset counters
2. Scoop coal (5 pieces)
3. Move toward furnace, losing 2 pieces along the way
4. Deliver remaining 3 pieces into furnace
5. Expected:
   - coal_delivered = 3
   - coal_dropped = 2 (after they settle)
   - Total tracked = 5

**Test 4: Boundary Cleanup**
1. Reset counters
2. Scoop coal
3. Move shovel outside playarea bounds
4. Expected:
   - Coal disappears when leaving boundary
   - No increase in counters (cleanup, not tracked)

**Test 5: Fast Furnace Hit**
1. Reset counters
2. Scoop coal
3. Throw coal at furnace obstacles (above/below opening)
4. Coal bounces off and falls
5. Expected:
   - Coal that settles below opening counts as dropped
   - Coal that bounces into opening counts as delivered

---

## Files Modified

- `autoloads/level1_vars.gd` - Added coal_dropped and coal_delivered variables
- `level1/furnace.gd` - Added delivery zone, boundary zone, and signal connections
- `level1/furnace.tscn` - Added DeliveryZone and BoundaryZone Area2D nodes
- `level1/coal_piece.gd` - Added tracking logic, signals, and detection methods

## Files Created

None (modifications only)

---

## Debug Helpers

**Print tracking to console (for testing):**
```gdscript
# In coal_piece.gd _track_as_delivered():
func _track_as_delivered():
    if Level1Vars:
        Level1Vars.coal_delivered += 1
        print("[COAL] Delivered! Total: ", Level1Vars.coal_delivered)
    has_been_tracked = true
    coal_delivered.emit()
    queue_free()

# In coal_piece.gd _track_as_dropped():
func _track_as_dropped():
    if Level1Vars:
        Level1Vars.coal_dropped += 1
        print("[COAL] Dropped! Total: ", Level1Vars.coal_dropped)
    has_been_tracked = true
    coal_dropped.emit()
    get_tree().create_timer(1.0).timeout.connect(queue_free)
```

**Display counters on screen (temporary UI):**
```gdscript
# In furnace.gd, add Label nodes and update in _process():
func _process(_delta):
    if Level1Vars:
        $DebugLabel.text = "Delivered: %d | Dropped: %d" % [
            Level1Vars.coal_delivered,
            Level1Vars.coal_dropped
        ]
```

---

## Notes

**Why delivery zone uses signals but dropped uses polling?**
- Delivery is a single event (coal crosses threshold) - signals are efficient
- Dropped requires settle timer (time-based condition) - polling is simpler
- Combining Area2D + timer for dropped would be more complex with no benefit

**Why 1 second delay before removing dropped coal?**
- Visual feedback - player sees coal settle before it disappears
- Confirms that coal counted as dropped (not a mystery)
- Can be adjusted for feel (0.5s faster, 2s slower pacing)

**Why boundary cleanup doesn't track?**
- Coal leaving playarea is an edge case / physics glitch
- Player shouldn't be penalized for unexpected behavior
- Prevents confusion ("where did that coal go?")
- Keeps cleanup separate from game mechanics

**Priority handling (delivery vs dropped):**
- Delivery check happens in signal handler (immediate)
- Dropped check happens in _physics_process (deferred)
- Both check has_been_tracked flag
- If coal somehow enters delivery zone while below furnace line, delivery wins
- In practice, this overlap shouldn't occur with proper zone positioning

**Next Phase**: Phase 2.2.4 will implement tests and balance tuning.
