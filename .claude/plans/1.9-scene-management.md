# Phase 1.9: Scene Management

**Goal**: Establish clean scene changing API with validation framework, decoupled from specific game mechanics

**Success Criteria**:
- Generic scene changing function with validation hooks
- Save/load integration on scene transitions
- Debug logging for all scene changes
- Validation framework for custom scene rules
- Unit tests for scene changing logic
- Removed coupling to victory/caught systems (being deprecated)

**Prerequisites**:
- Phase 1.3: Global Autoload (Global.gd exists)

---

## Overview

**IMPORTANT: Complete Rewrite Context**
This plan refactors the existing scene management system to be generic and reusable. The current `change_scene_with_check()` is tightly coupled to victory and caught mechanics (being removed). This plan creates a clean, extensible scene changing API that works for all current and future levels.

The scene management system provides the core infrastructure for navigating between game scenes. This plan focuses solely on the **base mechanics**: changing scenes, validation hooks, and logging. The actual **scene network** (which scenes connect to which, unlocks, prerequisites) is handled per-level in feature plans (e.g., 2.2-scene-network.md for copper era).

### Key Design Principles

- **Generic & Reusable**: Works for any scene in any level
- **Validation Hooks**: Extensible framework, not hardcoded rules
- **Decoupled**: No specific game mechanic dependencies (no victory, caught, etc.)
- **Save Before Transition**: Always persist state before scene changes
- **Comprehensive Logging**: Track all transitions for debugging
- **Backend Only**: No transition effects (deferred to future plan)

---

## Architecture Overview

### Data Flow

```
Scene Change Request
  -> Validate (custom validators)
  -> Save game state (cloud or local)
  -> Log transition (debug)
  -> Execute scene change
  -> (future: transition effects)
```

### Component Separation

- **This Plan (1.9)**: Core scene changing API, validation framework
- **Level Plans (2.x, 3.x, etc.)**: Scene networks, specific navigation rules
- **Future Plans**: Transition effects (fade, wipe, etc.)

---

## Implementation Tasks

### 1. Core Scene Changing Function

**File Location**: `res://global.gd`

**Function signature**:
```gdscript
# Change to a new scene with optional validation
func change_scene(scene_path: String, skip_validation: bool = false) -> void:
	# Validate scene transition
	if not skip_validation:
		if not can_change_to_scene(scene_path):
			push_warning("Scene transition blocked by validation: " + scene_path)
			return

	# Get current scene for logging
	var current_scene = ""
	if get_tree() and get_tree().current_scene:
		current_scene = get_tree().current_scene.scene_file_path

	# Save game state before transition
	if NakamaManager.is_authenticated:
		NakamaManager.save_game()
		DebugLogger.log_info("SceneChange", "Cloud save before scene transition")
	else:
		LocalSaveManager.save_game()
		DebugLogger.log_info("SceneChange", "Local save before scene transition")

	# Log the transition
	DebugLogger.log_scene_change(current_scene, scene_path, "Normal scene transition")

	# Execute scene change
	get_tree().change_scene_to_file(scene_path)
```

**Implementation Details**:
- Single function for all scene changes (replaces `change_scene_with_check`)
- Optional `skip_validation` parameter for special cases (debug, testing)
- Always saves before transitioning (prevents data loss)
- Logs all transitions via DebugLogger
- Uses Godot's built-in `change_scene_to_file()`

---

### 2. Validation Framework

**Variables needed**:
```gdscript
# Scene validation system
var scene_validators: Array[Callable] = []
```

**Core validation functions**:
```gdscript
# Register a custom scene validator
func register_scene_validator(validator: Callable) -> void:
	if not scene_validators.has(validator):
		scene_validators.append(validator)

# Remove a scene validator
func unregister_scene_validator(validator: Callable) -> void:
	scene_validators.erase(validator)

# Check if scene transition is allowed
func can_change_to_scene(scene_path: String) -> bool:
	# Run all registered validators
	for validator in scene_validators:
		var result = validator.call(scene_path)
		if not result:
			return false  # Validator blocked transition
	return true  # All validators passed
```

**Usage Example** (from future level plans):
```gdscript
# In copper era scene network plan
func _ready():
	# Register copper era scene validator
	Global.register_scene_validator(_validate_copper_scene)

func _validate_copper_scene(scene_path: String) -> bool:
	# Check if scene is unlocked, player has prerequisites, etc.
	var scene_id = _path_to_id(scene_path)
	if scene_id in locked_scenes:
		Global.show_stat_notification("That area is locked")
		return false
	return true
```

**Implementation Details**:
- Validators are `Callable` functions that return bool
- Multiple validators can be registered (level-specific, feature-specific)
- Validators run in order; first failure blocks transition
- Clean separation: core system provides framework, levels provide rules

---

### 3. Scene Validation Helpers

**Helper functions**:
```gdscript
# Validate that a scene file exists
func scene_exists(scene_path: String) -> bool:
	return ResourceLoader.exists(scene_path)

# Get current scene path
func get_current_scene_path() -> String:
	if get_tree() and get_tree().current_scene:
		return get_tree().current_scene.scene_file_path
	return ""

# Check if transitioning to same scene
func is_current_scene(scene_path: String) -> bool:
	return get_current_scene_path() == scene_path
```

**Built-in validations** (always run):
```gdscript
func can_change_to_scene(scene_path: String) -> bool:
	# Built-in validation: Scene file must exist
	if not scene_exists(scene_path):
		push_error("Scene does not exist: " + scene_path)
		return false

	# Built-in validation: Don't transition to same scene
	if is_current_scene(scene_path):
		push_warning("Already in scene: " + scene_path)
		return false

	# Run custom validators
	for validator in scene_validators:
		var result = validator.call(scene_path)
		if not result:
			return false

	return true
```

---

### 4. Debug Logging Integration

**Already exists in** `debug_logger.gd`, just ensure it's called:

```gdscript
# In DebugLogger (existing)
func log_scene_change(from_scene: String, to_scene: String, reason: String) -> void:
	var message = "Scene: %s -> %s (%s)" % [
		_get_scene_name(from_scene),
		_get_scene_name(to_scene),
		reason
	]
	log_info("SCENE", message)
```

**Integration**:
- Called from `change_scene()` function
- Logs source, destination, and reason
- Tracks all scene transitions for debugging

---

### 5. Backward Compatibility & Migration

**Deprecate old function**:
```gdscript
# DEPRECATED: Use change_scene() instead
# Kept temporarily for backward compatibility during rewrite
func change_scene_with_check(scene_tree: SceneTree, scene_path: String) -> void:
	push_warning("change_scene_with_check() is deprecated. Use Global.change_scene() instead.")
	change_scene(scene_path)
```

**Migration path**:
1. Keep `change_scene_with_check()` as wrapper during rewrite
2. Update all scene transition calls to use `change_scene()`
3. Remove `change_scene_with_check()` once migration complete
4. Remove victory/caught coupling

---

## Code Examples

### Basic Scene Change

```gdscript
# From any scene script
func _on_bar_button_pressed():
	Global.change_scene("res://level1/bar.tscn")
```

### Scene Change with Custom Validation

```gdscript
# Copper era validator (in 2.2-scene-network.md)
func _validate_secret_passage(scene_path: String) -> bool:
	if scene_path == "res://level1/secret_passage.tscn":
		if not Level1Vars.found_secret_door:
			Global.show_stat_notification("You haven't discovered this location yet")
			return false
	return true

# Register on ready
func _ready():
	Global.register_scene_validator(_validate_secret_passage)
```

### Skip Validation (Debug/Testing)

```gdscript
# For debug menu or testing
func _on_debug_warp_pressed():
	Global.change_scene("res://level1/secret_passage.tscn", true)  # Skip validation
```

---

## Testing Strategy

### Unit Tests

Create `tests/test_scene_management.gd`:

```gdscript
extends GutTest

func before_each():
	Global.scene_validators.clear()

# Test: Scene change with no validators
func test_scene_change_no_validators():
	var can_change = Global.can_change_to_scene("res://level1/bar.tscn")
	assert_true(can_change, "Should allow scene change with no validators")

# Test: Scene validation blocked
func test_scene_validation_blocks():
	# Register a validator that always blocks
	Global.register_scene_validator(func(path): return false)

	var can_change = Global.can_change_to_scene("res://level1/bar.tscn")
	assert_false(can_change, "Validator should block scene change")

# Test: Multiple validators
func test_multiple_validators():
	# Validator 1: allows all
	Global.register_scene_validator(func(path): return true)
	# Validator 2: blocks secret passage
	Global.register_scene_validator(func(path): return path != "res://level1/secret_passage.tscn")

	assert_true(Global.can_change_to_scene("res://level1/bar.tscn"), "Bar should be allowed")
	assert_false(Global.can_change_to_scene("res://level1/secret_passage.tscn"), "Secret passage should be blocked")

# Test: Validator registration/unregistration
func test_validator_registration():
	var validator = func(path): return false

	Global.register_scene_validator(validator)
	assert_eq(Global.scene_validators.size(), 1, "Validator registered")

	Global.unregister_scene_validator(validator)
	assert_eq(Global.scene_validators.size(), 0, "Validator unregistered")

# Test: Scene exists validation
func test_scene_exists():
	assert_false(Global.scene_exists("res://nonexistent.tscn"), "Nonexistent scene returns false")
	# Note: Testing existing scene requires actual scene file

# Test: Same scene validation
func test_same_scene_blocked():
	# Mock current scene
	# (Requires integration test with actual scene tree)
	pass
```

**Run tests:**
```bash
godot --headless --script res://addons/gut/gut_cmdln.gd -gtest=tests/test_scene_management.gd
```

### Integration Tests

| Scenario | Setup | Action | Expected Result |
|----------|-------|--------|-----------------|
| Basic scene change | In furnace | Change to bar | Saves, logs, switches scene |
| Blocked by validator | Locked scene | Try to change | Validator blocks, shows message |
| Skip validation | Locked scene | Change with skip=true | Changes anyway (debug) |
| Save before change | Modified stats | Change scene | Stats saved before transition |
| Nonexistent scene | Any scene | Change to invalid path | Error logged, change blocked |

### Manual Test Criteria

- [ ] Navigate between multiple scenes (furnace, bar, shop)
- [ ] Verify save occurs before each transition
- [ ] Check DebugLogger shows all scene transitions
- [ ] Register custom validator, verify it blocks transitions
- [ ] Unregister validator, verify transitions work again
- [ ] Try changing to nonexistent scene, verify error
- [ ] Skip validation in debug mode, verify bypass works

---

## Files to Modify

**global.gd** (~100 lines added/modified)
- Add `scene_validators` array
- Add `change_scene()` function
- Add `register_scene_validator()` function
- Add `unregister_scene_validator()` function
- Add `can_change_to_scene()` function
- Add helper functions (scene_exists, get_current_scene_path, etc.)
- Deprecate `change_scene_with_check()` (keep as wrapper temporarily)
- Remove victory/caught coupling from scene changes

**tests/test_scene_management.gd** (~100 lines new)
- Unit tests for validation framework
- Test validator registration/unregistration
- Test scene existence checks

---

## Design Values (Reference)

### Validation Behavior

- **Multiple validators**: All must pass (AND logic)
- **Validator order**: Registered order (FIFO)
- **Built-in validations**: Always run first (scene exists, not same scene)
- **Skip validation**: Debug/testing only, not for normal gameplay

### Save Behavior

- **When**: Before every scene change (prevents data loss)
- **Where**: Cloud if authenticated, local otherwise
- **What**: Full game state (stats, currency, level vars, etc.)

### Logging

- **Format**: "Scene: [from] -> [to] ([reason])"
- **Category**: "SCENE"
- **Level**: INFO
- **Always logged**: Yes (all transitions tracked)

---

## Dependencies & Integration

### Depends On:
- Phase 1.3 (Global Autoload) - Global.gd exists
- DebugLogger - Scene change logging
- LocalSaveManager - Local save integration
- NakamaManager - Cloud save integration

### Used By:
- **All scene scripts** - Call `Global.change_scene()`
- **Level plans (2.x, 3.x, etc.)** - Register custom validators
- **Debug systems** - Skip validation for testing
- **UI navigation** - Back buttons, scene menus

### Provides APIs For:

**Scene Changing**:
```gdscript
Global.change_scene(scene_path, skip_validation)  # Change scenes
```

**Validation Framework**:
```gdscript
Global.register_scene_validator(callable)    # Add custom rule
Global.unregister_scene_validator(callable)  # Remove custom rule
Global.can_change_to_scene(scene_path)       # Check if allowed
```

**Helpers**:
```gdscript
Global.scene_exists(scene_path)          # Check if scene file exists
Global.get_current_scene_path()          # Get current scene
Global.is_current_scene(scene_path)      # Check if in scene
```

---

## Phase Status

**Status**: Ready for Implementation

**Estimated Time**: 2-3 hours
- 1 hour: Refactor/implement core functions
- 0.5 hours: Remove victory/caught coupling
- 0.5 hours: Unit tests
- 0.5 hours: Integration testing
- 0.5 hours: Update existing scene transitions to new API

**Dependencies Complete**: Yes - Phase 1.3 complete

**Previous Phase**: [1.8-stats-and-experience.md](1.8-stats-and-experience.md)

**Next Phase**: 1.10 - Default Scene (initial scene setup)

**Related Future Plans**:
- **2.2-scene-network.md** - Copper era scene map with unlocks/prerequisites
- **Future** - Transition effects (fade, wipe, etc.)

---

## Notes & Decisions

**Decision 1**: Generic validation framework instead of hardcoded rules
- **Rationale**: Each level/feature can define its own scene rules
- **Benefit**: Extensible, reusable, no base system changes needed per-level
- **Implementation**: Callable array, validators return bool

**Decision 2**: Remove victory/caught coupling
- **Rationale**: These systems are being deprecated/redesigned
- **Benefit**: Clean base system, game-agnostic
- **Note**: Caught/victory logic can be re-added as validators if needed later

**Decision 3**: Always save before scene change
- **Rationale**: Prevents data loss if scene load fails or crashes
- **Benefit**: Player progress never lost on transition
- **Cost**: Minimal (save is fast, already implemented)

**Decision 4**: Single `change_scene()` function
- **Rationale**: Simpler API, one way to change scenes
- **Alternative**: Multiple functions (change_scene_safe, change_scene_force, etc.) - rejected as overcomplicated
- **Note**: `skip_validation` parameter handles special cases

**Decision 5**: Scene network deferred to level plans
- **Rationale**: Each level has different scenes/rules
- **Benefit**: Centralized per-level (copper era map in 2.2, not scattered)
- **Scalability**: Level 2 gets its own network plan, etc.

**Decision 6**: No transition effects yet
- **Rationale**: Backend first, visuals later
- **Benefit**: Can test mechanics without animation dependencies
- **Future**: Separate plan for fade/wipe effects

---

## Implementation Checklist

Before marking Phase 1.9 complete:

- [ ] `scene_validators` array added to global.gd
- [ ] `change_scene()` function implemented
- [ ] `register_scene_validator()` function implemented
- [ ] `unregister_scene_validator()` function implemented
- [ ] `can_change_to_scene()` function implemented
- [ ] Helper functions implemented (scene_exists, get_current_scene_path, etc.)
- [ ] Save integration verified (cloud and local)
- [ ] DebugLogger integration verified
- [ ] `change_scene_with_check()` deprecated (kept as wrapper)
- [ ] Victory/caught coupling removed from scene changes
- [ ] Unit tests written and passing (5+ tests minimum)
- [ ] Integration tests completed
- [ ] Manual tests verified (navigate between scenes)
- [ ] Existing scene transitions updated to new API (or wrapper verified working)
- [ ] Documentation updated (if needed)

---

**Last Updated**: 2025-11-30
**Maintainer**: Claude + User collaboration
**Plan Version**: 1.0 (Complete rewrite - clean scene changing API)
