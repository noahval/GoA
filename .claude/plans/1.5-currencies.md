# Phase 1.5: Currencies

**Goal**: Establish the foundational currency system with 4-tier currency (Copper, Silver, Gold, Platinum), basic operations, and lifetime tracking

**Success Criteria**:
- Currency data structures created in Level1Vars
- Basic add/subtract operations work correctly
- Lifetime currency tracking persists across sessions
- Currency unlock flags implemented
- Save/load integration complete
- All currency operations logged for debugging

**Prerequisites**:
- Phase 1.1: Project Setup (Godot 4.5 project exists)
- Phase 1.2: Project Architecture (folder structure established)
- Phase 1.3: Global Autoload (for notifications, error handling)

---

## Overview

**IMPORTANT: Complete Rewrite Context**
This plan is part of a complete game rewrite. Legacy currency files will be replaced with clean architecture designed for extensibility.

The currency system provides the foundational data structures and basic operations for GoA's 4-tier economy. This phase focuses on **data only** - exchange mechanics, market rates, and UI are in separate phases.

### Key Design Principles

- **Simple Data Structures**: Dictionaries for current and lifetime amounts
- **No Business Logic**: Just data storage and basic operations
- **Extensible**: Built to support market rates (added in Phase 1.6)
- **Persistent Tracking**: Lifetime earnings never decrease
- **Clear Unlock States**: Boolean flags for currency tier access

---

## Architecture Overview

### Data Flow

```
Player earns copper → add_currency() → currency.copper increases
                                    → lifetime_currency.copper increases
                                    → check_currency_unlocks()
                                    → save_game()
```

### Separation of Concerns

- **This phase (1.5)**: Data structures, basic add/subtract
- **Phase 1.6 (Currency Manager)**: Exchange logic, fees, market rate hooks
- **Phase 1.7 (ATM Scene)**: UI for viewing and exchanging
- **Phase 3.1 (Market Volatility)**: Dynamic rate updates

---

## Implementation Tasks

### 1. Currency Data Structures

**File Location**: `res://level1/level_1_vars.gd`

**Variables needed**:
```gdscript
extends Node

# ===== CURRENCY SYSTEM =====

# Current currency holdings
var currency = {
	"copper": 0.0,
	"silver": 0.0,
	"gold": 0.0,
	"platinum": 0.0
}

# Lifetime currency earned (never decreases, tracks total ever earned)
var lifetime_currency = {
	"copper": 0.0,
	"silver": 0.0,
	"gold": 0.0,
	"platinum": 0.0
}

# Currency tier unlock flags
var unlocked_silver: bool = true   # Copper tier always unlocked
var unlocked_gold: bool = false    # Unlocked by gameplay progression
var unlocked_platinum: bool = false # Unlocked by gameplay progression

# Legacy compatibility (syncs with currency.copper)
var coins: float:
	set(value):
		coins = value
		currency.copper = value
	get:
		return currency.copper
```

**Rationale**:
- Dictionaries provide clean access: `currency["copper"]` or `currency.copper`
- Separate lifetime tracking for statistics and unlock progression
- Boolean unlock flags simpler than complex unlock systems
- Legacy `coins` variable maintains backward compatibility

---

### 2. Basic Currency Operations

**Add currency (with lifetime tracking)**:

```gdscript
# Add currency of any type
func add_currency(currency_type: String, amount: float) -> void:
	if not currency_type in currency:
		push_error("Invalid currency type: " + currency_type)
		return

	if amount <= 0:
		push_warning("Attempted to add non-positive amount: %.2f" % amount)
		return

	# Update current holdings
	var old_amount = currency[currency_type]
	currency[currency_type] += amount

	# Update lifetime earnings
	lifetime_currency[currency_type] += amount

	# Check for currency unlocks
	check_currency_unlocks()

	# Log the transaction
	DebugLogger.log_resource_change("currency", currency_type, old_amount, currency[currency_type], "earned")

	# Notify player
	Global.show_notification("Received %.2f %s" % [amount, currency_type])
```

**Subtract currency (with validation)**:

```gdscript
# Deduct currency of any type
func deduct_currency(currency_type: String, amount: float) -> bool:
	if not currency_type in currency:
		push_error("Invalid currency type: " + currency_type)
		return false

	if amount <= 0:
		push_warning("Attempted to deduct non-positive amount: %.2f" % amount)
		return false

	# Check if player has enough
	if currency[currency_type] < amount:
		DebugLogger.log_warning("Insufficient %s: has %.2f, needs %.2f" % [
			currency_type, currency[currency_type], amount
		])
		return false

	# Deduct the amount
	var old_amount = currency[currency_type]
	currency[currency_type] -= amount

	# Log the transaction
	DebugLogger.log_resource_change("currency", currency_type, old_amount, currency[currency_type], "spent")

	return true
```

**Get currency amount**:

```gdscript
# Get current amount of a currency type
func get_currency(currency_type: String) -> float:
	return currency.get(currency_type, 0.0)

# Check if player can afford an amount
func can_afford(currency_type: String, amount: float) -> bool:
	return get_currency(currency_type) >= amount
```

---

### 3. Currency Unlock System

**Unlock checking**:

```gdscript
# Check if any currency tiers should unlock
func check_currency_unlocks() -> void:
	# Gold unlocks when player has 50+ silver
	if not unlocked_gold and currency.silver >= 50.0:
		unlocked_gold = true
		Global.show_notification("Gold currency now accessible")
		DebugLogger.log_milestone("Gold currency unlocked")

	# Platinum unlocks when player has 50+ gold
	if not unlocked_platinum and currency.gold >= 50.0:
		unlocked_platinum = true
		Global.show_notification("Platinum bonds now accessible")
		DebugLogger.log_milestone("Platinum currency unlocked")
```

**Unlock status queries**:

```gdscript
# Check if a currency tier is unlocked
func is_currency_unlocked(currency_type: String) -> bool:
	match currency_type:
		"copper":
			return true  # Always unlocked
		"silver":
			return unlocked_silver  # Always true for now
		"gold":
			return unlocked_gold
		"platinum":
			return unlocked_platinum
		_:
			return false

# Get list of unlocked currencies
func get_unlocked_currencies() -> Array:
	var unlocked = ["copper", "silver"]  # Copper and silver always available
	if unlocked_gold:
		unlocked.append("gold")
	if unlocked_platinum:
		unlocked.append("platinum")
	return unlocked
```

**Rationale**:
- Simple threshold unlocks (50 silver → gold, 50 gold → platinum)
- Can be enhanced later with gameplay requirements
- Unlock checks automatic on currency add
- Notifications inform player of new options

---

### 4. Save/Load Integration

**Save function additions**:

```gdscript
# In existing save_game() function
func save_game() -> void:
	var save_data = {}

	# ... existing save data ...

	# Currency data
	save_data["currency"] = currency.duplicate()
	save_data["lifetime_currency"] = lifetime_currency.duplicate()
	save_data["unlocked_gold"] = unlocked_gold
	save_data["unlocked_platinum"] = unlocked_platinum

	# ... save to file ...
```

**Load function additions**:

```gdscript
# In existing load_game() function
func load_game() -> void:
	# ... load file ...

	# Currency data (with defaults)
	currency = save_data.get("currency", {
		"copper": 0.0,
		"silver": 0.0,
		"gold": 0.0,
		"platinum": 0.0
	})

	lifetime_currency = save_data.get("lifetime_currency", {
		"copper": 0.0,
		"silver": 0.0,
		"gold": 0.0,
		"platinum": 0.0
	})

	unlocked_gold = save_data.get("unlocked_gold", false)
	unlocked_platinum = save_data.get("unlocked_platinum", false)

	# Legacy compatibility
	coins = currency.copper
```

---

### 5. Reset Functions

**Prestige reset (what survives)**:

```gdscript
# Reset for prestige - some currencies persist
func reset_for_prestige() -> void:
	# Reset copper, silver, gold
	currency.copper = 0.0
	currency.silver = 0.0
	currency.gold = 0.0
	# Platinum persists through prestige!

	# Lifetime currencies persist (for statistics)
	# unlocked_gold and unlocked_platinum persist

	DebugLogger.log_milestone("Prestige reset - Platinum preserved")
```

**Full reset (new game)**:

```gdscript
# Complete reset for new game
func reset_all_currency() -> void:
	currency = {
		"copper": 0.0,
		"silver": 0.0,
		"gold": 0.0,
		"platinum": 0.0
	}

	lifetime_currency = {
		"copper": 0.0,
		"silver": 0.0,
		"gold": 0.0,
		"platinum": 0.0
	}

	unlocked_gold = false
	unlocked_platinum = false

	DebugLogger.log_milestone("Currency system reset")
```

---

## Testing Strategy

### Unit Tests

Create `tests/test_currencies.gd`:

```gdscript
extends GutTest

func test_add_currency():
	Level1Vars.currency.copper = 0.0
	Level1Vars.add_currency("copper", 100.0)

	assert_eq(Level1Vars.currency.copper, 100.0, "Copper added correctly")
	assert_eq(Level1Vars.lifetime_currency.copper, 100.0, "Lifetime tracking works")

func test_deduct_currency():
	Level1Vars.currency.silver = 50.0
	var success = Level1Vars.deduct_currency("silver", 30.0)

	assert_true(success, "Deduction succeeded")
	assert_eq(Level1Vars.currency.silver, 20.0, "Silver deducted correctly")

func test_insufficient_funds():
	Level1Vars.currency.gold = 10.0
	var success = Level1Vars.deduct_currency("gold", 20.0)

	assert_false(success, "Deduction failed correctly")
	assert_eq(Level1Vars.currency.gold, 10.0, "Gold unchanged")

func test_currency_unlocks():
	Level1Vars.unlocked_gold = false
	Level1Vars.currency.silver = 49.0
	Level1Vars.check_currency_unlocks()
	assert_false(Level1Vars.unlocked_gold, "Gold not unlocked at 49 silver")

	Level1Vars.currency.silver = 50.0
	Level1Vars.check_currency_unlocks()
	assert_true(Level1Vars.unlocked_gold, "Gold unlocked at 50 silver")

func test_lifetime_tracking():
	Level1Vars.currency.copper = 0.0
	Level1Vars.lifetime_currency.copper = 0.0

	Level1Vars.add_currency("copper", 100.0)
	Level1Vars.deduct_currency("copper", 50.0)

	assert_eq(Level1Vars.currency.copper, 50.0, "Current is 50")
	assert_eq(Level1Vars.lifetime_currency.copper, 100.0, "Lifetime still 100")

func test_prestige_reset():
	Level1Vars.currency.platinum = 10.0
	Level1Vars.currency.copper = 1000.0
	Level1Vars.lifetime_currency.copper = 5000.0
	Level1Vars.unlocked_gold = true

	Level1Vars.reset_for_prestige()

	assert_eq(Level1Vars.currency.platinum, 10.0, "Platinum persists")
	assert_eq(Level1Vars.currency.copper, 0.0, "Copper reset")
	assert_eq(Level1Vars.lifetime_currency.copper, 5000.0, "Lifetime persists")
	assert_true(Level1Vars.unlocked_gold, "Unlocks persist")

func test_save_load():
	Level1Vars.currency.copper = 123.45
	Level1Vars.lifetime_currency.silver = 678.90
	Level1Vars.unlocked_platinum = true

	Level1Vars.save_game()

	Level1Vars.currency.copper = 0.0
	Level1Vars.lifetime_currency.silver = 0.0
	Level1Vars.unlocked_platinum = false

	Level1Vars.load_game()

	assert_almost_eq(Level1Vars.currency.copper, 123.45, 0.01, "Copper loaded")
	assert_almost_eq(Level1Vars.lifetime_currency.silver, 678.90, 0.01, "Lifetime loaded")
	assert_true(Level1Vars.unlocked_platinum, "Unlocks loaded")
```

**Run tests:**
```bash
godot --headless --script res://addons/gut/gut_cmdln.gd -gtest=tests/test_currencies.gd
```

### Manual Test Criteria

- [ ] Add currency via console: `Level1Vars.add_currency("copper", 100)`
- [ ] Verify notification appears
- [ ] Check DebugLogger shows transaction
- [ ] Verify lifetime amount increases
- [ ] Deduct currency: `Level1Vars.deduct_currency("copper", 50)`
- [ ] Verify deduction works and current amount decreases
- [ ] Verify lifetime amount unchanged
- [ ] Test insufficient funds returns false
- [ ] Add 50 silver, verify gold unlocks
- [ ] Add 50 gold, verify platinum unlocks
- [ ] Save game, exit, reload, verify all values persist

---

## Files to Create

None - all modifications to existing files

## Files to Modify

**level1/level_1_vars.gd** (~150 lines added)
- Currency dictionaries
- Unlock flags
- add_currency() function
- deduct_currency() function
- check_currency_unlocks() function
- is_currency_unlocked() function
- get_unlocked_currencies() function
- reset functions
- Save/load updates

**tests/test_currencies.gd** (~200 lines new)
- Unit tests for all currency operations
- Unlock testing
- Save/load testing
- Prestige reset testing

---

## Design Values (Reference)

### Currency Unlock Thresholds

- **Copper**: Always unlocked (starting currency)
- **Silver**: Always unlocked (accessible from start)
- **Gold**: Unlocks at 50 silver holdings
- **Platinum**: Unlocks at 50 gold holdings

**Rationale**: Progressive unlocking based on accumulation, not complex requirements

### Prestige Persistence

**Resets on prestige:**
- Copper amount
- Silver amount
- Gold amount

**Persists through prestige:**
- Platinum amount (special escape currency)
- All lifetime earnings
- Currency unlock flags

**Rationale**: Platinum is the escape currency for Level 1 completion, should never reset

### Conversion Ratios (Reference)

Approximate 1000:1 ratios between tiers:
- 1000 copper ≈ 1 silver
- 1000 silver ≈ 1 gold
- 1000 gold ≈ 1 platinum

**Note**: Exact conversion handled by Currency Manager (Phase 1.6) with market rates

---

## Integration Points

### Uses Global APIs

```gdscript
Global.show_notification(message)  # Player feedback
```

### Uses DebugLogger

```gdscript
DebugLogger.log_resource_change("currency", type, old, new, reason)
DebugLogger.log_milestone("Currency unlocked")
DebugLogger.log_warning("Insufficient funds")
```

### Provides APIs For

**Currency Manager (1.6):**
- `get_currency(type)` - Read current amounts
- `add_currency(type, amount)` - Award currency
- `deduct_currency(type, amount)` - Spend currency
- `is_currency_unlocked(type)` - Check accessibility

**ATM Scene (1.7):**
- `get_unlocked_currencies()` - Populate dropdowns
- `currency` dictionary - Display current holdings
- `lifetime_currency` dictionary - Statistics

**Gameplay Systems:**
- All earning systems use `add_currency()`
- All purchase systems use `can_afford()` and `deduct_currency()`

---

## Dependencies & Integration

### Depends On:
- Phase 1.3 (Global Autoload) - Notifications, error handling

### Used By:
- Phase 1.6 (Currency Manager) - Exchange operations
- Phase 1.7 (ATM Scene) - Display and UI
- Phase 2.x (Copper Era) - Earning and spending
- Phase 3.x (Economy) - Market systems

---

## Phase Status

**Status**: Planning Complete - Ready for Implementation

**Estimated Time**: 3-4 hours
- 1 hour: Data structures and basic operations
- 1 hour: Unlock system
- 0.5 hours: Save/load integration
- 1 hour: Unit tests
- 0.5 hours: Manual testing and verification

**Dependencies Complete**: Yes - Assumes Phase 1.3 complete

**Previous Phase**: [1.3-global-autoload.md](1.3-global-autoload.md)

**Next Phase**: 1.6 - Currency Manager (exchange logic, market rate hooks)

---

## Notes & Decisions

**Decision 1**: Dictionary-based currency storage
- **Rationale**: Flexible, easy to extend with new currencies
- **Alternative**: Separate variables (more verbose)
- **Benefit**: Uniform access pattern, easy iteration

**Decision 2**: Lifetime tracking separate from current
- **Rationale**: Statistics and progression tracking
- **Use case**: "You've earned 10,000 copper over all time"
- **Benefit**: Never resets, even on prestige

**Decision 3**: Simple unlock thresholds (50 units)
- **Rationale**: Easy to understand and implement
- **Can enhance**: Add gameplay requirements later if needed
- **Current**: Automatic on reaching threshold

**Decision 4**: Platinum persists through prestige
- **Rationale**: Escape currency for Level 1 completion
- **Thematic**: Hidden wealth that can't be confiscated
- **Mechanical**: Long-term goal, not reset by prestige

**Decision 5**: Legacy coins variable sync
- **Rationale**: Backward compatibility during rewrite
- **Implementation**: Setter/getter syncs with currency.copper
- **Future**: Can be removed after full migration

---

## Open Questions

- [ ] Should there be a maximum currency cap per type?
- [ ] Should lifetime earnings display somewhere in UI?
- [ ] Do we want currency conversion history tracking here or in Currency Manager?
- [ ] Should unlock thresholds be configurable constants?

---

## Implementation Checklist

Before marking this phase complete:

- [ ] Currency dictionaries added to level_1_vars.gd
- [ ] Unlock flags added
- [ ] add_currency() function implemented
- [ ] deduct_currency() function implemented
- [ ] can_afford() function implemented
- [ ] check_currency_unlocks() implemented
- [ ] is_currency_unlocked() implemented
- [ ] get_unlocked_currencies() implemented
- [ ] reset_for_prestige() updated
- [ ] reset_all_currency() implemented
- [ ] Save/load functions updated
- [ ] Legacy coins sync working
- [ ] Unit tests written and passing
- [ ] Manual tests completed
- [ ] DebugLogger integration verified
- [ ] Documentation updated

---

**Last Updated**: 2025-11-28
**Maintainer**: Claude + User collaboration
**Plan Version**: 1.0 (Complete rewrite - write once architecture)
