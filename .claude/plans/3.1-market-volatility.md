# Phase 3.1: Market Volatility

**Goal**: Add dynamic market rate fluctuations to the currency system using bell curve distribution, timed updates, and grimdark flavor notifications

**Success Criteria**:
- Market rates update every 15-30 minutes
- Rates follow bell curve distribution (±30% max, extremes rare)
- Platinum remains stable (always 1.0)
- Extreme volatility triggers grimdark notifications
- No UI changes needed (ATM reads modifiers automatically)
- System can be toggled on/off for testing

**Prerequisites**:
- Phase 1.6: Currency Manager (modifiers exist, set to 1.0)
- Phase 1.7: ATM Scene (displays rates, works with any modifier values)

---

## Overview

**IMPORTANT: Pure Plugin Architecture**
This phase adds market dynamics by simply updating `CurrencyManager.conversion_rate_modifiers` in a `_process()` loop. **Zero code changes** to Currency Manager logic or ATM UI. The system was built for this from day one.

Market volatility adds economic realism and discovery-based gameplay. Players observe rate changes and learn optimal exchange timing through experience, not tutorials.

### Key Design Principles

- **Non-Invasive**: Just updates existing modifier variables
- **Bell Curve Distribution**: Most changes moderate, extremes rare
- **Timed Updates**: Random 15-30 minute intervals
- **Platinum Stability**: Anchor currency never fluctuates
- **Grimdark Flavor**: Extreme rate changes have thematic notifications
- **Toggleable**: Dev mode can disable for testing

---

## Implementation Tasks

### 1. Market Update Timer System

**Add to currency_manager.gd**:

```gdscript
# ===== MARKET VOLATILITY SYSTEM =====

# Market update timing
var market_update_timer: float = 0.0
var next_market_update_interval: float = 900.0  # 15 minutes default

# Volatility tracking (for statistics/notifications)
var market_volatility: Dictionary = {
	CurrencyType.COPPER: 0.0,   # Current deviation from 1.0
	CurrencyType.SILVER: 0.0,
	CurrencyType.GOLD: 0.0
	# Platinum not included (no volatility)
}

# Toggle for testing
var market_volatility_enabled: bool = true

# Process loop for market updates
func _process(delta: float) -> void:
	if not market_volatility_enabled:
		return

	market_update_timer += delta

	if market_update_timer >= next_market_update_interval:
		market_update_timer = 0.0
		update_market_rates()
```

---

### 2. Bell Curve Volatility System

**Market rate update function**:

```gdscript
# Update market rates using bell curve distribution
func update_market_rates() -> void:
	# Set next update interval (random 15-30 minutes)
	next_market_update_interval = randf_range(900.0, 1800.0)

	# Update copper, silver, gold (platinum always 1.0)
	for currency_type in [CurrencyType.COPPER, CurrencyType.SILVER, CurrencyType.GOLD]:
		# Bell curve: normal distribution, std dev 0.1
		var deviation = randfn(0.0, 0.1)

		# Clamp to ±30% max range
		deviation = clamp(deviation, -0.3, 0.3)

		# Store deviation for tracking
		market_volatility[currency_type] = deviation

		# Apply to modifier (1.0 + deviation)
		conversion_rate_modifiers[currency_type] = 1.0 + deviation

	# Check for extreme volatility notifications
	_check_extreme_volatility()

	# Debug logging
	DebugLogger.log_info("MarketUpdate", "Rates: C=%.2f, S=%.2f, G=%.2f, P=1.00" % [
		conversion_rate_modifiers[CurrencyType.COPPER],
		conversion_rate_modifiers[CurrencyType.SILVER],
		conversion_rate_modifiers[CurrencyType.GOLD]
	])

# Check for extreme volatility and show notifications
func _check_extreme_volatility() -> void:
	for currency_type in [CurrencyType.COPPER, CurrencyType.SILVER, CurrencyType.GOLD]:
		var notification = get_extreme_market_notification(currency_type)
		if notification != "":
			Global.show_notification(notification)
```

**Bell curve characteristics**:
- ~68% of rates within ±10% (deviation -0.1 to +0.1)
- ~95% of rates within ±20% (deviation -0.2 to +0.2)
- ~99.7% within ±30% (deviation -0.3 to +0.3)
- Extreme swings (±20-30%) are rare (2-5% chance)

---

### 3. Grimdark Market Notifications

**Extreme volatility flavor text**:

```gdscript
# Get grimdark notification for extreme market movements
# Only triggers for ±20-30% deviations
func get_extreme_market_notification(currency_type: CurrencyType) -> String:
	var volatility = market_volatility.get(currency_type, 0.0)

	# Only show notifications for extremes (±20%+)
	if abs(volatility) < 0.2:
		return ""

	var is_high = volatility > 0.2  # Currency strong/valuable
	var variant = randi() % 3  # Random variant (0, 1, or 2)

	match currency_type:
		CurrencyType.COPPER:  # Laborers (fluctuates vs silver)
			if is_high:  # Laborers doing WELL, copper VALUABLE
				match variant:
					0: return "Furnace accident: labor shortage drives copper rates"
					1: return "Infection culls the workforce: survivors demand more"
					2: return "Mass conscription: fewer hands, higher wages"
			else:  # Laborers DESPERATE, copper WEAK
				match variant:
					0: return "Coal quotas doubled: labor value plummets"
					1: return "New work camp opened: copper floods the vaults"
					2: return "Vagrant roundup successful: desperate hands abundant"

		CurrencyType.SILVER:  # Merchants/artisans (fluctuates vs gold)
			if is_high:  # Merchants doing WELL, silver VALUABLE
				match variant:
					0: return "Resupply delayed: merchants hoard reserves"
					1: return "Black market disrupted: silver gains legitimacy"
					2: return "Guild masters bribe the Council: rates improve"
			else:  # Merchants DESPERATE, silver WEAK
				match variant:
					0: return "Guild regulations tightened: merchant desperation grows"
					1: return "Trade permits revoked: silver devalues rapidly"
					2: return "Factory owners demand tribute: middle class squeezed"

		CurrencyType.GOLD:  # Nobles/gentry (fluctuates vs platinum)
			if is_high:  # Nobles doing WELL, gold VALUABLE
				match variant:
					0: return "Military contract awarded: nobles enriched"
					1: return "Housing rights restricted: gold becomes scarce"
					2: return "Council favor shifts: titled families consolidate"
			else:  # Nobles DESPERATE, gold WEAK
				match variant:
					0: return "Estate taxes raised: nobility liquidating assets"
					1: return "War bonds called: old money bleeds gold"
					2: return "Succession crisis: desperate lords sell holdings"

	return ""
```

**Notification design notes**:
- 18 total variants (3 high + 3 low for each of 3 currencies)
- Viewpoint: Wealthy bank operators explaining market conditions
- High modifier = currency/class is powerful (valuable)
- Low modifier = currency/class is desperate (weak)
- Platinum has no notifications (stable anchor)

---

### 4. Dev Tools Integration

**Toggle volatility for testing**:

```gdscript
# In DevTools.gd (if exists) or via console

# Disable market volatility (lock rates at 1.0)
func disable_market_volatility() -> void:
	CurrencyManager.market_volatility_enabled = false
	CurrencyManager.conversion_rate_modifiers[CurrencyManager.CurrencyType.COPPER] = 1.0
	CurrencyManager.conversion_rate_modifiers[CurrencyManager.CurrencyType.SILVER] = 1.0
	CurrencyManager.conversion_rate_modifiers[CurrencyManager.CurrencyType.GOLD] = 1.0
	print("Market volatility disabled - rates locked at 1.0")

# Enable market volatility
func enable_market_volatility() -> void:
	CurrencyManager.market_volatility_enabled = true
	CurrencyManager.update_market_rates()  # Trigger immediate update
	print("Market volatility enabled")

# Force market update (for testing)
func force_market_update() -> void:
	CurrencyManager.update_market_rates()
	print("Market rates updated")
```

---

### 5. Save/Load Behavior

**Market rates do NOT persist** (intentional):

```gdscript
# In currency_manager.gd _ready()
func _ready() -> void:
	# Generate fresh market rates on game load
	# This prevents save-scumming (reloading to get better rates)
	update_market_rates()

	DebugLogger.log_info("CurrencyManager", "Market system initialized")
```

**Rationale**: Fresh rates on each session prevents exploits and encourages playing with whatever rates the market gives.

---

## Testing Strategy

### Unit Tests

Create `tests/test_market_volatility.gd`:

```gdscript
extends GutTest

func test_bell_curve_distribution():
	# Generate 1000 samples to verify distribution
	var samples = []
	for i in range(1000):
		var deviation = randfn(0.0, 0.1)
		deviation = clamp(deviation, -0.3, 0.3)
		samples.append(deviation)

	# Count distribution
	var within_10_percent = 0
	var within_20_percent = 0

	for sample in samples:
		if abs(sample) <= 0.1:
			within_10_percent += 1
		if abs(sample) <= 0.2:
			within_20_percent += 1

	# Should be approximately 68% within ±10%, 95% within ±20%
	assert_true(within_10_percent >= 600 and within_10_percent <= 750, "~68% within ±10%")
	assert_true(within_20_percent >= 900, "~95% within ±20%")

func test_market_update_changes_rates():
	CurrencyManager.conversion_rate_modifiers[CurrencyManager.CurrencyType.COPPER] = 1.0

	CurrencyManager.update_market_rates()

	var new_rate = CurrencyManager.conversion_rate_modifiers[CurrencyManager.CurrencyType.COPPER]

	# Rate should have changed (very unlikely to stay exactly 1.0)
	# Allow small chance of staying 1.0 (within margin)
	assert_true(new_rate >= 0.7 and new_rate <= 1.3, "Rate within valid range")

func test_platinum_always_stable():
	CurrencyManager.update_market_rates()

	assert_eq(
		CurrencyManager.conversion_rate_modifiers[CurrencyManager.CurrencyType.PLATINUM],
		1.0,
		"Platinum always 1.0"
	)

func test_extreme_notifications():
	# Force extreme deviation
	CurrencyManager.market_volatility[CurrencyManager.CurrencyType.COPPER] = 0.25

	var notification = CurrencyManager.get_extreme_market_notification(
		CurrencyManager.CurrencyType.COPPER
	)

	assert_true(notification != "", "Extreme volatility triggers notification")
	assert_true(notification.length() > 20, "Notification has content")

func test_moderate_no_notification():
	# Moderate deviation
	CurrencyManager.market_volatility[CurrencyManager.CurrencyType.SILVER] = 0.15

	var notification = CurrencyManager.get_extreme_market_notification(
		CurrencyManager.CurrencyType.SILVER
	)

	assert_eq(notification, "", "Moderate volatility has no notification")

func test_disable_volatility():
	CurrencyManager.market_volatility_enabled = false
	CurrencyManager.conversion_rate_modifiers[CurrencyManager.CurrencyType.COPPER] = 1.0

	# Process shouldn't update rates
	CurrencyManager._process(1000.0)  # 1000 seconds

	assert_eq(
		CurrencyManager.conversion_rate_modifiers[CurrencyManager.CurrencyType.COPPER],
		1.0,
		"Rates unchanged when disabled"
	)
```

**Run tests:**
```bash
godot --headless --script res://addons/gut/gut_cmdln.gd -gtest=tests/test_market_volatility.gd
```

### Manual Test Criteria

**Test 1: Market Updates Over Time**
- [ ] Start game
- [ ] Open ATM, note rates (e.g., "1 silver = 1000 copper")
- [ ] Wait 15-20 minutes (or speed up timer in debugger)
- [ ] Check ATM again, rates should have changed
- [ ] Repeat several times to observe variety

**Test 2: Bell Curve Distribution**
- [ ] Force 20+ market updates: `CurrencyManager.update_market_rates()`
- [ ] Observe rate changes in debugger or ATM display
- [ ] Most changes should be moderate (±10%)
- [ ] Occasional larger swings (±20%)
- [ ] Rare extreme swings (±25-30%)

**Test 3: Extreme Volatility Notifications**
- [ ] Force updates until extreme deviation occurs
- [ ] Verify notification appears
- [ ] Check notification is thematic (grimdark, class-based)
- [ ] Verify only shows for ±20%+ deviations

**Test 4: Platinum Stability**
- [ ] Force 50+ market updates
- [ ] Check platinum rate always shows "1 platinum = 1000 gold"
- [ ] Modifier always 1.0

**Test 5: Exchange with Dynamic Rates**
- [ ] Note current copper-silver rate (e.g., 1275)
- [ ] Exchange 100 copper
- [ ] Verify received amount reflects current rate
- [ ] Wait for market update
- [ ] Exchange again with new rate
- [ ] Verify different received amount

**Test 6: Save/Load Rate Reset**
- [ ] Note current market rates
- [ ] Save game
- [ ] Load game
- [ ] Verify rates are different (fresh generation)
- [ ] Confirms no save-scumming

**Test 7: Disable Volatility (Dev Mode)**
- [ ] Run: `CurrencyManager.market_volatility_enabled = false`
- [ ] Set all modifiers to 1.0
- [ ] Wait extended time
- [ ] Verify rates stay at 1.0
- [ ] Useful for testing exchange logic

---

## Files to Create

**tests/test_market_volatility.gd** (~200 lines new)
- Bell curve distribution tests
- Market update tests
- Notification tests
- Platinum stability tests

## Files to Modify

**autoloads/currency_manager.gd** (~150 lines added)
- Market update timer variables
- _process() function
- update_market_rates() function
- _check_extreme_volatility() function
- get_extreme_market_notification() function
- Toggle for testing

---

## Design Values (Reference)

### Bell Curve Distribution

**Standard deviation: 0.1**
- Mean: 0.0 (no deviation)
- 1σ: ±10% (68% of samples)
- 2σ: ±20% (95% of samples)
- 3σ: ±30% (99.7% of samples)

**Practical rates**:
- Very common: 900-1100 (±10%)
- Common: 800-1200 (±20%)
- Rare: 700-1300 (±30%)

### Update Timing

**Random interval: 15-30 minutes**
- Minimum: 900 seconds (15 minutes)
- Maximum: 1800 seconds (30 minutes)
- Average: 1350 seconds (22.5 minutes)

**Rationale**: Long enough players can't easily exploit, short enough to feel dynamic

### Notification Thresholds

**Show notifications:**
- Deviation > +0.2 (> +20% strong)
- Deviation < -0.2 (< -20% weak)

**No notifications:**
- -0.2 to +0.2 (normal market fluctuation)

**Frequency**: With ~5% chance of extreme, expect notification every ~5-10 updates (2-5 hours of play)

---

## Integration Points

### Modifies CurrencyManager

```gdscript
CurrencyManager.conversion_rate_modifiers  # Updates these values
CurrencyManager.market_volatility  # Tracks current deviations
```

### Uses Global

```gdscript
Global.show_notification(message)  # Extreme volatility alerts
```

### Uses DebugLogger

```gdscript
DebugLogger.log_info("MarketUpdate", details)  # Log rate changes
```

### Read By

**ATM Scene (1.7):**
- Reads `conversion_rate_modifiers` via `get_market_rates_display()`
- No code changes needed - already built for dynamic rates

**Currency Manager (1.6):**
- Exchange calculations use modifiers automatically
- No code changes needed - already built for this

---

## Phase Status

**Status**: Planning Complete - Ready for Implementation

**Estimated Time**: 3-4 hours
- 1 hour: Timer and update system
- 1 hour: Bell curve volatility generation
- 0.5 hours: Grimdark notification text
- 0.5 hours: Dev tools integration
- 1 hour: Testing (distribution verification, extreme events)

**Dependencies Complete**: Yes - Assumes Phases 1.6 and 1.7 complete

**Previous Phase**: 1.7 - ATM Scene (UI already handles dynamic rates)

**Next Phase**: Other economy features (market trends, advanced stats, etc.)

---

## Notes & Decisions

**Decision 1**: Bell curve distribution
- **Rationale**: Natural-feeling randomness, extremes rare
- **Alternative**: Uniform distribution (too many extremes)
- **Formula**: `randfn(0.0, 0.1)` gives normal distribution

**Decision 2**: Don't persist market rates
- **Rationale**: Prevents save-scumming
- **Benefit**: Fresh rates each session encourages adaptation
- **Tradeoff**: Player can't plan around known rates

**Decision 3**: Random update intervals
- **Rationale**: Less predictable than fixed intervals
- **Range**: 15-30 minutes feels right for pacing
- **Benefit**: Can't easily wait for specific time

**Decision 4**: Platinum always stable
- **Rationale**: Anchor currency for stability
- **Thematic**: Escape currency, protected from market
- **Mechanical**: Players can hold platinum to avoid volatility

**Decision 5**: Extreme notifications only
- **Rationale**: Don't spam player with every small change
- **Threshold**: ±20% is significant enough to matter
- **Frequency**: Rare enough to feel special

**Decision 6**: Grimdark class-based flavor
- **Rationale**: Thematic consistency with game world
- **Viewpoint**: Bank operators explaining economic forces
- **Tone**: Oppressive, matter-of-fact about suffering

---

## Open Questions

- [ ] Should we show time until next market update?
- [ ] Do we want market trend indicators (rising/falling)?
- [ ] Should intelligence stat reveal market patterns?
- [ ] Do we want player-triggered market events (big purchases affect rates)?
- [ ] Should there be seasonal/story-driven market changes?

---

## Implementation Checklist

Before marking this phase complete:

- [ ] Market timer variables added to CurrencyManager
- [ ] _process() function implemented
- [ ] update_market_rates() function implemented
- [ ] Bell curve generation working
- [ ] Rates clamped to ±30%
- [ ] Platinum always 1.0
- [ ] _check_extreme_volatility() implemented
- [ ] get_extreme_market_notification() implemented
- [ ] All 18 notification variants written
- [ ] Dev toggle for testing
- [ ] Fresh rates on _ready()
- [ ] Unit tests written and passing
- [ ] Distribution tests verify bell curve
- [ ] Manual tests completed
- [ ] Verified ATM updates without code changes
- [ ] Verified exchanges use new rates correctly
- [ ] DebugLogger integration working

---

**Last Updated**: 2025-11-28
**Maintainer**: Claude + User collaboration
**Plan Version**: 1.0 (Pure plugin - zero changes to existing systems)
