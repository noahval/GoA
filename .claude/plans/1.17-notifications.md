# Phase 1.13: Notifications System

**Goal**: Create unified notification system for displaying temporary messages with queueing, stat level-up feedback with variety, and notification history tracking

**Success Criteria**:
- `Global.show_notification(message, type)` API works
- Max 3 notifications visible simultaneously
- Queue system for 4+ notifications (FIFO)
- Dynamic auto-removal timer (1 sec + 45ms per character)
- Stat level-up notifications with message variety (3-5 variants per stat)
- Notifications persist across scene changes
- Click notification bar opens history panel (links to Plan 1.14)
- No animations (instant appear/disappear for performance)
- Type parameter supports future differentiation (info, stat, warning, etc.)

**Prerequisites**:
- Phase 1.3 (Global Autoload) - Global.gd exists
- Phase 1.11 (Responsive Layout) - NotificationBar defined (120px base, scales to 180px at 1080p)

---

## Overview

Provides a centralized system for displaying temporary translucent notifications at the bottom of the screen. Handles automatic stacking (max 3 visible), queueing for overflow, dynamic duration based on message length, and stat level-up feedback with variety. Designed for minimal performance impact with instant appearance/removal and clean memory management.

### Key Design Principles

- **Unified API**: Single function for all notification types
- **Performance first**: No animations, instant appear/disappear
- **Smart queueing**: Max 3 visible (fits in notification bar), queue beyond that
- **Persistent**: Notifications survive scene changes
- **Extensible**: Type parameter future-proofs for visual differentiation
- **Stat variety**: 3-5 message variants per stat to reduce repetition
- **History tracking**: All notifications saved for history panel (Plan 1.14)

---

## Architecture Overview

### Data Flow

```
Gameplay Event/Stat Level-Up
    ↓
show_notification(message, type)
    ↓
Add to notification_history (save all)
    ↓
Check visible count
    ↓
If < 3: Display immediately
If >= 3: Add to notification_queue
    ↓
Create Panel + Label + Timer
    ↓
Add to NotificationBar (auto-stacks via VBoxContainer)
    ↓
Timer expires → Remove → Check queue → Display next
```

### Component Separation

- **This Plan (1.13)**: Notification display, queueing, stat variety, history tracking
- **Plan 1.14**: History panel UI in play area (filter, scroll, close)
- **Plan 1.8**: Stat system that triggers notifications on level-up
- **Plan 1.11**: Layout defines NotificationBar positioning and scaling

---

## Implementation Tasks

### 1. Notification Data Structures

**File**: `res://global.gd`

**Variables needed**:
```gdscript
# ===== NOTIFICATION SYSTEM =====

# Currently visible notifications (max 3)
var active_notifications: Array[Dictionary] = []

# Queue for overflow (4+ notifications)
var notification_queue: Array[Dictionary] = []

# Complete history (for history panel - Plan 1.14)
var notification_history: Array[Dictionary] = []

# Notification types (future differentiation)
enum NotificationType {
    INFO,      # General messages
    STAT,      # Stat level-ups
    WARNING,   # Warnings/errors
    SUCCESS    # Achievements/milestones
}
```

**Dictionary Structure**:
```gdscript
# Active notification entry:
{
    "message": String,              # Text to display
    "type": NotificationType,       # Notification type
    "panel": Panel,                 # UI panel node
    "label": Label,                 # Text label node
    "timer": Timer                  # Auto-removal timer
}

# Queue entry (before displayed):
{
    "message": String,
    "type": NotificationType
}

# History entry:
{
    "message": String,
    "type": NotificationType
}
```

---

### 2. Core Notification API

**Function**: `show_notification(message: String, type: NotificationType = NotificationType.INFO)`

```gdscript
func show_notification(message: String, type: NotificationType = NotificationType.INFO) -> void:
    """
    Display a notification with automatic queueing if max visible reached.

    Args:
        message: Text to display
        type: Notification type (INFO, STAT, WARNING, SUCCESS)
    """
    # Create notification data
    var notification_data = {
        "message": message,
        "type": type
    }

    # Add to history (for Plan 1.14 history panel)
    # Array order = chronological order (newest at end)
    notification_history.append(notification_data.duplicate())

    # Check if we can display immediately
    if active_notifications.size() < 3:
        _display_notification(notification_data)
    else:
        # Queue for later display
        notification_queue.append(notification_data)
```

**Usage Examples**:
```gdscript
# General message
Global.show_notification("You've been caught!")

# Stat level-up (called from stat setters)
Global.show_notification("You feel stronger", Global.NotificationType.STAT)

# Warning
Global.show_notification("Low stamina!", Global.NotificationType.WARNING)

# Success
Global.show_notification("Achievement unlocked!", Global.NotificationType.SUCCESS)
```

---

### 3. Display Notification (Internal)

**Function**: `_display_notification(notification_data: Dictionary)`

```gdscript
func _display_notification(notification_data: Dictionary) -> void:
    """
    Create and display a notification panel.
    Internal - called by show_notification() or queue processor.
    """
    # Find NotificationBar container
    var notification_bar = _find_notification_bar()
    if not notification_bar:
        push_warning("No NotificationBar found in current scene")
        return

    # Create panel
    var notification_panel = Panel.new()
    notification_panel.custom_minimum_size = Vector2(0, 40)  # Base height (scales via layout)

    # Style panel (translucent dark background)
    var style_box = StyleBoxFlat.new()
    style_box.bg_color = Color(0.15, 0.15, 0.15, 0.4)  # Dark grey, 40% opacity
    style_box.corner_radius_top_left = 8
    style_box.corner_radius_top_right = 8
    style_box.corner_radius_bottom_left = 8
    style_box.corner_radius_bottom_right = 8
    style_box.content_margin_top = 5
    style_box.content_margin_bottom = 5
    style_box.content_margin_left = 10
    style_box.content_margin_right = 10
    style_box.expand_margin_top = 3  # Spacing between stacked notifications
    style_box.expand_margin_bottom = 3
    notification_panel.add_theme_stylebox_override("panel", style_box)

    # Create label
    var notification_label = Label.new()
    notification_label.text = notification_data.message
    notification_label.horizontal_alignment = HORIZONTAL_ALIGNMENT_CENTER
    notification_label.vertical_alignment = VERTICAL_ALIGNMENT_CENTER
    notification_label.add_theme_color_override("font_color", Color(1, 1, 1, 1))  # White
    notification_label.autowrap_mode = TextServer.AUTOWRAP_WORD_SMART

    # Fill panel (anchor to all edges)
    notification_label.anchor_left = 0
    notification_label.anchor_right = 1
    notification_label.anchor_top = 0
    notification_label.anchor_bottom = 1

    notification_panel.add_child(notification_label)

    # Create timer (dynamic duration)
    var notification_timer = Timer.new()
    notification_timer.one_shot = true
    notification_timer.wait_time = 1.0 + (len(notification_data.message) * 0.045)  # 1 sec + 45ms per char
    add_child(notification_timer)  # Child of Global (persists across scenes)

    # Update notification_data with UI references
    notification_data["panel"] = notification_panel
    notification_data["label"] = notification_label
    notification_data["timer"] = notification_timer

    # Add to active list
    active_notifications.append(notification_data)

    # Connect timer to removal
    notification_timer.timeout.connect(func(): _remove_notification(notification_data))

    # Add to scene
    notification_bar.add_child(notification_panel)

    # Apply responsive scaling (font size based on resolution)
    var scaled_font_size = ResponsiveLayout.get_scaled_font_size()
    notification_label.add_theme_font_size_override("font_size", scaled_font_size)

    # Start timer
    notification_timer.start()
```

---

### 4. Remove Notification & Process Queue

**Function**: `_remove_notification(notification_data: Dictionary)`

```gdscript
func _remove_notification(notification_data: Dictionary) -> void:
    """
    Remove notification from screen and process queue.
    Internal - called by timer timeout.
    """
    # Remove from active list
    var index = active_notifications.find(notification_data)
    if index != -1:
        active_notifications.remove_at(index)

    # Free UI nodes
    if notification_data.has("panel") and notification_data.panel:
        notification_data.panel.queue_free()
    if notification_data.has("timer") and notification_data.timer:
        notification_data.timer.queue_free()

    # Process queue if notifications waiting
    if notification_queue.size() > 0:
        var next_notification = notification_queue.pop_front()
        _display_notification(next_notification)
```

**Queue Logic**:
- FIFO (first in, first out)
- When notification removed → check queue → display next
- Smooth continuous flow when many notifications arrive

---

### 5. Find NotificationBar (Helper)

**Function**: `_find_notification_bar() -> Node`

```gdscript
func _find_notification_bar() -> Node:
    """
    Find NotificationBar in current scene.
    Handles scene template structure.
    """
    var current_scene = get_tree().current_scene
    if not current_scene:
        return null

    # NotificationBar is direct child of SceneRoot (from Plan 1.11 template)
    var notification_bar = current_scene.get_node_or_null("NotificationBar")
    return notification_bar
```

**Note**: Simplified from old system - no portrait mode, single location

---

### 6. Stat Notification Variants

**Stat Messages with Variety**:

```gdscript
# Stat message pools (3-5 variants each)
const STAT_MESSAGES = {
    "strength": [
        "You feel stronger",
        "Your muscles harden",
        "Power surges through you",
        "You can lift more weight",
        "Raw strength flows into your limbs"
    ],
    "dexterity": [
        "You feel more precise",
        "Your movements sharpen",
        "Agility comes naturally",
        "Your hands move with grace",
        "Reflexes quicken"
    ],
    "constitution": [
        "You feel more resilient",
        "Your body toughens",
        "Endurance wells up within",
        "You can withstand more",
        "Vitality courses through you"
    ],
    "intelligence": [
        "You feel smarter",
        "Clarity fills your mind",
        "Understanding deepens",
        "Patterns become clear",
        "Knowledge expands"
    ],
    "wisdom": [
        "You feel more introspective",
        "Insight dawns upon you",
        "Perception sharpens",
        "The world makes more sense",
        "Wisdom settles in"
    ],
    "charisma": [
        "You understand people better",
        "Social grace comes easier",
        "Others seem drawn to you",
        "Words flow more smoothly",
        "Presence strengthens"
    ]
}

func _get_stat_message(stat_name: String) -> String:
    """
    Get random message variant for stat level-up.
    Returns consistent message if stat not in pool.
    """
    var messages = STAT_MESSAGES.get(stat_name.to_lower(), [])
    if messages.is_empty():
        return "You feel improved"  # Fallback

    # Pick random variant
    return messages[randi() % messages.size()]
```

---

### 7. Stat Notification Integration

**Update stat setters in global.gd**:

```gdscript
# Example: Strength setter (update all six stats similarly)
var strength: int = 1:
    set(value):
        if is_node_ready() and value > strength:
            var message = _get_stat_message("strength")
            show_notification(message, NotificationType.STAT)
        strength = value

# Apply same pattern to: dexterity, constitution, intelligence, wisdom, charisma
```

**Before**: Simple hardcoded message
**After**: Random variant from pool, proper type parameter

---

### 8. Notification Bar Click Handler

**Add to NotificationBar setup** (in ResponsiveLayout or scene template):

```gdscript
# In scene_template.tscn or ResponsiveLayout.apply_to_scene()
func _setup_notification_bar_click(notification_bar: Control) -> void:
    """
    Make notification bar clickable to open history panel.
    Links to Plan 1.14 (Notification History Panel).
    """
    # Create invisible clickable area covering entire NotificationBar
    var click_area = Button.new()
    click_area.flat = true
    click_area.anchor_left = 0
    click_area.anchor_right = 1
    click_area.anchor_top = 0
    click_area.anchor_bottom = 1
    click_area.mouse_filter = Control.MOUSE_FILTER_PASS

    # Connect to history panel opener (implemented in Plan 1.14)
    click_area.pressed.connect(_on_notification_bar_clicked)

    notification_bar.add_child(click_area)

func _on_notification_bar_clicked() -> void:
    """
    Open notification history panel in play area.
    Implementation in Plan 1.14.
    """
    # TODO: Open NotificationHistoryPanel in play area
    # See Plan 1.14 for implementation
    pass
```

**Future**: Plan 1.14 implements full history panel UI

---

### 9. History Management

**History Persistence** (optional - can add later):

```gdscript
func save_notification_history() -> void:
    """
    Save notification history to save data.
    Optional: Can limit to last N notifications to prevent bloat.
    """
    # Limit history to last 100 notifications
    var history_to_save = notification_history.slice(-100) if notification_history.size() > 100 else notification_history

    # Save to game save (integrate with save system)
    # Format: Array of {message, type, timestamp}

func load_notification_history(save_data: Dictionary) -> void:
    """
    Load notification history from save data.
    """
    notification_history = save_data.get("notification_history", [])
```

**Note**: Can defer persistence to Plan 1.14 if history is session-only

---

## Testing Strategy

### Unit Tests

Create `tests/test_notifications.gd`:

```gdscript
extends GutTest

func before_each():
    Global.active_notifications.clear()
    Global.notification_queue.clear()
    Global.notification_history.clear()

# Test: Show notification under max (< 3)
func test_show_notification_immediate():
    Global.show_notification("Test message")
    assert_eq(Global.active_notifications.size(), 1, "Notification added to active")
    assert_eq(Global.notification_history.size(), 1, "Notification added to history")

# Test: Queue overflow (4+ notifications)
func test_notification_queueing():
    Global.show_notification("Message 1")
    Global.show_notification("Message 2")
    Global.show_notification("Message 3")
    Global.show_notification("Message 4")  # Should queue

    assert_eq(Global.active_notifications.size(), 3, "Max 3 active")
    assert_eq(Global.notification_queue.size(), 1, "4th queued")
    assert_eq(Global.notification_history.size(), 4, "All in history")

# Test: Timer duration calculation
func test_dynamic_duration():
    Global.show_notification("Short")
    var timer1 = Global.active_notifications[0].timer

    Global.show_notification("This is a much longer message with many characters")
    var timer2 = Global.active_notifications[1].timer

    assert_gt(timer2.wait_time, timer1.wait_time, "Longer message = longer duration")

# Test: Stat message variety
func test_stat_message_variety():
    var messages_seen = {}

    # Trigger 20 strength notifications
    for i in range(20):
        var msg = Global._get_stat_message("strength")
        messages_seen[msg] = true

    assert_gt(messages_seen.size(), 1, "Multiple message variants used")

# Test: Notification types
func test_notification_types():
    Global.show_notification("Info", Global.NotificationType.INFO)
    Global.show_notification("Stat", Global.NotificationType.STAT)

    assert_eq(Global.active_notifications[0].type, Global.NotificationType.INFO)
    assert_eq(Global.active_notifications[1].type, Global.NotificationType.STAT)
```

### Integration Tests

| Scenario | Setup | Action | Expected Result |
|----------|-------|--------|-----------------|
| Normal notification flow | 0 active | Show 1 notification | Appears immediately, timer starts |
| Queue processing | 3 active | Show 4th notification | 4th queued, appears after 1st expires |
| Scene change persistence | 2 active notifications | Change scene | Notifications still visible in new scene |
| Stat level-up | STR=1, 0 XP | Add 100 XP | Random strength message appears |
| History tracking | Empty history | Show 5 notifications | All 5 in history array |

### Manual Test Criteria

- [ ] Show notification via console: `Global.show_notification("Test")`
- [ ] Notification appears at bottom, dark translucent background
- [ ] Auto-removes after ~1-2 seconds (based on length)
- [ ] Show 4 notifications rapidly - max 3 visible, 4th queued
- [ ] When 1st expires, 4th appears automatically
- [ ] Level up a stat - random message variant appears
- [ ] Level up same stat multiple times - see different messages
- [ ] Click notification bar - history panel opens (Plan 1.14)
- [ ] Change scenes - active notifications persist
- [ ] Font scales correctly at 1080p (25px → 37px)

---

## Files to Create

- None (uses existing global.gd and scene_template.tscn)

## Files to Modify

- `global.gd` (~200 lines added)
  - Notification data structures (arrays, enum)
  - show_notification() API
  - _display_notification() internal
  - _remove_notification() and queue processing
  - _find_notification_bar() helper
  - STAT_MESSAGES constant pool
  - _get_stat_message() randomizer
  - Update all six stat setters to use show_notification()

- `scene_template.tscn` (minor - optional)
  - Add click handler to NotificationBar (for Plan 1.14)

---

## Design Values (Reference)

### Notification Dimensions

| Property | Value | Formula |
|----------|-------|---------|
| Panel height (base) | 40px | Set in code |
| Panel spacing | 6px | 3px expand top + 3px expand bottom |
| Corner radius | 8px | Rounded corners |
| Content margin | 5/10px | Top/bottom: 5px, Left/right: 10px |

**Scales with resolution** (via ResponsiveLayout):
- 1280x720: 40px panels, 25px font
- 1920x1080: 60px panels, 37px font (1.5x)

### Timing

| Parameter | Value | Rationale |
|-----------|-------|-----------|
| Base duration | 1 second | Minimum display time |
| Per-character duration | 0.045 seconds (45ms) | Longer messages stay longer |
| Max visible | 3 notifications | Fits in 120px bar (3×40px + spacing) |

**Examples**:
- "You feel stronger" (17 chars): 1 + (17 × 0.045) = 1.765 seconds
- "Achievement unlocked!" (22 chars): 1 + (22 × 0.045) = 1.99 seconds
- "Very long message..." (50 chars): 1 + (50 × 0.045) = 3.25 seconds

### Colors

| Element | Color | Opacity | Hex |
|---------|-------|---------|-----|
| Background | Dark grey | 40% | rgba(38, 38, 38, 0.4) |
| Text | White | 100% | #FFFFFF |

**Future types** (not implemented yet):
- INFO: Dark grey background (current)
- STAT: Could add blue tint
- WARNING: Could add orange tint
- SUCCESS: Could add green tint

### Stat Message Pools

Each stat has **5 variants** to reduce repetition:
- Strength: 5 messages
- Dexterity: 5 messages
- Constitution: 5 messages
- Intelligence: 5 messages
- Wisdom: 5 messages
- Charisma: 5 messages

**Random selection**: `randi() % messages.size()`

---

## Dependencies & Integration

### Depends On:
- Phase 1.3 (Global Autoload) - Global.gd exists
- Phase 1.11 (Responsive Layout) - NotificationBar positioning, get_scaled_font_size()

### Used By:
- **Plan 1.8** (Stats & Experience) - Stat setters call show_notification()
- **Plan 1.14** (Notification History Panel) - Reads notification_history array
- **All gameplay features** - Generic notification API for events

### Provides APIs For:

**Gameplay Code**:
```gdscript
Global.show_notification(message, type)  # Display notification
```

**History Panel (Plan 1.14)**:
```gdscript
Global.notification_history  # Access full history
```

**Stat System**:
```gdscript
# Auto-called from stat setters
Global._get_stat_message(stat_name)  # Random variant
```

---

## Phase Status

**Status**: Ready for Implementation

**Estimated Time**: 3-4 hours
- 1 hour: Core notification display and queueing logic
- 1 hour: Stat message variants and integration
- 1 hour: Testing (unit + integration + manual)
- 30 min: History tracking and click handler stub

**Dependencies Complete**:
- Phase 1.3 (Global Autoload) - Required
- Phase 1.11 (Responsive Layout) - Required

**Previous Phase**: [1.12-ui-scale-slider.md](1.12-ui-scale-slider.md)

**Next Phase**: [1.14-notification-history-panel.md](1.14-notification-history-panel.md)

---

## Notes & Decisions

**Decision 1**: Max 3 visible notifications
- **Rationale**: Fits perfectly in notification bar (3×40px + spacing = ~130px < 120px scaled bar)
- **Benefit**: Clean UI, no overflow outside designated area

**Decision 2**: Queue system (not replacement)
- **Rationale**: Don't lose notifications, show all eventually
- **Benefit**: User sees all messages in order
- **Alternative considered**: Replace oldest with newest (rejected - losing information is bad)

**Decision 3**: Stat message variety (5 variants each)
- **Rationale**: Reduces repetition without overwhelming content creation
- **Benefit**: Feels less robotic, more game-like
- **Alternative considered**: Single message (rejected - too repetitive), 10+ variants (rejected - diminishing returns)

**Decision 4**: No animations
- **Rationale**: Performance, simplicity, instant feedback
- **Benefit**: Zero performance overhead, crisp appearance
- **Alternative considered**: Fade in/out (rejected - adds complexity, requires tweens)

**Decision 5**: Type parameter for future differentiation
- **Rationale**: Easy to add visual differences later (colors, icons)
- **Implementation**: Enum now, visual styling deferred
- **Benefit**: Clean migration path when needed

**Decision 6**: Click to open history
- **Rationale**: Natural interaction, uses existing notification bar space
- **Benefit**: Discoverable, consistent with mobile patterns
- **Implementation**: Stub in this plan, full UI in Plan 1.14

**Decision 7**: Persist across scene changes
- **Rationale**: Important messages shouldn't disappear mid-transition
- **Benefit**: Player doesn't miss critical info
- **Implementation**: Timers are children of Global (survives scene changes)

---

## Implementation Checklist

Before marking this phase complete:

- [ ] Notification data structures added (active, queue, history, enum)
- [ ] show_notification() API implemented
- [ ] _display_notification() creates panels and labels
- [ ] _remove_notification() cleans up and processes queue
- [ ] Max 3 visible enforced
- [ ] Queue FIFO processing works
- [ ] _find_notification_bar() helper implemented
- [ ] STAT_MESSAGES pool created (5 variants per stat)
- [ ] _get_stat_message() randomizer implemented
- [ ] All six stat setters updated to use show_notification()
- [ ] Dynamic timer works (1 sec + 45ms per char)
- [ ] Notification history tracking works
- [ ] Click handler stub added (links to Plan 1.14)
- [ ] Notifications persist across scene changes
- [ ] Font scaling works (25px → 37px at 1080p)
- [ ] Unit tests written and passing
- [ ] Integration tests verified
- [ ] Manual tests completed
- [ ] No memory leaks (queue_free() called correctly)

---

**Last Updated**: 2025-11-30
**Maintainer**: Claude + User collaboration
