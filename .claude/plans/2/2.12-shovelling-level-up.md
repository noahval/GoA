# Shovelling Level-Up System

**Goal**: Implement roguelike-style upgrade selection UI triggered by player level-ups

**Success Criteria**: Player levels up, Mind button appears, player selects upgrades in Mind scene until upgrades_qty matches player_level, returns to furnace

**Prerequisites**:
- 2.x-shovel-experience.md (Strength XP and level-up system)
- 2.x-upgrade-pool.md (Technique definitions)

## Overview

When the player levels up their shoveling skill (player level increases via coal delivery XP from 2.x-shovel-experience.md), they gain access to the Mind scene where they select shovelling technique upgrades.

**Note**: Per plan 2.x-shovel-experience.md, `Level1Vars.player_level` represents the player's shoveling mastery level (separate from Global's D&D-style stats). The Mind button in the furnace menu becomes visible when `Level1Vars.player_level > Level1Vars.upgrades_qty`. After selecting upgrades until caught up, the player returns to the furnace.

This plan focuses on the **UI flow and selection mechanics**. The actual gameplay effects of selected upgrades will be implemented in 2.x-apply-upgrade.md.

### Key Design Principles

- **Roguelike card presentation** - Upgrades display as cards with icon, name, level/progress, description, and tooltip-enabled text
- **Future-proof layout** - Design accommodates 2-4 upgrade choices (currently 2, expandable later)
- **Loop until caught up** - Player selects upgrades repeatedly until `upgrades_qty == Level1Vars.player_level`
- **Stub effect system** - Store selections without applying gameplay effects yet (deferred to 2.x-apply-upgrade.md)

---

## Implementation Tasks

### 1. Level1Vars Upgrade Tracking

Track how many upgrades the player has selected this run.

**Variables needed**:
```gdscript
# In level1/level_1_vars.gd
var upgrades_qty: int = 0  # Total upgrades selected this run

# Dictionary tracking selected techniques and their levels
# Format: {"balance": 2, "rhythm": 1} means Balance lvl 2, Rhythm lvl 1
var selected_techniques: Dictionary = {}

# Branch selection ("manual", "auto", or "" if not chosen yet)
var technique_branch: String = ""
```

**Implementation details**:
- `upgrades_qty` increments each time player selects an upgrade
- `selected_techniques` stores technique_id -> level mapping
- `technique_branch` locks player into Manual Mastery or Automation after first selection
- Reset these variables when starting a new run (Level1Vars should have a reset function)

---

### 2. Mind Button Visibility Logic

Show/hide the Mind button in the furnace menu based on level-up status.

**Location**: [level1/furnace.gd](../../game/v0.1/level1/furnace.gd)

**Add Mind button to furnace menu**:
- Mind button should be hidden by default in furnace.tscn
- Button text: "Mind" (theme: ForwardNavButton)
- Position: Below existing furnace menu buttons

**Visibility check function**:
```gdscript
# In furnace.gd
func _update_mind_button_visibility():
    # Show Mind button when player has unspent level-ups
    var has_pending_upgrades = Level1Vars.player_level > Level1Vars.upgrades_qty
    mind_button.visible = has_pending_upgrades
```

**When to call**:
- When furnace scene loads (`_ready()`)
- When returning from Mind scene (`_on_tree_entered()` or similar)
- After player level-up (Level1Vars emits notification when leveling up)

**Note**: The player level-up notification ("Level up! You are now level X") is shown by Level1Vars._show_levelup_notification() when the player gains enough XP.

---

### 3. Mind Scene UI Layout

Create the upgrade selection interface with space for up to 4 options.

**File**: [level1/mind.tscn](../../game/v0.1/level1/mind.tscn) (already exists with ToFurnaceButton)

**Scene structure**:
```
Mind (inherits scene_template.tscn)
  AspectContainer/MainContainer
    Background (TextureRect - mind.jpg)
    mainarea/
      Menu/
        ToFurnaceButton (existing)
      PlayArea/
        UpgradeContainer (HBoxContainer)
          UpgradeCard1 (Panel - custom style)
          UpgradeCard2 (Panel - custom style)
          UpgradeCard3 (Panel - hidden initially, for future expansion)
          UpgradeCard4 (Panel - hidden initially, for future expansion)
```

**Layout specifications**:
- **UpgradeContainer**: Centered in PlayArea, uses HBoxContainer with spacing
- **Card count**: Show 2 cards currently, hide cards 3-4 (reserved for future upgrade)
- **Card sizing**: Each card should be ~300-400px wide, flexible height
- **Spacing**: 20-30px between cards for visual separation

**Individual upgrade card structure**:
```
UpgradeCard (Panel with custom theme)
  VBoxContainer (margin 10px)
    IconContainer (TextureRect or ColorRect placeholder)
    NameLabel (Label - larger font, technique name)
    LevelLabel (Label - "Level 1" or "NEW")
    DescriptionLabel (RichTextLabel - technique description)
    SelectButton (Button - "Select")
```

**Card styling**:
- Use Panel with custom StyleBox (border, background color)
- Rarity-based border colors (Common: gray, Rare: blue, Epic: purple, Legendary: gold)
- Hover state: Slight scale or brightness change

---

### 4. Upgrade Selection Logic

Generate random upgrade options and handle player selection.

**File**: [level1/mind.gd](../../game/v0.1/level1/mind.gd)

**Load technique data**:
```gdscript
# At top of mind.gd
const TECHNIQUES = preload("res://data/techniques.gd").TECHNIQUES
```

**Generate upgrade options**:
```gdscript
func _generate_upgrade_options(count: int) -> Array:
    # Returns array of technique_ids (e.g., ["balance", "rhythm"])

    var available_techniques = []

    # First selection: offer from entire pool
    if Level1Vars.technique_branch == "":
        available_techniques = TECHNIQUES.keys()
    else:
        # Subsequent selections: filter by branch and exclude maxed techniques
        for tech_id in TECHNIQUES.keys():
            var tech = TECHNIQUES[tech_id]

            # Must match player's chosen branch
            if tech.branch != Level1Vars.technique_branch:
                continue

            # Exclude maxed techniques
            var current_level = Level1Vars.selected_techniques.get(tech_id, 0)
            var max_level = _get_max_level_for_rarity(tech.rarity)
            if current_level >= max_level:
                continue

            available_techniques.append(tech_id)

    # Shuffle and take first 'count' items
    available_techniques.shuffle()
    return available_techniques.slice(0, count)

func _get_max_level_for_rarity(rarity: String) -> int:
    # From 2.x-upgrade-pool.md
    match rarity:
        "common": return 5
        "rare": return 4
        "epic": return 3
        "legendary": return 2
        _: return 1
```

**Display upgrade cards**:
```gdscript
func _display_upgrade_options(technique_ids: Array):
    # Populate card 1 and card 2 with technique data
    for i in range(min(technique_ids.size(), 2)):
        var tech_id = technique_ids[i]
        var tech = TECHNIQUES[tech_id]
        var card = upgrade_cards[i]  # Reference to UpgradeCard1/2 nodes

        # Set card data
        card.get_node("VBoxContainer/NameLabel").text = tech.name
        card.get_node("VBoxContainer/DescriptionLabel").text = tech.description

        # Show current level or "NEW"
        var current_level = Level1Vars.selected_techniques.get(tech_id, 0)
        if current_level > 0:
            card.get_node("VBoxContainer/LevelLabel").text = "Level %d" % current_level
        else:
            card.get_node("VBoxContainer/LevelLabel").text = "NEW"

        # Set rarity-based border color
        _apply_rarity_styling(card, tech.rarity)

        # Connect Select button
        var select_btn = card.get_node("VBoxContainer/SelectButton")
        select_btn.pressed.connect(_on_upgrade_selected.bind(tech_id))

        card.visible = true
```

**Handle selection**:
```gdscript
func _on_upgrade_selected(tech_id: String):
    # Increment technique level
    var current_level = Level1Vars.selected_techniques.get(tech_id, 0)
    Level1Vars.selected_techniques[tech_id] = current_level + 1

    # Lock branch on first selection
    if Level1Vars.technique_branch == "":
        Level1Vars.technique_branch = TECHNIQUES[tech_id].branch

    # Increment total upgrades
    Level1Vars.upgrades_qty += 1

    # Check if more upgrades needed
    if Level1Vars.upgrades_qty < Level1Vars.player_level:
        # Generate new options
        var new_options = _generate_upgrade_options(2)
        _display_upgrade_options(new_options)
    else:
        # All caught up, return to furnace
        SceneNetwork.go_to("furnace")
```

---

### 5. Tooltip System (Basic)

Implement hover tooltips for highlighted/colored text in descriptions.

**Approach**: Use RichTextLabel's `meta_clicked` signal for clickable text, or create a simple Tooltip panel that follows mouse.

**For now (minimal implementation)**:
- Use plain text descriptions without embedded tooltips
- Mark this as a future enhancement (can add in 2.x-content-and-balance.md)

**Alternative (if time permits)**:
- Add a Tooltip Panel (Label with Panel background) that becomes visible on mouse hover
- Position it near the card being hovered
- Populate with additional explanation text for game mechanics

**Decision**: Defer complex tooltip system to later plan. Use clear descriptions for now.

---

### 6. Stub Effect Application

Store selected upgrades but don't modify gameplay variables yet.

**What this plan does**:
- Stores `Level1Vars.selected_techniques = {"balance": 2, "rhythm": 1}`
- Stores `Level1Vars.technique_branch = "manual"`
- Does NOT modify `Level1Vars.shovel_tilt_torque` or other gameplay variables

**What 2.x-apply-upgrade.md will do**:
- Read `Level1Vars.selected_techniques`
- Apply effects to gameplay (e.g., multiply torque, modify stamina drain rates)
- Implement runtime checks (Zone Out proc chance, Pattern Recognition warning timing)
- Handle stacking for multi-level techniques

**Placeholder comment**:
```gdscript
# In mind.gd _on_upgrade_selected()
# NOTE: Actual gameplay effects are applied in 2.x-apply-upgrade.md
# For now, we only store the selection in Level1Vars.selected_techniques
```

---

## Testing Strategy

### Unit Tests (Headless)

Create `tests/test_shovelling_levelup.gd`:

```gdscript
extends GutTest

# Test suite for shovelling level-up system (Plan 2.12)

func before_each():
    # Reset to baseline
    Level1Vars.player_level = 1
    Level1Vars.upgrades_qty = 0
    Level1Vars.selected_techniques = {}
    Level1Vars.technique_branch = ""

# =============================================================================
# Mind Button Visibility Tests
# =============================================================================

func test_mind_button_hidden_when_no_levelups():
    # Setup: No level difference
    Level1Vars.player_level = 1
    Level1Vars.upgrades_qty = 1

    # Would check button visibility here (requires scene loading)
    # For headless test, verify logic instead
    var should_show = Level1Vars.player_level > Level1Vars.upgrades_qty
    assert_false(should_show, "Mind button should be hidden when caught up")

func test_mind_button_visible_when_levelup_pending():
    # Setup: Player leveled up but hasn't selected upgrade
    Level1Vars.player_level = 2
    Level1Vars.upgrades_qty = 1

    var should_show = Level1Vars.player_level > Level1Vars.upgrades_qty
    assert_true(should_show, "Mind button should be visible when level > upgrades")

# =============================================================================
# Selection Tracking Tests
# =============================================================================

func test_first_selection_locks_branch():
    # Simulate selecting "balance" (manual branch)
    Level1Vars.technique_branch = ""

    # Mock selection
    Level1Vars.technique_branch = "manual"

    assert_eq(Level1Vars.technique_branch, "manual", "Branch locked to manual")

func test_technique_level_increments():
    # Select Balance twice
    Level1Vars.selected_techniques["balance"] = 1
    Level1Vars.selected_techniques["balance"] += 1

    assert_eq(Level1Vars.selected_techniques["balance"], 2, "Balance is level 2")

func test_upgrades_qty_increments():
    Level1Vars.upgrades_qty = 0

    # Simulate 3 selections
    Level1Vars.upgrades_qty += 1
    Level1Vars.upgrades_qty += 1
    Level1Vars.upgrades_qty += 1

    assert_eq(Level1Vars.upgrades_qty, 3, "3 upgrades selected")

# =============================================================================
# Upgrade Loop Logic Tests
# =============================================================================

func test_loop_continues_when_behind():
    Level1Vars.player_level = 3
    Level1Vars.upgrades_qty = 1

    var should_continue = Level1Vars.upgrades_qty < Level1Vars.player_level
    assert_true(should_continue, "Should offer more upgrades when behind")

func test_loop_exits_when_caught_up():
    Level1Vars.player_level = 2
    Level1Vars.upgrades_qty = 2

    var should_continue = Level1Vars.upgrades_qty < Level1Vars.player_level
    assert_false(should_continue, "Should exit to furnace when caught up")

# =============================================================================
# Max Level Tests
# =============================================================================

func test_common_max_level():
    # Common techniques max at level 5
    var max_level = 5  # Would call _get_max_level_for_rarity("common")
    assert_eq(max_level, 5, "Common techniques max at 5")

func test_legendary_max_level():
    # Legendary techniques max at level 2
    var max_level = 2  # Would call _get_max_level_for_rarity("legendary")
    assert_eq(max_level, 2, "Legendary techniques max at 2")
```

**Run tests**:
```bash
godot --headless --script res://tests/test_runner.gd
```

---

### Integration Tests

**Test Scenarios**:

| Scenario | Setup | Action | Expected Result |
|----------|-------|--------|-----------------|
| First level-up | player_level = 1, deliver enough coal to level up | Check furnace menu | Mind button becomes visible |
| Enter Mind scene | Mind button visible and clicked | Navigate to Mind scene | 2 upgrade cards displayed from full pool |
| First selection | 2 options displayed | Select Balance | Branch locked to "manual", upgrades_qty = 1, selected_techniques = {"balance": 1} |
| Multiple level-ups | player_level = 3, upgrades_qty = 0 | Select upgrade 3 times | Loop continues until upgrades_qty = 3, then returns to furnace |
| Branch filtering | Branch = "manual", player_level = 3 | Check upgrade options | Only Manual Mastery techniques offered |
| Max level exclusion | Balance level 5 (maxed) | Generate options | Balance not offered again |

---

### Manual Test Criteria

- [ ] Mind button appears in furnace menu after first level-up
- [ ] Mind button hidden when upgrades_qty equals player_level
- [ ] Mind scene displays 2 upgrade cards with technique data
- [ ] Card layout has space for 4 cards (cards 3-4 hidden)
- [ ] Upgrade card shows: icon/placeholder, name, level, description
- [ ] Rarity-based border colors display correctly (Common/Rare/Epic/Legendary)
- [ ] Selecting an upgrade increments upgrades_qty
- [ ] First selection locks technique branch ("manual" or "auto")
- [ ] Subsequent selections only offer techniques from locked branch
- [ ] Maxed techniques (at max level for rarity) are excluded from options
- [ ] Loop continues offering upgrades until upgrades_qty == player_level
- [ ] Returns to furnace scene when caught up
- [ ] Mind button becomes hidden after catching up
- [ ] selected_techniques dictionary correctly tracks technique levels

---

## Code Examples

### Upgrade Option Generation with Branch Filtering

```gdscript
# In mind.gd
func _generate_upgrade_options(count: int) -> Array:
    const TECHNIQUES = preload("res://data/techniques.gd").TECHNIQUES
    var available = []

    for tech_id in TECHNIQUES.keys():
        var tech = TECHNIQUES[tech_id]

        # First selection: all techniques available
        if Level1Vars.technique_branch == "":
            available.append(tech_id)
            continue

        # Filter by branch
        if tech.branch != Level1Vars.technique_branch:
            continue

        # Exclude maxed techniques
        var current_lvl = Level1Vars.selected_techniques.get(tech_id, 0)
        var max_lvl = _get_max_level_for_rarity(tech.rarity)
        if current_lvl >= max_lvl:
            continue

        available.append(tech_id)

    available.shuffle()
    return available.slice(0, count)
```

**Explanation**: Generates random upgrade options based on player's branch selection and excludes maxed techniques.

---

### Rarity-Based Card Styling

```gdscript
# In mind.gd
func _apply_rarity_styling(card: Panel, rarity: String):
    var border_color: Color

    match rarity:
        "common":
            border_color = Color(0.6, 0.6, 0.6)  # Gray
        "rare":
            border_color = Color(0.2, 0.5, 1.0)  # Blue
        "epic":
            border_color = Color(0.7, 0.3, 1.0)  # Purple
        "legendary":
            border_color = Color(1.0, 0.8, 0.2)  # Gold
        _:
            border_color = Color.WHITE

    # Apply to Panel's StyleBox border
    var stylebox = card.get_theme_stylebox("panel").duplicate()
    stylebox.border_color = border_color
    card.add_theme_stylebox_override("panel", stylebox)
```

**Explanation**: Applies visual differentiation to upgrade cards based on rarity tier.

---

## UI Mockup

```
+--------------------------------------------------------------+
|  Mind Scene                                              [X] |
+--------------------------------------------------------------+
|                                                              |
|  [Background: mind.jpg]                                      |
|                                                              |
|         +----------------+        +----------------+         |
|         | [Icon/Rect]    |        | [Icon/Rect]    |         |
|         | Balance        |        | Rhythm         |         |
|         | Level 1        |        | NEW            |         |
|         |                |        |                |         |
|         | +20% shovel    |        | -20% stamina   |         |
|         | click torque   |        | drain from     |         |
|         |                |        | holding shovel |         |
|         |                |        |                |         |
|         | [Select]       |        | [Select]       |         |
|         +----------------+        +----------------+         |
|                                                              |
|         (Space reserved for cards 3-4, hidden for now)      |
|                                                              |
|  [To Furnace]                                                |
+--------------------------------------------------------------+
```

---

## Files to Create

- `res://data/techniques.gd` - Technique data structure (from 2.x-upgrade-pool.md, may already exist)
- `res://level1/mind.gd` - Mind scene script for upgrade selection logic
- `tests/test_shovelling_levelup.gd` - Test suite for level-up flow

## Files to Modify

- `level1/level_1_vars.gd` - Add `upgrades_qty`, `selected_techniques`, `technique_branch` variables
- `level1/furnace.gd` - Add Mind button visibility logic and button connection
- `level1/furnace.tscn` - Add Mind button to menu (initially hidden)
- `level1/mind.tscn` - Expand with UpgradeContainer and card UI structure

---

## Design Values (Reference)

### Card Layout
- **Card width**: 300-400px
- **Card spacing**: 20-30px
- **Cards shown**: 2 (with space for 4)
- **Card padding**: 10px internal margin

### Rarity Colors
- **Common**: RGB(153, 153, 153) - Gray
- **Rare**: RGB(51, 128, 255) - Blue
- **Epic**: RGB(179, 77, 255) - Purple
- **Legendary**: RGB(255, 204, 51) - Gold

### Max Levels by Rarity
- **Common**: 5 levels
- **Rare**: 4 levels
- **Epic**: 3 levels
- **Legendary**: 2 levels

---

## Balance Tuning Notes

**Tuneable Parameters**:
- `UPGRADE_OPTIONS_COUNT` in mind.gd - Number of choices per selection (currently 2)
- Rarity weights (deferred to future plan with rarity system)
- Card layout spacing and sizing

**Expected Player Progression**:
- First level-up (Strength 2): Player discovers Mind scene, sees 2 options from full pool
- Level 2-3: Player locked into branch, sees filtered options
- Level 4+: Some techniques start reaching max level, option pool narrows

**Warning Signs**:
- If players feel "forced" into a branch too early, increase initial option count
- If upgrade loop feels tedious, consider adding "Select All" for multiple pending levels
- If card text is hard to read, increase font size or card dimensions

---

## Notes & Decisions

### Decision 1: Defer Gameplay Effects to 2.x-apply-upgrade.md

**Rationale**:
- This plan is already UI-heavy (card display, scene flow, selection tracking)
- Effect implementation requires modifying many gameplay systems (shovel physics, stamina drain, coal spawning)
- Separating concerns allows UI testing independent of effect bugs
- Clearer rollback if effect implementation breaks gameplay

**Alternatives considered**:
- Implement effects in this plan - Rejected: Would create massive, hard-to-review plan
- Skip stub storage and implement effects later - Rejected: Can't verify selections are working without storing them

### Decision 2: Reserve Space for 4 Cards Now

**Rationale**:
- User specified "create enough space for up to 4 options"
- Easier to hide 2 cards than redesign layout later
- Future expansion is a single variable change (show cards 3-4)

### Decision 3: Basic Tooltip System (Deferred)

**Rationale**:
- User wants "highlighted and colored text that can be hovered over with a tool tip"
- Implementing full rich text + tooltip system is complex
- RichTextLabel with BBCode is possible but adds scope
- Decision: Use clear plain text descriptions for now, add tooltips in content/polish plan

**Open Questions**:
- [ ] Should "To Furnace" button be hidden during upgrade selection loop? (Prevent exiting before catching up)
- [ ] Should we show "X upgrades pending" text in Mind scene?
- [ ] Icon/image for each technique - use placeholder ColorRect or fetch actual images?
- [ ] Should maxed techniques show visual indicator in future selections (grayed out but visible)?

---

## Implementation Checklist

- [ ] Add `upgrades_qty`, `selected_techniques`, `technique_branch` to Level1Vars
- [ ] Add Mind button to furnace.tscn (hidden by default)
- [ ] Implement `_update_mind_button_visibility()` in furnace.gd
- [ ] Connect Mind button to SceneNetwork.go_to("mind")
- [ ] Update mind.tscn with UpgradeContainer and 4 card panels (2 visible, 2 hidden)
- [ ] Create mind.gd with upgrade generation logic
- [ ] Implement `_generate_upgrade_options()` with branch filtering
- [ ] Implement `_display_upgrade_options()` to populate cards
- [ ] Implement `_on_upgrade_selected()` to handle selection and looping
- [ ] Implement `_get_max_level_for_rarity()` helper
- [ ] Implement `_apply_rarity_styling()` for card borders
- [ ] Create techniques.gd data file (if not already created in 2.x-upgrade-pool.md)
- [ ] Add placeholder for effect application (comment noting 2.x-apply-upgrade.md)
- [ ] Write unit tests in test_shovelling_levelup.gd
- [ ] Run headless tests
- [ ] Perform integration tests (level-up flow)
- [ ] Manual test: UI layout at 1438x817 resolution
- [ ] Manual test: Branch locking behavior
- [ ] Manual test: Max level exclusion
- [ ] Manual test: Multiple pending level-ups loop correctly
- [ ] Verify Mind button hides after catching up
- [ ] Code review for clarity and maintainability

---

**Last Updated**: 2025-12-27
**Status**: Draft - Awaiting 2.x-apply-upgrade.md completion for full functionality
**Note**: This plan implements UI and selection flow. Actual gameplay effects of techniques are deferred to 2.x-apply-upgrade.md.
