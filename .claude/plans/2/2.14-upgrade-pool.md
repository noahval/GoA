# Upgrade System (Pool + Application)

**Goal**: Define and implement the complete upgrade system - technique pool, selection mechanics, and gameplay effect application

**Success Criteria**:
- Diverse upgrade paths with combo mechanics that reward skillful play
- All technique effects correctly modify gameplay mechanics
- Combo systems track state properly and unlock dynamically

**Prerequisites**:
- Shovel experience system ([2.x-shovel-experience.md](2.x-shovel-experience.md)) complete
- Scene navigation via Global.change_scene() (existing pattern in mind.gd)

**Scope**:
- Complete upgrade system: UI flow, technique pool, draw quality, effect application, combo mechanics
- Supersedes previous separate "Upgrade Pool", "Apply Upgrade", and "Shovelling Level-Up" plans

---

## Part 1: Technique Pool Definition

### Upgrade Categories

All upgrades are in a single pool (no branch locking). Organized into functional categories:

**Core Stats**: Basic improvements to shoveling mechanics (stamina, XP gain, shovel physics)

**Clean Streak Path**: Unlocks and enhances clean streak mechanics - consecutive deliveries without dropping coal. Streak persists between deliveries until coal is dropped.

**Heavy Load Combo Path**: Unlocks and enhances burst bonuses for delivering 3+ coal within 1 second (successfully dumping a multi-coal load). Uses a 5-second decay timer that refreshes on each heavy delivery.

**Shovel Stability Path**: Increases shovel stability for different physics behavior

### Tier System

Techniques are organized into unlock tiers to prevent overwhelming new players. Only techniques from unlocked tiers appear in the upgrade pool.

| Tier | Techniques | Design Intent |
|------|------------|---------------|
| **Tier 1** | Rhythm, Firm Grip, Economy of Motion | Simple stat boosts, no combo mechanics |
| **Tier 2** | Determination, Cadence, Streak Ceiling | Introduces clean streak concept |
| **Tier 3** | Power Surge, Pressure Training, Extended Window, Repetition Learning | Introduces heavy combo, deeper streak scaling |
| **Tier 4** | Perfect Form, Forgiveness, Mass Training | Capstone abilities, most complex |

**Unlock mechanism**: `Level1Vars.technique_tier` controls which tiers are available (default: 1). External systems set this value to unlock higher tiers. Techniques from locked tiers are completely hidden from the pool.

**Persistence**: `technique_tier` is saved/loaded as persistent progression. It does NOT reset per-run (unlike techniques themselves). Only resets via full game reset in settings panel.

---

## Part 2: Data Structure

### File: res://data/techniques.gd

**IMPORTANT**: Using class_name for global access pattern (no preload needed).

**Cost Field Note**: The `cost` field in technique definitions is for future multi-resource system ([2.x-additional-resource-pools.md](2.x-additional-resource-pools.md)). It is NOT displayed in Mind scene UI and NOT deducted during selection. Players select from available options without spending resources.

**Technique Description Display**: Descriptions use a two-part format with `\n\n` separator:
- **Short description** (first line): Brief descriptor WITHOUT value, max 5 words (e.g., "Base stamina drain")
- **Blank line**: Visual separation
- **Long description**: Flavor text explaining the mechanic (NO numbers)

Example: `"Base stamina drain\n\nReduces stamina drain from holding the shovel. Your grip becomes more efficient with each selection."`

**Runtime display structure**:
- **Upgrade name**: Technique name (NameLabel - 24px, centered)
- **Short description**: Quality-modified value injected with BBCode color, centered. Reductions show negative (e.g., stamina drain `-22%`), increases show positive (e.g., stability `+15%`). Example: `"[center]Base stamina drain [color=#4ccc4c]-22%[/color][/center]"` (ShortDescriptionLabel - 15px)
- **Long description**: Flavor text with NO numerical values, left-aligned (LongDescriptionLabel - 12px)

A `show_exact_values` flag (planned as purchasable feature) can hide exact percentages to align with knowledge-based progression principles.

```gdscript
# Technique pool definitions for upgrade system
# Referenced by Mind scene and effect application
# Using class_name for global access (no need to preload)
class_name TechniquesData

const TECHNIQUES = {
    # ========================================================================
    # CORE STAT TECHNIQUES
    # ========================================================================

    "rhythm": {
        "name": "Rhythm",
        "rarity": "common",
        "cost": 10,
        "max_level": 5,
        "tier": 1,
        "description": "Base stamina drain\n\nReduces stamina drain from holding the shovel. Your grip becomes more efficient with each selection.",
        "effect": {"base_bonus": 0.20},  # -20% drain per selection (multiplicative)
        "category": "core"
    },
    "determination": {
        "name": "Determination",
        "rarity": "rare",
        "cost": 16,
        "max_level": 5,
        "tier": 2,
        "description": "All stamina drain\n\nPure willpower keeps you going. All sources of stamina drain are reduced - both from the weight of the shovel and the burden of carrying coal. The overseer may push, but you endure.",
        "effect": {"base_bonus": 0.12},  # -12% all drain per selection (multiplicative)
        "category": "core"
    },
    "economy_of_motion": {
        "name": "Economy of Motion",
        "rarity": "uncommon",
        "cost": 20,
        "max_level": 5,
        "tier": 1,
        "description": "Coal carry stamina drain\n\nReduces stamina drain while carrying coal. You learn to move more efficiently under the burden, conserving energy with each delivery.",
        "effect": {"base_bonus": 0.15},  # -15% coal carrying drain per selection (multiplicative)
        "category": "core"
    },

    # ========================================================================
    # CLEAN STREAK TECHNIQUES
    # ========================================================================
    # Selecting any of these unlocks the clean streak mechanic
    # Streak increases by 1 for each coal delivered without dropping
    # Streak resets to 0 when coal is dropped (unless Forgiveness prevents it)

    "cadence": {
        "name": "Cadence",
        "rarity": "uncommon",
        "cost": 15,
        "max_level": 5,
        "tier": 2,
        "description": "Stamina drain per streak\n\nThe overseer notices consistent workers. Each delivery extends your clean streak, and longer streaks mean less stamina lost to stress. Dropping coal resets the count.",
        "effect": {"base_bonus": 0.03},  # -3% per streak per selection (additive across stacks)
        "category": "clean_streak",
        "unlocks_combo": true
    },
    "repetition_learning": {
        "name": "Repetition Learning",
        "rarity": "rare",
        "cost": 18,
        "max_level": 5,
        "tier": 3,
        "description": "XP gain per streak\n\nAvoid mistakes and you learn faster. Each delivery in your clean streak multiplies XP earned - the overseer's watchful eye keeps you focused. One drop and you're back to square one.",
        "effect": {"base_bonus": 0.10},  # +10% XP per streak per selection
        "category": "clean_streak",
        "unlocks_combo": true
    },
    "perfect_form": {
        "name": "Perfect Form",
        "rarity": "legendary",
        "cost": 50,
        "max_level": 1,
        "tier": 4,
        "description": "Stamina drain at 10+ streak\n\nFlawless work goes unnoticed. Maintain a clean streak of 10 or more and the overseer stops watching so closely - stamina drain drops dramatically until you slip up.",
        "effect": {"type": "boolean", "threshold": 10, "reduction": 0.50},
        "category": "clean_streak",
        "unlocks_combo": true
    },
    "forgiveness": {
        "name": "Forgiveness",
        "rarity": "epic",
        "cost": 30,
        "max_level": 5,
        "tier": 4,
        "description": "Earn forgiveness charges\n\nSometimes a dropped coal goes unnoticed. Earn forgiveness charges through consistent deliveries, then spend them when you slip - the overseer looks away and your clean streak survives.",
        "effect": {"base_bonus": 1.0},  # First: sets threshold, Later: C/U/R reduce threshold, E/L add capacity
        "category": "clean_streak",
        "unlocks_combo": true
    },
    "streak_ceiling": {
        "name": "Streak Ceiling",
        "rarity": "uncommon",
        "cost": 20,
        "max_level": 5,
        "tier": 2,
        "description": "Max streak\n\nThe overseer tracks longer counts. Raises the maximum clean streak that matters, letting streak-based benefits scale even higher.",
        "effect": {"base_bonus": 10},  # +10 to max streak per selection
        "category": "clean_streak",
        "unlocks_combo": true
    },

    # ========================================================================
    # HEAVY LOAD COMBO TECHNIQUES
    # ========================================================================
    # Selecting any of these unlocks the heavy load combo mechanic
    # Heavy load = successfully dumping 3+ coal from shovel (all deliveries within 1 second)
    # Each successful heavy delivery increments stacks and refreshes the 5-second decay timer
    # Timer expiration or dropping coal resets stacks to 0
    # Rewards risky play of carrying multiple coal pieces without spilling

    "power_surge": {
        "name": "Power Surge",
        "rarity": "rare",
        "cost": 18,
        "max_level": 5,
        "tier": 3,
        "description": "Stamina drain per heavy stack\n\nMomentum from heavy loads carries you forward. Successfully delivering 3+ coal at once builds power - each heavy delivery in quick succession reduces your stamina drain. Stop delivering and the surge fades.",
        "effect": {"base_bonus": 0.05},  # -5% stamina per heavy stack per selection (additive across stacks)
        "category": "heavy_combo",
        "unlocks_combo": true
    },
    "pressure_training": {
        "name": "Pressure Training",
        "rarity": "rare",
        "cost": 20,
        "max_level": 5,
        "tier": 3,
        "description": "XP gain per heavy stack\n\nThe overseer values efficiency above all. Deliver heavy loads in quick succession and each one teaches you more - XP multiplies with every consecutive heavy delivery. Slow down and the bonus resets.",
        "effect": {"base_bonus": 0.20},  # +20% XP per heavy stack per selection
        "category": "heavy_combo",
        "unlocks_combo": true
    },
    "extended_window": {
        "name": "Extended Window",
        "rarity": "uncommon",
        "cost": 22,
        "max_level": 5,
        "tier": 3,
        "description": "Heavy timer\n\nYou learn to maintain your rhythm longer. The window between heavy deliveries extends, giving you more time to keep your momentum going before the bonus fades.",
        "effect": {"base_bonus": 1.0},  # +1.0s to timer per selection
        "category": "heavy_combo",
        "unlocks_combo": true
    },

    # ========================================================================
    # SHOVEL STABILITY TECHNIQUES
    # ========================================================================

    "firm_grip": {
        "name": "Firm Grip",
        "rarity": "common",
        "cost": 12,
        "max_level": 5,
        "tier": 1,
        "description": "Shovel stability\n\nA steadier hold on the shovel. Coal shifting on the blade has less impact on your balance, giving you more control when carrying heavy loads.",
        "effect": {"base_bonus": 0.15},  # +15% stability per selection (multiplicative)
        "category": "mass"
    },
    "mass_training": {
        "name": "Mass Training",
        "rarity": "epic",
        "cost": 35,
        "max_level": 5,
        "tier": 4,
        "description": "Shovel stability per streak\n\nFear sharpens your grip. As your clean streak builds and the pressure mounts, you hold the shovel tighter - more control, less wobble. Breaking your streak relaxes your grip.",
        "effect": {"base_bonus": 0.02},  # +2% stability per streak per selection
        "category": "mass",
        "requires": "clean_streak"  # Must have unlocked clean streak system
    },
}
```

**Loading pattern in other files**:
```gdscript
# In mind.gd or level_1_vars.gd
# TechniquesData is globally available via class_name, no preload needed
const TECHNIQUES = TechniquesData.TECHNIQUES
```

---

## Part 3: Draw Quality System

When upgrade options are generated for display, each technique has a **draw quality** randomly assigned that determines how powerful that particular instance is. Players choose between technique+quality combinations.

### Quality Tiers

Each technique has a base bonus defined in its data structure. The quality tier multiplies this bonus:

| Quality Tier | Quality Multiplier | Example (Rhythm base 0.20) |
|--------------|-------------------|----------------------------|
| Common | x1.0 | 0.20 x 1.0 = 0.20 |
| Uncommon | x1.1 | 0.20 x 1.1 = 0.22 |
| Rare | x1.2 | 0.20 x 1.2 = 0.24 |
| Epic | x1.4 | 0.20 x 1.4 = 0.28 |
| Legendary | x1.6 | 0.20 x 1.6 = 0.32 |

**Formula**: `actual_bonus = base_bonus x quality_multiplier`

**Why multiplicative**: Rare quality gives 20% MORE effect (1.2x instead of 1.0x). For Rhythm's base 20% bonus, a Rare draw gives 24% (20% base x 1.2 = 24%).

### Draw Quality Weights

**All techniques use the same quality distribution** regardless of technique rarity. This keeps the reward system simple: technique rarity affects how often it appears in the pool, quality affects how powerful this specific draw is.

**Uniform quality distribution for all techniques**:

| Quality | Chance | Cumulative |
|---------|--------|------------|
| Common | 40% | 0.00-0.40 |
| Uncommon | 30% | 0.40-0.70 |
| Rare | 20% | 0.70-0.90 |
| Epic | 8% | 0.90-0.98 |
| Legendary | 2% | 0.98-1.00 |

**Design intent**: Seeing a rare technique is exciting because it appears infrequently in the pool (when rarity-weighted selection is implemented). Quality roll is independent - all techniques have equal chance for high-quality draws.

**Implementation**: See `_draw_quality_for_technique()` in Part 4.5 for roll logic.

---

## Part 4: Rarity System

**Appearance Rarity** controls how often a technique appears in level-up pools (NOT implemented yet - all techniques have equal appearance chance currently).

**Future Distribution** (for rarity-weighted selection):
- **Common**: 40% chance to appear
- **Uncommon**: 30% chance to appear
- **Rare**: 20% chance to appear
- **Epic**: 8% chance to appear
- **Legendary**: 2% chance to appear

**Visual Indicator**: Border color on technique card (see Part 4.5 below for UI implementation)

| Rarity | Color Name | RGB Values | Godot Color |
|--------|-----------|-----------|-------------|
| Common | Gray | (153, 153, 153) | Color(0.6, 0.6, 0.6) |
| Uncommon | Green | (102, 204, 102) | Color(0.4, 0.8, 0.4) |
| Rare | Blue | (51, 128, 255) | Color(0.2, 0.5, 1.0) |
| Epic | Purple | (179, 77, 255) | Color(0.7, 0.3, 1.0) |
| Legendary | Gold | (255, 204, 51) | Color(1.0, 0.8, 0.2) |

---

## Part 4.5: Mind Scene UI and Selection Flow

### Mind Button Visibility Logic

Player starts at level 0. When player levels up (`Level1Vars.player_level` increases via coal delivery XP), the Mind button appears in the furnace menu allowing access to the upgrade selection scene. First upgrade is earned, not given.

**Location**: [level1/furnace.gd](../../game/v0.1/level1/furnace.gd)

**Add Mind button to furnace menu**:
- Mind button should be hidden by default in furnace.tscn
- Button text: "Mind" (theme: ForwardNavButton)
- Position: Below existing furnace menu buttons

**Visibility check function**:
```gdscript
# In furnace.gd
func _update_mind_button_visibility():
    # Show Mind button when player has unspent level-ups
    var has_pending_upgrades = Level1Vars.player_level > Level1Vars.upgrades_qty
    mind_button.visible = has_pending_upgrades
```

**When to call**:
- When furnace scene loads (`_ready()`)
- When returning from Mind scene
- After player level-up (Level1Vars should emit signal when leveling up)

### Mind Scene UI Layout

Create the upgrade selection interface with space for up to 4 options (currently showing 2).

**File**: [level1/mind.tscn](../../game/v0.1/level1/mind.tscn)

**Scene structure**:
```
Mind (inherits scene_template.tscn)
  AspectContainer/MainContainer
    Background (TextureRect - mind.jpg)
    mainarea/
      Menu/
        ToFurnaceButton (existing)
      PlayArea/
        UpgradeContainer (HBoxContainer)
          UpgradeCard1 (Panel - custom style)
          UpgradeCard2 (Panel - custom style)
          UpgradeCard3 (Panel - hidden initially, for future expansion)
          UpgradeCard4 (Panel - hidden initially, for future expansion)
```

**Layout specifications**:
- **UpgradeContainer**: Centered in PlayArea, uses HBoxContainer with 30px spacing
- **Card count**: Show 2 cards currently, hide cards 3-4 (reserved for future expansion)
- **Card sizing**: 300px wide x 420px tall (custom_minimum_size)
- **Internal padding**: 15px margins on all sides

**Individual upgrade card structure**:
```
UpgradeCard (Panel with custom theme)
  VBoxContainer (15px margins, 12px separation)
    IconPlaceholder (ColorRect - 80px tall placeholder)
    NameLabel (Label - 24px font, technique name, centered)
    LevelLabel (Label - 16px font, "Level X" or "NEW", centered, gray)
    ShortDescriptionLabel (RichTextLabel - 15px font, 30px min height, BBCode enabled, centered via [center] tag)
    LongDescriptionLabel (RichTextLabel - 12px font, 100px min height, BBCode enabled, fit_content, left-aligned)
    SelectButton (Button - "Select", ForwardNavButton theme)
```

**Card styling**:
- Panel with StyleBoxFlat (3px border, rounded 8px corners, dark semi-transparent background)
- Rarity-based border colors (from table in Part 4)
- Short description: 15px font, centered, with colored quality-modified value (RichTextLabel with BBCode)
- Long description: 12px font, left-aligned (RichTextLabel with BBCode, fit_content enabled)

### Mind Scene Script Implementation

**File**: [level1/mind.gd](../../game/v0.1/level1/mind.gd)

**Load technique data**:
```gdscript
# At top of mind.gd
# TechniquesData is globally available via class_name
const TECHNIQUES = TechniquesData.TECHNIQUES
```

**Generate upgrade options**:
```gdscript
func _generate_upgrade_options(count: int) -> Array:
    # Returns array of dictionaries: [{"tech_id": "rhythm", "quality": "rare"}, ...]

    var available_techniques = []

    for tech_id in TECHNIQUES.keys():
        var tech = TECHNIQUES[tech_id]

        # Exclude techniques from locked tiers
        var tech_tier = tech.get("tier", 1)
        if tech_tier > Level1Vars.technique_tier:
            continue

        # Exclude maxed techniques
        var current_level = Level1Vars.get_technique_level(tech_id)
        var max_level = tech.get("max_level", 5)
        if current_level >= max_level:
            continue

        # Check if technique requires unlocked combo system
        if tech.has("requires"):
            if tech["requires"] == "clean_streak" and not Level1Vars.clean_streak_unlocked:
                continue

        available_techniques.append(tech_id)

    # Shuffle and take first 'count' items
    available_techniques.shuffle()
    var selected = available_techniques.slice(0, count)

    # Roll quality for each selected technique
    var options = []
    for tech_id in selected:
        var quality = _draw_quality_for_technique(tech_id)
        options.append({"tech_id": tech_id, "quality": quality})

    return options
```

**Display upgrade cards**:
```gdscript
func _display_upgrade_options(options: Array):
    # Populate card 1 and card 2 with technique+quality data
    for i in range(min(options.size(), 2)):
        var option = options[i]
        var tech_id = option["tech_id"]
        var quality = option["quality"]
        var tech = TECHNIQUES[tech_id]
        var card = upgrade_cards[i]  # Reference to UpgradeCard1/2 nodes

        # Set technique name (no quality or cost shown in name)
        card.get_node("VBoxContainer/NameLabel").text = tech["name"]

        # Split description into short and long descriptions
        var description = tech["description"]
        var parts = description.split("\n\n", true, 1)
        var short_desc = parts[0] if parts.size() > 0 else ""
        var long_desc = parts[1] if parts.size() > 1 else ""

        # Calculate quality-modified bonus
        var base_bonus = tech["effect"].get("base_bonus", 0.0)
        var quality_mult = _get_quality_multiplier(quality)
        var actual_bonus = base_bonus * quality_mult

        # Get quality color for BBCode
        var quality_color = _get_quality_color(quality)

        # Build short description with colored value
        var short_label = card.get_node("VBoxContainer/ShortDescriptionLabel")
        if Level1Vars.show_exact_technique_values and base_bonus > 0:
            var value_text = ""
            var category = tech.get("category", "")
            if base_bonus < 1.0:  # Percentage bonus
                # Stability category shows as increase (+), others show as reduction (-)
                if category == "mass":
                    value_text = " [color=#%s]+%.0f%%[/color]" % [quality_color, actual_bonus * 100]
                else:
                    value_text = " [color=#%s]-%.0f%%[/color]" % [quality_color, actual_bonus * 100]
            else:  # Flat bonus (like Streak Ceiling +10)
                value_text = " [color=#%s]+%.0f[/color]" % [quality_color, actual_bonus]

            short_label.text = "[center]" + short_desc + value_text + "[/center]"
        else:
            short_label.text = "[center]" + short_desc + "[/center]"

        # Set long description (no numbers, left-aligned)
        var long_label = card.get_node("VBoxContainer/LongDescriptionLabel")
        long_label.text = long_desc

        # Show current level or "NEW"
        var current_level = Level1Vars.get_technique_level(tech_id)
        if current_level > 0:
            card.get_node("VBoxContainer/LevelLabel").text = "Level %d" % current_level
        else:
            card.get_node("VBoxContainer/LevelLabel").text = "NEW"

        # Set rarity-based border color and quality-based text color
        _apply_card_styling(card, tech_id, quality)

        # Connect Select button
        var select_btn = card.get_node("VBoxContainer/SelectButton")
        # Disconnect previous signals if any
        if select_btn.is_connected("pressed", _on_upgrade_selected):
            select_btn.disconnect("pressed", _on_upgrade_selected)
        select_btn.pressed.connect(_on_upgrade_selected.bind(tech_id, quality))

        card.visible = true
```

**Handle selection**:
```gdscript
func _on_upgrade_selected(tech_id: String, quality: String):
    # Quality was already rolled when options were generated
    Level1Vars.add_technique(tech_id, quality)

    # Increment total upgrades
    Level1Vars.upgrades_qty += 1

    # Check if more upgrades needed
    if Level1Vars.upgrades_qty < Level1Vars.player_level:
        # Generate new options with fresh quality rolls
        var new_options = _generate_upgrade_options(2)
        _display_upgrade_options(new_options)
    else:
        # All caught up, return to furnace
        Global.change_scene("res://level1/furnace.tscn")

func _draw_quality_for_technique(tech_id: String) -> String:
    # Uniform quality distribution for all techniques (see Part 3)
    var roll = randf()

    # 40% common, 30% uncommon, 20% rare, 8% epic, 2% legendary
    if roll < 0.40:
        return "common"
    elif roll < 0.70:  # 0.40 + 0.30
        return "uncommon"
    elif roll < 0.90:  # 0.70 + 0.20
        return "rare"
    elif roll < 0.98:  # 0.90 + 0.08
        return "epic"
    else:  # 0.98 + 0.02
        return "legendary"
```

**Apply card styling**:
```gdscript
func _apply_card_styling(card: Panel, tech_id: String, quality: String):
    # Border color based on technique rarity (how rare it is to appear)
    var tech_rarity = TECHNIQUES[tech_id]["rarity"]
    var border_color: Color

    match tech_rarity:
        "common":
            border_color = Color(0.6, 0.6, 0.6)  # Gray
        "uncommon":
            border_color = Color(0.4, 0.8, 0.4)  # Green
        "rare":
            border_color = Color(0.2, 0.5, 1.0)  # Blue
        "epic":
            border_color = Color(0.7, 0.3, 1.0)  # Purple
        "legendary":
            border_color = Color(1.0, 0.8, 0.2)  # Gold
        _:
            border_color = Color.WHITE

    # Apply border color to Panel's StyleBox
    var stylebox = card.get_theme_stylebox("panel").duplicate()
    stylebox.border_color = border_color
    card.add_theme_stylebox_override("panel", stylebox)

    # Text color based on quality (how powerful this draw is)
    var quality_color: Color

    match quality:
        "common":
            quality_color = Color(0.6, 0.6, 0.6)  # Gray
        "uncommon":
            quality_color = Color(0.4, 0.8, 0.4)  # Green
        "rare":
            quality_color = Color(0.2, 0.5, 1.0)  # Blue
        "epic":
            quality_color = Color(0.7, 0.3, 1.0)  # Purple
        "legendary":
            quality_color = Color(1.0, 0.8, 0.2)  # Gold
        _:
            quality_color = Color.WHITE

    # Note: Quality color is now applied during _display_upgrade_options
    # No additional styling needed here

func _get_quality_color(quality: String) -> String:
    # Returns hex color string (without #) for BBCode usage
    var color: Color
    match quality:
        "common":
            color = Color(0.6, 0.6, 0.6)  # Gray
        "uncommon":
            color = Color(0.4, 0.8, 0.4)  # Green
        "rare":
            color = Color(0.2, 0.5, 1.0)  # Blue
        "epic":
            color = Color(0.7, 0.3, 1.0)  # Purple
        "legendary":
            color = Color(1.0, 0.8, 0.2)  # Gold
        _:
            color = Color.WHITE

    return color.to_html(false)

func _get_quality_multiplier(quality: String) -> float:
    match quality:
        "common": return 1.0
        "uncommon": return 1.1
        "rare": return 1.2
        "epic": return 1.4
        "legendary": return 1.6
        _: return 1.0
```

---

## Part 5: Storage and State Management

### Data Storage in Level1Vars

**Location**: `level_1_vars.gd`

**Variables to add**:
```gdscript
# Upgrade tracking
var upgrades_qty: int = 0  # Total upgrades selected this run (for Mind button visibility)
var technique_tier: int = 1  # Current unlock tier (1-4). External systems set this to unlock higher tiers.

# Technique selection tracking
var selected_techniques: Dictionary = {}
# Structure: { technique_id: { "level": int, "qualities": Array[String] } }

# Example after selecting Rhythm three times with different draw qualities:
# selected_techniques = {
#     "rhythm": {
#         "level": 3,
#         "qualities": ["common", "rare", "common"]
#     },
#     "cadence": {
#         "level": 1,
#         "qualities": ["rare"]
#     }
# }

# Combo system unlock flags
var clean_streak_unlocked: bool = false
var heavy_combo_unlocked: bool = false

# UI display settings
var show_exact_technique_values: bool = true  # Show exact percentages in descriptions (purchasable toggle feature)

# Clean streak state
var clean_streak_count: int = 0
var clean_streak_max: int = 20  # Increased by Streak Ceiling technique
var forgiveness_charges: int = 0  # Charges available to save combo from drops
var forgiveness_coal_counter: int = 0  # Coal delivered since last charge earned
var forgiveness_threshold: int = 0  # Coal needed to earn 1 charge (set by first selection quality)
var forgiveness_max_capacity: int = 0  # Maximum charges that can be banked

# Heavy load combo state
var heavy_combo_stacks: int = 0
var heavy_combo_timer: float = 0.0  # Counts down from 5.0s + bonuses
var recent_delivery_timestamps: Array[float] = []  # Timestamps of recent deliveries for batch detection
const HEAVY_LOAD_BATCH_WINDOW: float = 1.0  # Time window for detecting 3+ coal deliveries (seconds)

# Signals for UI updates
signal technique_updated(technique_id: String, new_level: int)
signal clean_streak_changed(new_count: int)
signal heavy_combo_changed(new_stacks: int, timer_remaining: float)
```

### Basic Management Functions

**Add to level_1_vars.gd**:

```gdscript
# TechniquesData is globally available via class_name
const TECHNIQUES = TechniquesData.TECHNIQUES

func add_technique(technique_id: String, draw_quality: String) -> void:
    if technique_id not in selected_techniques:
        selected_techniques[technique_id] = {
            "level": 1,
            "qualities": [draw_quality]
        }
    else:
        selected_techniques[technique_id]["level"] += 1
        selected_techniques[technique_id]["qualities"].append(draw_quality)

    # Check if this technique unlocks a combo system
    if technique_id in TECHNIQUES:
        var tech_data = TECHNIQUES[technique_id]
        if tech_data.has("unlocks_combo") and tech_data["unlocks_combo"]:
            if tech_data["category"] == "clean_streak":
                clean_streak_unlocked = true
            elif tech_data["category"] == "heavy_combo":
                heavy_combo_unlocked = true

    emit_signal("technique_updated", technique_id, selected_techniques[technique_id]["level"])

func get_technique_level(technique_id: String) -> int:
    if technique_id not in selected_techniques:
        return 0
    return selected_techniques[technique_id]["level"]

func reset_techniques() -> void:
    upgrades_qty = 0
    # NOTE: technique_tier is NOT reset here - it's persistent progression
    # Only reset via full game reset in settings panel
    selected_techniques.clear()
    clean_streak_unlocked = false
    heavy_combo_unlocked = false
    clean_streak_count = 0
    clean_streak_max = 20
    forgiveness_charges = 0
    forgiveness_coal_counter = 0
    forgiveness_threshold = 0
    forgiveness_max_capacity = 0
    heavy_combo_stacks = 0
    heavy_combo_timer = 0.0
    recent_delivery_timestamps.clear()
```

### Save/Load Integration

**Add to level_1_vars.gd save/load functions**:

```gdscript
# In get_save_data()
func get_save_data() -> Dictionary:
    return {
        # ...existing save data...
        # NOTE: Techniques are NOT saved - they reset each run (per-run progression)
        # technique_tier IS saved - persistent progression, only reset via full game reset
        # Combo state IS saved - combos reset when new day begins, but persist during same-day saves
        "technique_tier": technique_tier,
        "show_exact_technique_values": show_exact_technique_values,
        "clean_streak_count": clean_streak_count,
        "clean_streak_max": clean_streak_max,
        "forgiveness_charges": forgiveness_charges,
        "forgiveness_coal_counter": forgiveness_coal_counter,
        "forgiveness_threshold": forgiveness_threshold,
        "forgiveness_max_capacity": forgiveness_max_capacity,
        "heavy_combo_stacks": heavy_combo_stacks,
        "heavy_combo_timer": heavy_combo_timer,
        "recent_delivery_timestamps": recent_delivery_timestamps.duplicate(),
    }

# In load_save_data()
func load_save_data(data: Dictionary):
    # ...existing load code...
    # Techniques NOT loaded - reset each run
    # technique_tier IS loaded - persistent progression
    technique_tier = data.get("technique_tier", 1)
    show_exact_technique_values = data.get("show_exact_technique_values", true)
    # Load combo state (persists during same day, resets when new day begins)
    clean_streak_count = data.get("clean_streak_count", 0)
    clean_streak_max = data.get("clean_streak_max", 20)
    forgiveness_charges = data.get("forgiveness_charges", 0)
    forgiveness_coal_counter = data.get("forgiveness_coal_counter", 0)
    forgiveness_threshold = data.get("forgiveness_threshold", 0)
    forgiveness_max_capacity = data.get("forgiveness_max_capacity", 0)
    heavy_combo_stacks = data.get("heavy_combo_stacks", 0)
    heavy_combo_timer = data.get("heavy_combo_timer", 0.0)
    recent_delivery_timestamps = data.get("recent_delivery_timestamps", [])
```

**Backward Compatibility**: Using `data.get(key, default)` ensures old save files without technique data load correctly with empty/default values. Existing player progress (XP, currency, etc.) preserved.

**Per-Run Design**: Techniques and unlock flags reset each run (roguelike build variety). Combo state persists during same-day saves but resets when new day begins.

---

## Part 6: Effect Application

### Core Helper Functions

**Add to level_1_vars.gd**:

```gdscript
# ============================================================================
# TECHNIQUE EFFECT HELPERS
# ============================================================================

# Core calculation function - sums all quality-scaled bonuses for a technique
# Used for additive effects (XP bonuses, mass bonuses, combo stacking)
func get_technique_total_bonus(technique_id: String) -> float:
    if technique_id not in selected_techniques:
        return 0.0

    # Validate technique exists in definition
    if technique_id not in TECHNIQUES:
        push_warning("Unknown technique: " + technique_id)
        return 0.0

    # Handle boolean techniques (like Perfect Form)
    var effect_data = TECHNIQUES[technique_id]["effect"]
    if effect_data.has("type") and effect_data["type"] == "boolean":
        return 0.0  # Boolean techniques checked with has_technique(), not bonus calculation

    var base_bonus = effect_data["base_bonus"]
    var qualities = selected_techniques[technique_id]["qualities"]
    var total = 0.0

    for quality in qualities:
        var quality_mult = get_quality_multiplier(quality)
        total += base_bonus * quality_mult

    return total

func get_quality_multiplier(quality: String) -> float:
    match quality:
        "common": return 1.0
        "uncommon": return 1.1
        "rare": return 1.2
        "epic": return 1.4
        "legendary": return 1.6
        _:
            push_warning("Unknown quality tier: " + quality)
            return 1.0
```

**Example calculation (Rhythm with Common + Rare + Common) - Multiplicative:**
- Draw 1 (Common): 0.20 x 1.0 = 0.20 → mult = 1.0 - 0.20 = 0.80
- Draw 2 (Rare): 0.20 x 1.2 = 0.24 → mult = 0.80 × (1.0 - 0.24) = 0.608
- Draw 3 (Common): 0.20 x 1.0 = 0.20 → mult = 0.608 × (1.0 - 0.20) = 0.486
- **Final multiplier applied to stamina drain**: 0.486 (48.6% of original drain, 51.4% reduction)
- **No dead zone**: Each selection always provides 20-32% reduction of current drain

### Stamina Drain Modifiers

**Add to level_1_vars.gd**:

```gdscript
# Returns multiplier for base stamina drain (from holding shovel)
# Affected by: Rhythm, Determination, Cadence, Perfect Form
# Uses MULTIPLICATIVE stacking - each effect reduces current drain, not base drain
func get_base_stamina_drain_multiplier() -> float:
    var mult = 1.0

    # Rhythm: Each selection reduces current drain by 20% (multiplicative)
    if "rhythm" in selected_techniques:
        var qualities = selected_techniques["rhythm"]["qualities"]
        for quality in qualities:
            var quality_mult = get_quality_multiplier(quality)
            var reduction = 0.20 * quality_mult  # 20% base, 22-32% with quality
            mult *= (1.0 - reduction)

    # Determination: Each selection reduces current drain by 12% (multiplicative)
    if "determination" in selected_techniques:
        var qualities = selected_techniques["determination"]["qualities"]
        for quality in qualities:
            var quality_mult = get_quality_multiplier(quality)
            var reduction = 0.12 * quality_mult  # 12% base, 13-19% with quality
            mult *= (1.0 - reduction)

    # Cadence: Combo stacks apply additive reduction (total from all selections × combo count)
    if "cadence" in selected_techniques and clean_streak_unlocked:
        var cadence_total = get_technique_total_bonus("cadence")  # Sum all selections
        var combo_reduction = cadence_total * clean_streak_count  # 3% per stack per selection
        mult *= max(0.0, 1.0 - combo_reduction)  # Apply as single multiplier

    # Perfect Form: -50% at 10+ combo (boolean)
    if "perfect_form" in selected_techniques and clean_streak_count >= 10:
        mult *= 0.50  # Reduces to 50% of current drain

    return mult  # No floor cap - natural diminishing returns from multiplicative stacking

# Returns multiplier for coal carrying stamina drain
# Affected by: Economy of Motion, Determination, Power Surge
# Uses MULTIPLICATIVE stacking - each effect reduces current drain, not base drain
func get_coal_stamina_drain_multiplier() -> float:
    var mult = 1.0

    # Economy of Motion: Each selection reduces current drain by 15% (multiplicative)
    if "economy_of_motion" in selected_techniques:
        var qualities = selected_techniques["economy_of_motion"]["qualities"]
        for quality in qualities:
            var quality_mult = get_quality_multiplier(quality)
            var reduction = 0.15 * quality_mult  # 15% base, 17-24% with quality
            mult *= (1.0 - reduction)

    # Determination: Each selection reduces current drain by 12% (multiplicative)
    if "determination" in selected_techniques:
        var qualities = selected_techniques["determination"]["qualities"]
        for quality in qualities:
            var quality_mult = get_quality_multiplier(quality)
            var reduction = 0.12 * quality_mult  # 12% base, 13-19% with quality
            mult *= (1.0 - reduction)

    # Power Surge: Heavy stacks apply additive reduction (total from all selections × stack count)
    if "power_surge" in selected_techniques and heavy_combo_unlocked and heavy_combo_timer > 0.0:
        var surge_total = get_technique_total_bonus("power_surge")  # Sum all selections
        var heavy_reduction = surge_total * heavy_combo_stacks  # 5% per stack per selection
        mult *= max(0.0, 1.0 - heavy_reduction)  # Apply as single multiplier

    return mult  # No floor cap - coal drain can be heavily reduced with investment
```

**Usage in shovel.gd**:
```gdscript
func _physics_process(delta):
    # ...existing code...

    if coal_count >= 1 and is_in_work_zone:
        var base_drain = 0.2 * Level1Vars.get_base_stamina_drain_multiplier()
        var coal_drain = coal_count * 0.1 * Level1Vars.get_coal_stamina_drain_multiplier()
        var total_drain = base_drain + coal_drain
        Level1Vars.modify_stamina(-total_drain * delta)
```

### XP Multiplier

**Add to level_1_vars.gd**:

```gdscript
# Returns XP multiplier based on combo states
# Affected by: Repetition Learning, Pressure Training
func get_xp_multiplier() -> float:
    var mult = 1.0

    # Repetition Learning: +10% XP per combo stack per selection
    if "repetition_learning" in selected_techniques and clean_streak_unlocked:
        var learning_bonus = get_technique_total_bonus("repetition_learning")
        mult += learning_bonus * clean_streak_count

    # Pressure Training: +20% XP per heavy stack per selection
    if "pressure_training" in selected_techniques and heavy_combo_unlocked:
        var pressure_bonus = get_technique_total_bonus("pressure_training")
        mult += pressure_bonus * heavy_combo_stacks

    return mult
```

**Integration in furnace.gd**:
Modify `_on_coal_entered_delivery_zone()` (currently at furnace.gd:292-297):
```gdscript
func _on_coal_entered_delivery_zone(body: Node2D):
    # Only coal can trigger this (collision_mask = 4)
    if body._on_entered_delivery_zone():
        # Award player XP for successful delivery with multiplier
        var base_xp = 1.0
        var xp_with_multiplier = base_xp * Level1Vars.get_xp_multiplier()
        Level1Vars.add_player_exp(xp_with_multiplier)

        # Check for heavy load batch (see Part 7)
        if Level1Vars.heavy_combo_unlocked:
            _check_heavy_load_batch()
```

### Shovel Stability Multiplier

**Add to level_1_vars.gd**:

```gdscript
# Returns shovel mass multiplier
# Affected by: Firm Grip, Mass Training
func get_shovel_mass_multiplier() -> float:
    var mult = 1.0

    # Firm Grip: Each selection increases current mass by 15% (multiplicative)
    if "firm_grip" in selected_techniques:
        var qualities = selected_techniques["firm_grip"]["qualities"]
        for quality in qualities:
            var quality_mult = get_quality_multiplier(quality)
            var increase = 0.15 * quality_mult  # 15% base, 17-24% with quality
            mult *= (1.0 + increase)

    # Mass Training: +2% per combo stack per selection
    if "mass_training" in selected_techniques and clean_streak_unlocked:
        var mass_bonus = get_technique_total_bonus("mass_training")
        mult += mass_bonus * clean_streak_count

    return mult
```

**Usage in shovel.gd**:
```gdscript
# In shovel.gd _ready() or physics setup
func _ready():
    # Connect to Level1Vars signal for dynamic mass updates
    Level1Vars.clean_streak_changed.connect(_on_clean_streak_changed)
    update_shovel_mass()

func update_shovel_mass():
    var base_mass = Level1Vars.shovel_mass  # Use base value from Level1Vars
    var mass_mult = Level1Vars.get_shovel_mass_multiplier()
    mass = base_mass * mass_mult

# Signal handler for combo changes
func _on_clean_streak_changed(new_count: int):
    # If Mass Training is active, update shovel mass dynamically
    if "mass_training" in Level1Vars.selected_techniques:
        update_shovel_mass()
```

**Architecture Notes**:
- Shovel.gd is a scene instance (RigidBody2D) spawned by furnace.gd
- Signal connection happens in shovel's _ready() function
- Uses Level1Vars.shovel_mass as base value (existing variable at line 16 of level_1_vars.gd)
- Dynamic mass updates only apply when Mass Training technique is selected

### Combo System Helpers

**Add to level_1_vars.gd**:

```gdscript
# Returns maximum clean streak count (base 20 + Streak Ceiling bonuses)
func get_clean_streak_max() -> int:
    var base_max = 20
    if "streak_ceiling" not in selected_techniques:
        return base_max

    var bonus = get_technique_total_bonus("streak_ceiling")
    return base_max + int(bonus)

# Returns coal threshold for earning 1 forgiveness charge
# First selection sets base threshold (20/18/16/14/12 based on quality)
# Subsequent C/U/R selections reduce threshold (-2/-3/-4)
# Epic/Legendary selections don't affect threshold (they add capacity instead)
func get_forgiveness_threshold() -> int:
    if "forgiveness" not in selected_techniques:
        return 0

    var qualities = selected_techniques["forgiveness"]["qualities"]
    if qualities.size() == 0:
        return 0

    # First selection sets base threshold
    var first_quality = qualities[0]
    var threshold = 20  # Base
    match first_quality:
        "common": threshold = 20
        "uncommon": threshold = 18
        "rare": threshold = 16
        "epic": threshold = 14
        "legendary": threshold = 12

    # Subsequent C/U/R selections reduce threshold
    for i in range(1, qualities.size()):
        var quality = qualities[i]
        match quality:
            "common": threshold -= 2
            "uncommon": threshold -= 3
            "rare": threshold -= 4
            # Epic and legendary don't reduce threshold

    return max(1, threshold)  # Never go below 1

# Returns maximum forgiveness charges that can be banked
# First selection grants 1 capacity
# Subsequent Epic selections grant +1, Legendary grant +2
func get_forgiveness_max_capacity() -> int:
    if "forgiveness" not in selected_techniques:
        return 0

    var qualities = selected_techniques["forgiveness"]["qualities"]
    if qualities.size() == 0:
        return 0

    # First selection always grants 1 capacity
    var capacity = 1

    # Subsequent Epic/Legendary selections add capacity
    for i in range(1, qualities.size()):
        var quality = qualities[i]
        match quality:
            "epic": capacity += 1
            "legendary": capacity += 2
            # Common, uncommon, rare don't add capacity

    return capacity

# Returns heavy load timer extension in seconds
func get_heavy_timer_extension() -> float:
    if "extended_window" not in selected_techniques:
        return 0.0

    return get_technique_total_bonus("extended_window")
```

---

## Part 7: Combo System Implementation

### Clean Streak Tracking

**Integration Point 1: coal_piece.gd**

Modify `_on_entered_delivery_zone()` (currently at coal_piece.gd:55-74):

```gdscript
# Called by delivery zone Area2D when coal enters furnace
# Returns true if coal was successfully delivered, false if already tracked
func _on_entered_delivery_zone() -> bool:
    # Skip if already counted (matches drop handler pattern)
    if has_been_tracked:
        queue_free()  # Still remove it, just don't count
        return false

    # Mark as tracked FIRST (prevents drop zone from counting it during fade)
    has_been_tracked = true

    # Track as delivered
    Level1Vars.coal_delivered += 1
    if Level1Vars.DEBUG_COAL_TRACKING:
        print("[COAL] Delivered! Total: ", Level1Vars.coal_delivered)

    # Clean streak tracking (if unlocked)
    if Level1Vars.clean_streak_unlocked:
        Level1Vars.clean_streak_count = min(
            Level1Vars.clean_streak_count + 1,
            Level1Vars.get_clean_streak_max()
        )

        # Forgiveness charge tracking (hybrid threshold + capacity system)
        if "forgiveness" in Level1Vars.selected_techniques:
            Level1Vars.forgiveness_coal_counter += 1
            var threshold = Level1Vars.get_forgiveness_threshold()
            if Level1Vars.forgiveness_coal_counter >= threshold:
                # Award 1 charge if below capacity
                var max_capacity = Level1Vars.get_forgiveness_max_capacity()
                if Level1Vars.forgiveness_charges < max_capacity:
                    Level1Vars.forgiveness_charges += 1
                    if Level1Vars.DEBUG_COAL_TRACKING:
                        print("[COMBO] Earned forgiveness charge! Total: %d/%d" % [Level1Vars.forgiveness_charges, max_capacity])
                Level1Vars.forgiveness_coal_counter = 0

        Level1Vars.emit_signal("clean_streak_changed", Level1Vars.clean_streak_count)

    # Red fade animation: gradually change color to red over 0.3 seconds, then remove
    var tween = create_tween()
    tween.tween_property(self, "modulate", Color.RED, 0.3)
    tween.finished.connect(queue_free)

    return true
```

**Integration Point 2: coal_piece.gd**

Modify `_on_entered_drop_zone()` (currently at coal_piece.gd:37-51):

```gdscript
# Called by border zone Area2D when coal enters drop zone
func _on_entered_drop_zone():
    # Skip if already counted as delivered
    if has_been_tracked:
        queue_free()  # Still remove it, just don't count
        return

    # Mark as tracked FIRST (before incrementing)
    has_been_tracked = true

    # Track as dropped
    Level1Vars.coal_dropped += 1
    if Level1Vars.DEBUG_COAL_TRACKING:
        print("[COAL] Dropped! Total: ", Level1Vars.coal_dropped)

    # Clean streak penalty (if unlocked)
    if Level1Vars.clean_streak_unlocked:
        # Check if forgiveness charges available
        if Level1Vars.forgiveness_charges > 0:
            # Use one forgiveness charge - don't break combo
            Level1Vars.forgiveness_charges -= 1
            print("[COMBO] Forgiveness saved combo! Charges remaining: %d" % Level1Vars.forgiveness_charges)
        else:
            # No forgiveness available - reset combo
            Level1Vars.clean_streak_count = 0
            Level1Vars.forgiveness_coal_counter = 0
            Level1Vars.emit_signal("clean_streak_changed", 0)

    queue_free()  # Remove immediately
```

### Heavy Load Combo Tracking

**Integration Point 1: furnace.gd**

Add batch detection helper function to furnace.gd:

```gdscript
# Check if recent deliveries constitute a heavy load (3+ coal in 1 second)
func _check_heavy_load_batch():
    var current_time = Time.get_ticks_msec() / 1000.0

    # Clean old timestamps (older than batch window)
    var cleaned_timestamps: Array[float] = []
    for timestamp in Level1Vars.recent_delivery_timestamps:
        if current_time - timestamp <= Level1Vars.HEAVY_LOAD_BATCH_WINDOW:
            cleaned_timestamps.append(timestamp)
    Level1Vars.recent_delivery_timestamps = cleaned_timestamps

    # Add current delivery
    Level1Vars.recent_delivery_timestamps.append(current_time)

    # Check if we hit heavy load threshold (3+ deliveries in window)
    if Level1Vars.recent_delivery_timestamps.size() >= 3:
        # Trigger heavy load combo
        Level1Vars.heavy_combo_stacks += 1

        # Refresh timer
        var base_timer = 5.0
        var timer_bonus = Level1Vars.get_heavy_timer_extension()
        Level1Vars.heavy_combo_timer = base_timer + timer_bonus

        # Clear timestamps (batch consumed)
        Level1Vars.recent_delivery_timestamps.clear()

        Level1Vars.emit_signal("heavy_combo_changed", Level1Vars.heavy_combo_stacks, Level1Vars.heavy_combo_timer)

        if Level1Vars.DEBUG_COAL_TRACKING:
            print("[COMBO] Heavy load triggered! Stacks: %d, Timer: %.1fs" % [Level1Vars.heavy_combo_stacks, Level1Vars.heavy_combo_timer])
```

**Integration Point 2: furnace.gd**

Add timer countdown to furnace.gd `_process()`:

```gdscript
func _process(delta):
    # Apply continuous tilt torque while mouse buttons are held
    if left_mouse_held:
        shovel_body.tilt_left(delta)
    if right_mouse_held:
        shovel_body.tilt_right(delta)

    # Spawn coal from tap continuously if below max count
    if active_coal_count < MAX_COAL_PIECES:
        coal_spawn_timer += delta
        if coal_spawn_timer >= COAL_SPAWN_RATE:
            coal_spawn_timer = 0.0
            spawn_coal_from_tap()

    # Heavy combo timer countdown (if unlocked)
    if Level1Vars.heavy_combo_unlocked and Level1Vars.heavy_combo_timer > 0.0:
        Level1Vars.heavy_combo_timer -= delta

        if Level1Vars.heavy_combo_timer <= 0.0:
            # Timer expired - reset stacks
            Level1Vars.heavy_combo_stacks = 0
            Level1Vars.heavy_combo_timer = 0.0
            Level1Vars.emit_signal("heavy_combo_changed", 0, 0.0)
            if Level1Vars.DEBUG_COAL_TRACKING:
                print("[COMBO] Heavy combo expired")
```

**Integration Point 3: coal_piece.gd**

Add heavy combo reset to `_on_entered_drop_zone()` (in the clean_streak_unlocked block):

```gdscript
    # Clean streak penalty (if unlocked)
    if Level1Vars.clean_streak_unlocked:
        # Check if forgiveness charges available
        if Level1Vars.forgiveness_charges > 0:
            # Use one forgiveness charge - don't break combo
            Level1Vars.forgiveness_charges -= 1
            print("[COMBO] Forgiveness saved combo! Charges remaining: %d" % Level1Vars.forgiveness_charges)
        else:
            # No forgiveness available - reset combo
            Level1Vars.clean_streak_count = 0
            Level1Vars.forgiveness_coal_counter = 0
            Level1Vars.emit_signal("clean_streak_changed", 0)

    # Heavy combo penalty (if unlocked) - dropping coal resets heavy stacks
    if Level1Vars.heavy_combo_unlocked:
        Level1Vars.heavy_combo_stacks = 0
        Level1Vars.heavy_combo_timer = 0.0
        Level1Vars.recent_delivery_timestamps.clear()
        Level1Vars.emit_signal("heavy_combo_changed", 0, 0.0)
```

**Design Notes - Heavy Load Mechanics**:
- **Heavy load = multi-coal dump**: Player carries 3+ coal on shovel, tilts to dump them all at furnace
- **1-second window**: All coal pieces from one dump enter delivery zone within ~1 second of each other
- **Batch detection**: Tracks recent delivery timestamps, triggers when 3+ deliveries occur within window
- **Skill-based**: Requires successfully carrying multiple coal without spilling (higher stamina drain, higher risk)
- **Sequential batches**: Delivering 6 coal fast = 2 heavy load stacks (3+3)

---

## Testing Strategy

### Manual Test Criteria

**Tier System**:
- [ ] At technique_tier=1, only Rhythm, Firm Grip, Economy of Motion appear in pool
- [ ] At technique_tier=2, Determination, Cadence, Streak Ceiling also appear
- [ ] At technique_tier=3, Power Surge, Pressure Training, Extended Window, Repetition Learning also appear
- [ ] At technique_tier=4, Perfect Form, Forgiveness, Mass Training also appear
- [ ] Locked tier techniques are completely hidden (not grayed out)
- [ ] technique_tier persists across runs (saved/loaded)
- [ ] technique_tier only resets via full game reset in settings panel
- [ ] reset_techniques() does NOT reset technique_tier

**Core Stat Techniques**:
- [ ] Rhythm reduces base stamina drain (check debug overlay with F3)
- [ ] Economy reduces coal stamina drain (check debug overlay)
- [ ] Determination stacks with both Rhythm AND Economy
- [ ] Multiple selections stack multiplicatively (each selection reduces current drain, not base)
- [ ] Quality tiers modify bonuses correctly (Common/Uncommon/Rare/Epic/Legendary)
- [ ] No dead zone - 5 selections of same technique all provide value
- [ ] Rhythm x5 (all Common): ~67% reduction (32.8% final drain)
- [ ] Economy x5 (all Common): ~56% reduction (44.4% final drain)
- [ ] Determination x5 (all Common): ~47% reduction (52.8% final drain)

**Clean Streak System**:
- [ ] Clean streak increments on coal delivery
- [ ] Clean streak resets on coal drop (unless forgiveness active)
- [ ] Forgiveness threshold set by first selection quality (20/18/16/14/12)
- [ ] Forgiveness threshold reduced by subsequent C/U/R selections (-2/-3/-4)
- [ ] Forgiveness max capacity starts at 1, increased by subsequent E/L selections (+1/+2)
- [ ] Forgiveness charges earned when coal counter reaches threshold
- [ ] Forgiveness charges respect max capacity (won't exceed limit)
- [ ] Forgiveness charges consumed when dropping coal (saves combo)
- [ ] Streak Ceiling increases max combo above 20
- [ ] Combo counter caps at maximum value
- [ ] Cadence reduces stamina based on combo count
- [ ] Repetition Learning increases XP based on combo count
- [ ] Perfect Form activates at 10+ combo (50% stamina reduction)

**Heavy Load Combo System**:
- [ ] Heavy load combo triggers on 3+ coal in 1 second
- [ ] Heavy combo timer refreshes on each heavy delivery
- [ ] Heavy combo resets on timer expiration
- [ ] Heavy combo resets on coal drop
- [ ] Power Surge reduces stamina during heavy timer (5% per stack per selection)
- [ ] Pressure Training increases XP during heavy timer (20% per stack per selection)
- [ ] Extended Window lengthens heavy timer

**Shovel Stability**:
- [ ] Firm Grip increases shovel stability (multiplicative stacking)
- [ ] Mass Training dynamically scales stability with combo
- [ ] Shovel stability updates when combo changes (if Mass Training active)

**System Integration**:
- [ ] Combo systems unlock when first relevant technique selected
- [ ] All combo signals emit correctly for UI updates
- [ ] Run reset clears all technique selections and combo states
- [ ] Save/load preserves combo state during same day (techniques NOT saved - reset per run)
- [ ] Combo state resets when new day begins

---

## Files to Create

- `game/v0.1/data/techniques.gd` - Technique pool definitions (TECHNIQUES dictionary)

## Files to Modify

- `game/v0.1/level1/mind.gd`:
  - Currently exists with basic navigation (30 lines)
  - Add upgrade selection UI logic and card display
  - Preserve existing navigation and settings button connections

- `game/v0.1/level1/level_1_vars.gd`:
  - Add upgrades_qty variable
  - Add selected_techniques dictionary
  - Add combo state variables (unlock flags, counters, timers)
  - Add signals (technique_updated, clean_streak_changed, heavy_combo_changed)
  - Add management functions (add_technique, get_technique_level, reset_techniques)
  - Add all helper functions (get_technique_total_bonus, stamina multipliers, XP multiplier, mass multiplier, combo helpers)
  - Update save/load functions to persist technique selections and upgrades_qty

- `game/v0.1/level1/furnace.gd`:
  - Add Mind button to scene (initially hidden)
  - Add _update_mind_button_visibility() function
  - Call visibility check in _ready() and when returning from Mind scene
  - Modify `_on_coal_entered_delivery_zone()` to add XP multiplier and call `_check_heavy_load_batch()`
  - Add `_check_heavy_load_batch()` function for batch detection
  - Add heavy combo timer countdown in `_process()`

- `game/v0.1/level1/furnace.tscn`:
  - Add Mind button to menu (hidden by default)

- `game/v0.1/level1/mind.tscn`:
  - Add UpgradeContainer (HBoxContainer) with 4 upgrade card panels (2 visible, 2 hidden)
  - Structure each card with VBoxContainer containing icon, name, level, description, select button

- `game/v0.1/level1/mind.gd`:
  - Implement _generate_upgrade_options() to filter available techniques and roll quality
  - Implement _display_upgrade_options() to populate cards with technique+quality data
  - Implement _on_upgrade_selected() to handle selection and looping
  - Implement _draw_quality_for_technique() for quality rolls
  - Implement _apply_quality_styling() for card borders
  - Implement _get_quality_multiplier() helper

- `game/v0.1/level1/shovel.gd`:
  - Modify stamina drain to query drain multipliers
  - Add update_shovel_mass() function
  - Connect to clean_streak_changed signal for dynamic mass updates (if Weighted Mastery)

- `game/v0.1/level1/coal_piece.gd`:
  - Modify `_on_entered_delivery_zone()` to track clean streak increments and forgiveness charge earning
  - Modify `_on_entered_drop_zone()` to handle forgiveness charge consumption and combo resets (both no-drop and heavy)

---

## Implementation Checklist

### Phase 1: Data Structure
- [ ] Create `data/techniques.gd` with TECHNIQUES dictionary
- [ ] Verify all technique definitions include `tier` field (1-4)
- [ ] Verify tier assignments match design: T1 (Rhythm, Firm Grip, Economy), T2 (Determination, Cadence, Streak Ceiling), T3 (Power Surge, Pressure Training, Extended Window, Repetition Learning), T4 (Perfect Form, Forgiveness, Mass Training)
- [ ] Test preload pattern works from level_1_vars.gd

### Phase 2: Mind Scene UI
- [ ] Add Mind button to furnace.tscn (hidden by default)
- [ ] Add UpgradeContainer with 4 card panels to mind.tscn (2 visible, 2 hidden)
- [ ] Structure each card with VBoxContainer (icon, name, level, description, select button)
- [ ] Create mind.gd with basic structure
- [ ] Implement _update_mind_button_visibility() in furnace.gd
- [ ] Implement _generate_upgrade_options() in mind.gd
- [ ] Implement _display_upgrade_options() in mind.gd
- [ ] Implement _on_upgrade_selected() with looping logic in mind.gd
- [ ] Implement _draw_quality_for_technique() with uniform distribution in mind.gd
- [ ] Implement _apply_card_styling() in mind.gd (handles both border rarity and text quality colors)
- [ ] Test Mind button appears on level-up
- [ ] Test upgrade selection loop works correctly
- [ ] Test card styling shows rarity colors

### Phase 3: Storage Setup
- [ ] Add upgrades_qty variable to Level1Vars
- [ ] Add technique_tier variable to Level1Vars (default: 1)
- [ ] Add selected_techniques dictionary to Level1Vars
- [ ] Add combo system variables to Level1Vars
- [ ] Add signals to Level1Vars
- [ ] Implement add_technique() with combo unlocking
- [ ] Implement get_technique_level()
- [ ] Implement reset_techniques() with full state reset (resets techniques per-run)
- [ ] Update save/load functions to persist combo state (NOT techniques - per-run design)
- [ ] Test save/load preserves combo state but NOT techniques

### Phase 4: Core Helpers
- [ ] Implement get_technique_total_bonus()
- [ ] Implement get_quality_multiplier()
- [ ] Test bonus calculation with multiple qualities
- [ ] Verify boolean techniques return 0.0 for bonus

### Phase 5: Stamina Effects
- [ ] Implement get_base_stamina_drain_multiplier() with multiplicative stacking
- [ ] Implement get_coal_stamina_drain_multiplier() with multiplicative stacking
- [ ] Modify shovel.gd to use drain multipliers
- [ ] Test Rhythm technique (base drain reduction) - verify multiplicative stacking
- [ ] Test Economy technique (coal drain reduction) - verify multiplicative stacking
- [ ] Test Determination technique (all drain reduction) - verify multiplicative stacking
- [ ] Test stacking of multiple techniques - verify no dead zones at max level
- [ ] Test quality variations affect per-selection reduction (20-32% range for Rhythm)
- [ ] Verify Rhythm x5 (all Common) = 32.8% final drain (67.2% reduction)
- [ ] Verify no floor cap - techniques can reduce drain below 10%

### Phase 6: Clean Streak
- [ ] Implement get_clean_streak_max()
- [ ] Implement get_forgiveness_threshold() (hybrid: first quality sets base, C/U/R reduce)
- [ ] Implement get_forgiveness_max_capacity() (hybrid: first grants 1, E/L add capacity)
- [ ] Add combo tracking to coal_piece._on_entered_delivery_zone()
- [ ] Add forgiveness charge earning to coal_piece._on_entered_delivery_zone() (uses threshold + capacity)
- [ ] Add combo reset to coal_piece._on_entered_drop_zone()
- [ ] Test combo increments correctly
- [ ] Test combo resets on drop
- [ ] Test forgiveness threshold varies by first selection quality (20/18/16/14/12)
- [ ] Test forgiveness threshold reduced by subsequent C/U/R selections (-2/-3/-4)
- [ ] Test forgiveness capacity increased by subsequent E/L selections (+1/+2)
- [ ] Test forgiveness charges earned when counter reaches threshold
- [ ] Test forgiveness charges respect max capacity (won't exceed limit)
- [ ] Test forgiveness charge consumption saves combo
- [ ] Test Streak Ceiling increases max
- [ ] Test Cadence scales with combo
- [ ] Test Repetition Learning scales XP with combo
- [ ] Test Perfect Form activates at 10+ combo

### Phase 7: Heavy Load Combo
- [ ] Implement get_heavy_timer_extension()
- [ ] Add heavy load trigger logic to furnace._check_heavy_load_batch()
- [ ] Add heavy timer countdown in furnace._process()
- [ ] Add heavy combo reset to coal_piece._on_entered_drop_zone()
- [ ] Test heavy load triggers on 3+ coal in 1s
- [ ] Test timer refreshes on heavy delivery
- [ ] Test timer expiration resets stacks
- [ ] Test Power Surge scales with heavy stacks
- [ ] Test Pressure Training scales XP with heavy stacks
- [ ] Test Extended Window lengthens timer

### Phase 8: Shovel Stability
- [ ] Implement get_shovel_mass_multiplier() with multiplicative stacking for Firm Grip
- [ ] Add update_shovel_mass() to shovel.gd
- [ ] Connect to clean_streak_changed signal
- [ ] Test Firm Grip increases stability (multiplicative stacking)
- [ ] Test Mass Training scales stability dynamically with combo
- [ ] Test stability updates when combo changes (if Mass Training active)

### Phase 9: Integration Testing
- [ ] Test combo systems unlock when first technique selected
- [ ] Test all signals fire correctly
- [ ] Test run reset clears all state
- [ ] Test with debug overlay (F3) to verify values
- [ ] Play full run with various technique combinations

---

## Design Notes

### Combo System Unlocking

**Decision**: Combo systems unlock dynamically when first relevant technique selected.

**Rationale**: Players can ignore combo mechanics entirely if they prefer simpler stat upgrades. Unlocking on first technique selection creates "aha!" moment and tutorial opportunity.

**Alternatives rejected**:
- Both combos always active (clutters UI for players not using them)
- Separate unlock items (adds complexity)

### Clean Streak Persistence

**Decision**: Clean streak persists indefinitely until broken (by dropping coal without forgiveness).

**Rationale**: Rewards long-term consistency, creates high-stakes moments. Forgiveness system adds flexibility without removing tension.

**Alternatives rejected**:
- Time-based decay (punishes slow/careful play)
- Reset on delivery (no meaningful persistence)
- Cap at lower value (less satisfying progression)

### Heavy Load Timer

**Decision**: Heavy load uses decay timer (5s base, extendable).

**Rationale**: Creates distinct rhythm from clean streak. Time pressure encourages aggressive burst play style that contrasts with careful no-drop approach.

**Alternatives rejected**:
- Persistent stacks (no urgency, too similar to no-drop)
- Instant bursts only (no stacking depth)
- Shorter timer (too punishing, frustrating)

### Effect Stacking

**Decision**: Non-combo techniques use multiplicative stacking (each selection reduces current drain). Combo techniques sum selections, then multiply by combo count, then apply once.

**Rationale**:
- **Multiplicative stacking**: Eliminates dead zones - every selection always provides value (20-32% of current drain). Natural diminishing returns prevent overpowered builds without artificial caps.
- **Combo additive scaling**: Total technique bonus × combo count = powerful at high combos (reward for skilled play), but still requires investment in technique to scale.

**Example - Rhythm x5 (all Common quality):**
- Selection 1: 100% → 80% (20% reduction)
- Selection 2: 80% → 64% (16% reduction)
- Selection 3: 64% → 51.2% (12.8% reduction)
- Selection 4: 51.2% → 41.0% (10.2% reduction)
- Selection 5: 41.0% → 32.8% (8.2% reduction)
- **Total: 67.2% reduction, every level provides value**

**Example - Cadence x3 (all Common) at combo 15:**
- Total bonus: 0.03 × 3 = 0.09 per stack
- Combo multiplier: 0.09 × 15 = 1.35 (135% reduction)
- Applied: mult × (1.0 - 1.35) = mult × 0.0 (capped at 0)
- **Very powerful at high combos - reward for skillful play**

**Alternatives rejected**:
- Pure additive (dead zones where selections become worthless)
- Combo as exponential (0.97^15 too complex, hard to understand)

### Run Persistence

**Decision**: Techniques reset each run (roguelike build variety). Combo state persists during same-day saves but resets when new day begins.

**Rationale**: Per-run technique selection creates build variety and strategic choices. Combo reset on new day prevents exploitation without needing complex save-scumming prevention. Players start each run fresh with clean slate for technique selection.

### Forgiveness Hybrid System

**Decision**: First forgiveness selection sets threshold (coal needed to earn 1 charge) based on quality. Subsequent selections either reduce threshold (Common/Uncommon/Rare) or add capacity (Epic/Legendary).

**How It Works**:

**First Selection** - Sets base threshold:
- Common: 20 coal per charge
- Uncommon: 18 coal per charge
- Rare: 16 coal per charge
- Epic: 14 coal per charge
- Legendary: 12 coal per charge
- First selection always grants 1 capacity

**Subsequent Selections** - Quality determines effect:
- Common: -2 to threshold
- Uncommon: -3 to threshold
- Rare: -4 to threshold
- Epic: +1 to max capacity (no threshold change)
- Legendary: +2 to max capacity (no threshold change)

**Examples**:
- 1 Common: 20 coal per charge, max 1 charge
- 1 Common + 1 Rare: 16 coal per charge (20-4), max 1 charge
- 1 Legendary + 1 Epic: 12 coal per charge, max 4 charges (1+1+2)
- 1 Rare + 2 Common + 1 Legendary: 12 coal per charge (16-2-2), max 3 charges (1+2)

**Rationale**:
- Lower rarities make forgiveness more frequent (reduce threshold)
- Higher rarities make forgiveness more powerful (increase capacity for big streaks)
- Creates meaningful choice: frequent small safety vs rare big safety
- First draw quality matters strategically (sets starting threshold)
- Hybrid approach captures both progression vectors (frequency + capacity)

### Technique Description Display

**Decision**: Descriptions show exact percentages by default with optional hide/show toggle (planned as purchasable feature).

**Implementation**: Add `show_exact_technique_values: bool` to Level1Vars (default true). Mind scene UI checks this flag before rendering descriptions.

**Future Feature**: "Mysterious Mastery" upgrade - toggle to hide exact values, aligning with knowledge-based progression principle. Player learns through observation instead of explicit numbers.

**Examples**:
- `show_exact_technique_values = true`: "Reduces stamina drain by 25%"
- `show_exact_technique_values = false`: "Reduces stamina drain"

### Batch Detection Architecture

**Decision**: Heavy load uses rolling timestamp window (1 second) with batch consumption on trigger.

**How It Works**:
1. Each coal delivery adds timestamp to `recent_delivery_timestamps` array
2. Old timestamps (>1 second) removed before checking
3. If 3+ timestamps exist, trigger heavy load and clear array
4. Allows sequential batches (6 coal fast = 2 heavy loads)

**Rationale**: Matches actual gameplay (dump multi-coal load → all pieces enter within 1 second). Simple, performant, intuitive.

**Alternative considered**: Track "heavy delivery" events separately (rejected - adds complexity, harder to understand).

### Boolean Technique Pattern

**Decision**: Boolean techniques (Perfect Form) require two checks:
1. Technique presence: `"perfect_form" in selected_techniques`
2. Threshold condition: `clean_streak_count >= 10`

**Rationale**: Presence check ensures player owns technique, threshold check ensures activation condition met. Both necessary.

**Note**: Boolean techniques return 0.0 from `get_technique_total_bonus()` since they don't use additive bonuses.

### Uniform Quality Distribution

**Decision**: All techniques use the same quality roll distribution (40% common, 30% uncommon, 20% rare, 8% epic, 2% legendary) regardless of technique rarity.

**Rationale**: Separates two distinct reward axes:
- **Technique rarity**: How often it appears in the pool (excitement from seeing rare technique)
- **Quality**: How powerful this specific draw is (excitement from high-quality roll)

**Why not rarity-weighted quality**: Having rare techniques also roll better quality creates double-dipping that makes common techniques feel bad. With uniform distribution, seeing a Common technique with Legendary quality is exciting, and seeing a Legendary technique with Common quality creates interesting "do I take this now or wait?" decisions.

### Dual-Color Card System

**Decision**: Upgrade cards display two colors - border shows technique rarity (gray/green/blue/purple/gold), percentage text shows quality (same color scheme).

**Rationale**: Both pieces of information matter for selection:
- Border color = "this technique is rare to see" (pool frequency)
- Text color = "this draw is powerful" (quality multiplier)

**Example**: Uncommon technique (green border) with Epic quality (purple percentage text) - player sees it's not a super-rare technique, but this particular roll is very strong.

### Combo Reset on New Day

**Decision**: Combo state persists during same-day saves but resets when new day begins.

**How it works**:
1. Combo counters, timers, and charges save/load normally during same day
2. When new day begins (day boundary event), all combo state resets
3. No auto-save triggers on combo breaks - unnecessary with day-based reset
4. Players can save mid-session without losing combo progress

**Rationale**: Natural reset boundary prevents long-term exploitation while allowing normal save/load during play sessions. Simpler than save-scumming prevention logic. Combo systems are session-based, not persistent progression.

**Alternative considered**: Auto-save on combo breaks - rejected because combos already reset on day boundary, making save-scumming prevention redundant.

---

## Open Questions

- [ ] Should there be visual feedback for combo milestones (10, 20, 30+)?
- [ ] Should heavy load threshold be upgradeable (reduce from 3 coal to 2)?
- [ ] Should combo values display in UI outside of debug overlay?
- [ ] Should there be audio cues for combo events (unlock, milestone, break)?

---

## Future Expansion Hooks

**Multi-Resource Costs**: Experience costs currently informational. See [2.x-additional-resource-pools.md](2.x-additional-resource-pools.md) for Insight, Passion, Drive integration.

**Rarity-Weighted Selection**: Appearance rarity defined but not enforced. Will filter pool by rarity percentages when implemented.

**Pool Expansion**: Current pool has 13 techniques. Room for 30+ in [2.x-content-and-balance.md](2.x-content-and-balance.md).

**Visual Feedback**: Combo meters, timer displays, particle effects, milestone celebrations.

---

**Last Updated**: 2026-01-07
**Status**: Ready for Implementation
**Version**: 5.11 (Mass→Stability terminology)
**Supersedes**: Plans 2.12-upgrade-pool.md, 2.13-apply-upgrade.md, and 2.14-shovelling-level-up.md

**Changelog v5.11** (2026-01-07):
- **TERMINOLOGY**: Changed "Shovel mass" to "Shovel stability" in all user-facing text
- Firm Grip description now reads "Shovel stability" instead of "Shovel mass"
- Mass Training description now reads "Shovel stability per streak"
- Debug overlay label changed from "Shovel Mass" to "Shovel Stability"
- Internal category name ("mass") and function names unchanged (still affects physics mass)
- Thematic reasoning: the shovel's mass doesn't change, but stability/grip does

**Changelog v5.10** (2026-01-07):
- **FIX**: Stability category techniques now display as positive percentages (+X%) instead of negative
- Firm Grip and Mass Training show "+15%" and "+2%" respectively (stability increases are good)
- Other percentage techniques still show as negative (stamina drain reductions)
- Updated `_display_upgrade_options()` to check category for sign determination

**Changelog v5.9** (2026-01-07):
- **ADDED**: Tier system to control technique availability
- Added `tier` field (1-4) to all technique definitions
- Added `technique_tier` variable to Level1Vars (default: 1)
- Tier 1: Rhythm, Firm Grip, Economy of Motion (simple stat boosts)
- Tier 2: Determination, Cadence, Streak Ceiling (introduces clean streak)
- Tier 3: Power Surge, Pressure Training, Extended Window, Repetition Learning (heavy combo + deeper streak)
- Tier 4: Perfect Form, Forgiveness, Mass Training (capstone abilities)
- Updated `_generate_upgrade_options()` to filter by `Level1Vars.technique_tier`
- `technique_tier` is persistent progression (saved/loaded), NOT reset per-run
- `technique_tier` only resets via full game reset in settings panel
- Locked tier techniques are completely hidden from pool (not grayed out)
- External systems control tier unlocks (not tied to player level)

**Changelog v5.8** (2026-01-05):
- **CHANGE**: Player now starts at level 0 instead of level 1
- First upgrade must be earned via XP, not given at game start
- Updated level_1_vars.gd: player_level init, load default, and reset_to_defaults()

**Changelog v5.7** (2025-12-31):
- **REBALANCE**: Weakened heavy load combo techniques to reduce power level
  - Power Surge: 0.05 (was 0.08) - now 5% per stack per selection
  - Pressure Training: 0.20 (was 0.50) - now 20% per stack per selection
- **RENAME**: "mass_training" → "firm_grip" (common rarity, base technique)
- **RENAME**: "weighted_mastery" → "mass_training" (epic rarity, combo-scaling technique)
- Updated get_shovel_mass_multiplier() to use multiplicative stacking for Firm Grip
- Updated all code references, test criteria, and implementation checklist

**Changelog v5.6** (2025-12-31):
- **MAJOR CHANGE**: Switched from additive to multiplicative stacking for non-combo techniques
- **Eliminates dead zones**: Every technique selection now always provides value (20-32% of current drain)
- Updated base bonus values: Rhythm 0.20 (was 0.25), Determination 0.12 (was 0.15), Economy 0.15 (was 0.10)
- Updated combo techniques: Cadence 0.03 (was 0.05)
- Removed 10% floor cap on stamina drain - natural diminishing returns from multiplicative stacking
- Completely rewrote get_base_stamina_drain_multiplier() and get_coal_stamina_drain_multiplier()
- Each selection now loops through qualities and applies reduction multiplicatively
- Combo techniques still sum selections, then multiply by combo count, then apply once
- Updated Design Notes "Effect Stacking" section with new examples and rationale
- Removed "Minimum Caps" design note (no longer needed)
- Updated test criteria with multiplicative stacking tests and expected values
- Updated quality tier example table to use Rhythm base 0.20

**Changelog v5.5** (2025-12-30):
- **CRITICAL FIX**: Removed SceneNetwork references - using existing Global.change_scene() pattern
- **CRITICAL FIX**: Changed techniques.gd from `extends Node` to `class_name TechniquesData` for proper global access
- **CRITICAL FIX**: Moved mind.gd from "Files to Create" to "Files to Modify" (file already exists with 30 lines)
- **CRITICAL FIX**: Techniques now reset per-run (roguelike design) - removed from save/load persistence
- **CRITICAL FIX**: Removed auto-save triggers on combo breaks (combos reset on new day, not save-scum prevention)
- Added shovel signal connection architecture notes (RigidBody2D scene instance pattern)
- Updated Design Notes "Run Persistence" section - techniques reset each run for build variety
- Updated Design Notes "Save-Scumming Prevention" to "Combo Reset on New Day" - simpler natural reset
- Removed `selected_techniques` from save/load functions (per-run design)
- Updated all preload patterns to use class_name global access
- Updated test criteria and implementation checklist to match per-run design

**Changelog v5.4**:
- **MAJOR CHANGE**: All techniques now use uniform quality distribution (40% common, 30% uncommon, 20% rare, 8% epic, 2% legendary)
- Removed technique rarity-based quality roll tables - quality is now independent of technique rarity
- **UI CHANGE**: Card border color = technique rarity, percentage text color = quality rarity (dual-color system)
- Renamed `_apply_quality_styling()` to `_apply_card_styling()` - now handles both border and text colors
- Simplified `_draw_quality_for_technique()` to use single uniform distribution
- Removed cost display from Mind scene cards (cost field is for future multi-resource system only)
- Updated save/load functions to include combo state variables
- Added Design Notes sections: Uniform Quality Distribution, Dual-Color Card System
- Updated test criteria and implementation checklist to reflect changes

**Changelog v5.3**:
- **IMPLEMENTED**: Hybrid forgiveness system (threshold + capacity mechanics)
- First forgiveness selection sets threshold based on quality (20/18/16/14/12 for C/U/R/E/L)
- Subsequent C/U/R selections reduce threshold (-2/-3/-4)
- Subsequent E/L selections add max capacity (+1/+2)
- First selection always grants 1 capacity
- Updated coal delivery logic in Part 7 to use get_forgiveness_threshold() and get_forgiveness_max_capacity()
- Charges now respect max capacity (won't exceed limit)
- Updated Design Notes section with complete hybrid system documentation
- Updated test criteria to reflect threshold and capacity mechanics
- Updated implementation checklist Phase 6 with hybrid system tests
- Fixed get_quality_multiplier() in Part 6 to include uncommon tier (1.1x)

**Changelog v5.2**:
- **ADDED**: Uncommon rarity tier between Common and Rare (5 total rarities now)
- Added Uncommon quality multiplier: 1.1x (between Common 1.0x and Rare 1.2x)
- Added Uncommon visual indicator: Green border color (0.4, 0.8, 0.4)
- Updated draw quality distribution tables for all 5 rarity tiers
- Updated _draw_quality_for_technique() to include uncommon tier in all match cases
- Updated _apply_quality_styling() to handle uncommon green border
- Updated _get_quality_multiplier() to return 1.1 for uncommon
- Updated technique appearance rarity distribution (40% common, 30% uncommon, 20% rare, 8% epic, 2% legendary)
- Reassigned 4 techniques to uncommon rarity: Economy of Motion, Cadence, Streak Ceiling, Extended Window
- Updated all quality tier tables and examples throughout plan

**Changelog v5.1**:
- **CRITICAL FIX**: Quality now rolled when generating options (not when selecting) - players choose technique+quality combo
- **CRITICAL FIX**: Forgiveness now uses charge system instead of backwards threshold system
- Removed deferred techniques (Pattern Recognition, Flow, Perfect Balance) to eliminate dead code
- Updated _generate_upgrade_options() to return {tech_id, quality} dictionaries
- Updated _display_upgrade_options() to show quality in card title and border color
- Updated _on_upgrade_selected() to receive quality as parameter instead of rolling it
- Renamed _apply_rarity_styling() to _apply_quality_styling() (border color = draw quality, not technique rarity)
- Added _get_quality_multiplier() helper to mind.gd
- Changed forgiveness_coal_count to forgiveness_charges + forgiveness_coal_counter variables
- Updated get_forgiveness_threshold() to get_forgiveness_charges_per_milestone()
- Forgiveness now earns charges every 10 coal (additive with quality scaling)
- Updated all coal delivery/drop logic to use charge system
- Updated all test criteria and checklists to reflect changes
- Technique count: 13 (was 16, removed 3 deferred)

**Changelog v5.0**:
- **MAJOR**: Merged Mind scene UI flow from 2.14-shovelling-level-up.md
- Added Part 4.5: Mind Scene UI and Selection Flow (UI layout, card display, selection logic)
- Added `upgrades_qty` variable for tracking total selections (Mind button visibility)
- Added complete mind.gd implementation (option generation, display, selection handling, quality drawing, styling)
- Removed branch-locking system (was incompatible with single-pool design)
- Updated Files to Create/Modify sections with Mind UI components
- Added Phase 2 to implementation checklist for Mind scene UI
- Renumbered subsequent phases (3-9)
- Plan now self-contained: no references to archived/obsolete plans
