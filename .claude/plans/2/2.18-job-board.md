# Job Board Scene

## Overview

A physical job board location where players can:
1. View unlocked jobs (discovered through gameplay/exploration)
2. Assign their protagonist to idle on a specific job when leaving the game
3. Navigate directly to job locations for active play
4. See current idle status

**Location Name**: "The Job Wall" - a physical location in the play area where work assignments are posted.

**Alternative Names** (if Job Wall doesn't fit later):
- The Work Board
- The Crew Board
- The Roster Hall
- The Labor Exchange

**Rendering**: This is a physical location scene in the play area, NOT a menu overlay or separate UI system. Players navigate to it like any other game location.

---

## Dependencies

- **2.x-offline-earnings.md**: Provides `OfflineEarningsManager` which handles timestamp verification and duration caps. Calls into this plan's `JobBoardManager.process_offline_session()`.
- **2.x-dishwash.md**: First job with both active and idle modes (earns Holes)

**Ownership Boundaries**:

**OfflineEarningsManager (2.17) owns:**
- Timestamp verification and server time fetching
- 2-hour duration cap enforcement
- Welcome-back notification display
- Calls JobBoardManager.process_offline_session()

**JobBoardManager (this plan) owns:**
- Job registration system (jobs self-register handlers)
- Unlock state tracking (via explicit unlock_job() calls)
- Idle assignment management (protagonist + future workers)
- Routing offline earnings to registered job handlers
- Validation and error recovery for missing/invalid jobs

**Individual Job Plans (e.g., 2.19.8 dishwash-offline) own:**
- Job-specific progression systems (mugs_washed, etc.)
- Idle earning rate calculations based on progression
- Self-registration with JobBoardManager on ready
- Triggering unlock_job() when discovery conditions met
- Job-specific UI and active gameplay

---

## Core Mechanics

### Job States

Each job can be in one of these states:
- **Locked**: Not yet discovered (greyed out or hidden)
- **Unlocked**: Available but not currently idling
- **Active Idle**: Currently assigned for idle earnings

Only ONE job can be actively idling at a time (for the protagonist).

### Future: Hireable Workers

Eventually, players may hire additional workers who can each idle one job. This is out of scope for initial implementation, but the data model is designed to support it from the start (see `idle_assignments` dictionary below).

---

## Scene Design

### Visual Layout

```
+------------------------------------------+
|  THE JOB WALL                            |
|  [Back Navigation Button]                |
+------------------------------------------+
|                                          |
|   +------------+  +------------+         |
|   | DISHWASH   |  | [LOCKED]   |         |
|   | [icon]     |  | ???        |         |
|   | [Work]     |  |            |         |
|   | [Visit]    |  |            |         |
|   +------------+  +------------+         |
|                                          |
|   +------------+  +------------+         |
|   | [LOCKED]   |  | [LOCKED]   |         |
|   | ???        |  | ???        |         |
|   +------------+  +------------+         |
|                                          |
|   Current Idle: Dishwashing              |
|                                          |
+------------------------------------------+
```

### UI Elements

**See [1.8-default-theme.md](../1/1.8-default-theme.md) for complete button styling guidelines.**

1. **Job Cards**: Grid of job postings
   - Job name and icon
   - **"Work" button** (AffirmativeButton - gold) - assigns job for idle earnings
   - **"Visit" button** (ForwardNavButton - light blue) - navigates to job's active scene
   - Locked state shows "???" or silhouette

2. **Status Panel**: Bottom area showing:
   - Currently selected idle job (if any)
   - Use transparent label or dark grey highlight (1.8 line 361-371)

3. **Navigation**:
   - **Back button** (BackNavButton - navy blue) - exits to previous scene

---

## Data Model

### JobData Resource

```gdscript
class_name JobData
extends Resource

@export var job_id: String  # "dishwash", "coal_sort", etc.
@export var display_name: String
@export var icon: Texture2D
@export var scene_path: String  # Path to active scene
```

### JobProgressData (Saved per-player)

```gdscript
var job_progress: Dictionary = {
    "dishwash": {
        "unlocked": true,
    },
    # ... other jobs
}

# Idle assignments for protagonist and future workers
# Design supports multiple workers from day one
var idle_assignments: Dictionary = {
    "protagonist": "dishwash",  # job_id or "" if none
    # Future: "worker_1": "coal_sort", etc.
}
```

### JobBoardManager Implementation

**Registration System** - Jobs self-register instead of hardcoded routing:

```gdscript
# JobBoardManager.gd

var _job_handlers: Dictionary = {}  # job_id -> Callable

# Jobs call this on ready to register themselves
func register_job(job_id: String, handler: Callable) -> void:
    _job_handlers[job_id] = handler
    DebugLogger.info("Registered job handler: " + job_id)

# Unlock tracking with explicit calls
signal job_unlocked(job_id: String)

func unlock_job(job_id: String) -> void:
    if not Level1Vars.job_progress.has(job_id):
        Level1Vars.job_progress[job_id] = {}
    Level1Vars.job_progress[job_id]["unlocked"] = true
    job_unlocked.emit(job_id)
    DebugLogger.info("Unlocked job: " + job_id)

func is_job_unlocked(job_id: String) -> bool:
    return Level1Vars.job_progress.get(job_id, {}).get("unlocked", false)

# Protagonist idle assignment (future: extend for workers)
func get_protagonist_idle_job() -> String:
    return Level1Vars.idle_assignments.get("protagonist", "")

func set_protagonist_idle_job(job_id: String) -> void:
    Level1Vars.idle_assignments["protagonist"] = job_id

# Called by OfflineEarningsManager with already-capped seconds
func process_offline_session(capped_seconds: int) -> Dictionary:
    var job_id = get_protagonist_idle_job()

    if job_id == "":
        return {}  # No job assigned

    # Validate job still exists and is unlocked
    if not is_job_unlocked(job_id):
        DebugLogger.warn("Idle job no longer unlocked: " + job_id)
        set_protagonist_idle_job("")  # Clear invalid assignment
        return {}

    # Validate handler exists
    if not _job_handlers.has(job_id):
        DebugLogger.error("Missing handler for job: " + job_id)
        # Don't clear - might be temporary code issue
        return {}

    # Call job-specific handler
    var result = _job_handlers[job_id].call(capped_seconds)

    # Validate result structure
    if not result.has("earnings") or not result.has("currency") or not result.has("job_name"):
        DebugLogger.error("Invalid earnings result from job: " + job_id)
        return {}

    return result
```

**Job Scene Integration** - Each job registers itself:

```gdscript
# Example: dishwash_manager.gd
func _ready():
    JobBoardManager.register_job("dishwash", _calculate_offline_earnings)

func _calculate_offline_earnings(seconds: int) -> Dictionary:
    var interval = Level1Vars.offline_dishwash_seconds
    var holes_earned = int(seconds / interval)
    Level1Vars.holes += holes_earned

    return {
        "earnings": holes_earned,
        "currency": "holes",
        "job_name": "Dishwashing"
    }
```

---

## Integration with Offline System

**See 2.x-offline-earnings.md for the full flow.**

Summary:
1. On game load, `OfflineEarningsManager` fetches server time and calculates capped elapsed seconds
2. It calls `JobBoardManager.process_offline_session(capped_seconds)`
3. JobBoardManager validates assignment, routes to registered job handler
4. Job handler calculates earnings and returns result
5. OfflineEarningsManager displays the notification

This plan provides:
- Save `idle_assignments` dictionary to save file
- Registration system for jobs via `register_job()`
- Unlock tracking via `unlock_job()` and `is_job_unlocked()`
- Validation and error recovery in `process_offline_session()`

---

## Job Unlocking

Jobs are unlocked through:
1. **Story progression**: Main narrative unlocks core jobs
2. **Exploration**: Finding certain locations reveals job opportunities
3. **Prerequisites**: Some jobs require mastery in others first

**Unlock Process**:
- Job scenes explicitly call `JobBoardManager.unlock_job(job_id)` when discovery conditions are met
- Example: First visit to dishwash area calls `unlock_job("dishwash")`
- JobBoardManager emits `job_unlocked` signal for UI updates
- Job board UI reads unlock state via `is_job_unlocked(job_id)`

This keeps unlock logic in job scenes while providing centralized tracking.

---

## Implementation Steps

### Step 1: Data Layer

1. Create `JobData` resource class
2. Create job data files for each job (`dishwash.tres`, etc.)
3. Add `job_progress` dictionary to save system
4. Add `idle_assignments` dictionary to Level1Vars (replaces `current_idle_job`)

### Step 2: Job Board Manager

1. Create `JobBoardManager` singleton
2. Implement registration system:
   - `register_job(job_id, handler)`
   - `_job_handlers` dictionary
3. Implement unlock tracking:
   - `unlock_job(job_id)`
   - `is_job_unlocked(job_id)`
   - `job_unlocked` signal
4. Implement idle assignment:
   - `get_protagonist_idle_job()`
   - `set_protagonist_idle_job(job_id)`
5. Implement `process_offline_session(capped_seconds)` with validation

### Step 3: Scene UI

1. Create `job_board.tscn` scene (physical location in play area)
2. Implement job card component (reusable for grid)
3. Implement locked/unlocked/active states
4. Wire up buttons using 1.8-default-theme.md:
   - "Work" button (AffirmativeButton - gold)
   - "Visit" button (ForwardNavButton - light blue)
   - Back navigation (BackNavButton - navy blue)
5. Status panel with current idle job display

---

## Files to Create

1. `job_board/job_data.gd` - Resource class
2. `job_board/job_board_manager.gd` - Singleton
3. `job_board/job_board.tscn` - Scene
4. `job_board/job_board.gd` - Scene script
5. `job_board/job_card.tscn` - Reusable card component
6. `job_board/job_card.gd` - Card script

## Files to Modify

1. `level1/level_1_vars.gd` - Add `idle_assignments` dictionary and `job_progress` dictionary
2. `save_manager.gd` - Add job progress and idle assignments to save/load
3. `project.godot` - Register JobBoardManager autoload

**Integration Notes**:
- `offline_earnings_manager.gd` is created/owned by 2.x-offline-earnings.md and calls JobBoardManager.process_offline_session()
- Individual job scenes (e.g., dishwash_manager.gd) must call:
  - `JobBoardManager.register_job()` on ready
  - `JobBoardManager.unlock_job()` when discovery conditions met

---

## Navigation

The job board is a **physical location scene** accessible from:
- Evening menu (primary access point)
- Scene network as a standalone location

**Button Navigation**:
- **"Visit" button** on job card → Navigate to that job's active scene
- **Back button** (top of scene) → Return to previous scene (e.g., evening menu)

---

## Open Questions

1. **Visual style**: Bulletin board? Chalk board? Digital display? Need art direction.
2. **Sound**: What ambient sounds for the location? Mechanical hums? Footsteps?
3. **Worker hiring**: When does this unlock? What's the cost? (Defer to future plan)

---

## Success Criteria

- [ ] Job board renders as physical location in play area
- [ ] Player can view all unlocked jobs on the board
- [ ] Player can assign protagonist to idle one job via "Work" button
- [ ] "Visit" button navigates to job's active scene
- [ ] Jobs self-register handlers on load (no hardcoded routing)
- [ ] Idle earnings calculate correctly via registered handlers
- [ ] Offline earnings show job-specific breakdown
- [ ] Validation prevents earnings from missing/unlocked jobs
- [ ] Save/load preserves job progress and idle assignments
- [ ] Button styling follows 1.8-default-theme.md (Work=gold, Visit=blue, Back=navy)

---

## Notes

This system provides the infrastructure for job assignment and discovery. Individual job plans (like 2.19.8 dishwash-offline) define their own progression systems and idle earning rates.

**Design Philosophy**:
- **Registration over hardcoding** - Jobs self-register handlers instead of hardcoded match statements. Adding new jobs never requires modifying JobBoardManager.
- **Validation and recovery** - System validates job state before processing earnings and gracefully handles missing/invalid jobs.
- **Future-proof data model** - `idle_assignments` dictionary designed from day one to support multiple workers, not just protagonist.
- **Clear ownership** - JobBoardManager owns routing and validation, job scenes own progression and earnings logic, neither duplicates the other's concerns.
