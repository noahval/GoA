# Upgrade System (Pool + Application)

**Goal**: Define and implement the complete upgrade system - technique pool, selection mechanics, and gameplay effect application

**Success Criteria**:
- Diverse upgrade paths with combo mechanics that reward skillful play
- All technique effects correctly modify gameplay mechanics
- Combo systems track state properly and unlock dynamically

**Prerequisites**:
- Shovel experience system ([2.x-shovel-experience.md](2.x-shovel-experience.md)) complete
- Scene navigation via Global.change_scene() (existing pattern in mind.gd)

**Scope**:
- Complete upgrade system: UI flow, technique pool, draw quality, effect application, combo mechanics
- Supersedes previous separate "Upgrade Pool", "Apply Upgrade", and "Shovelling Level-Up" plans

---

## Part 1: Technique Pool Definition

### Upgrade Categories

All upgrades are in a single pool (no branch locking). Organized into functional categories:

**Core Stats**: Basic improvements to shoveling mechanics (stamina, XP gain, shovel physics)

**No-Drop Combo Path**: Unlocks and enhances streak mechanics for shoveling without dropping coal. Combo persists between deliveries until coal is dropped.

**Heavy Load Combo Path**: Unlocks and enhances burst bonuses for delivering 3+ coal within 1 second (successfully dumping a multi-coal load). Uses a 5-second decay timer that refreshes on each heavy delivery.

**Shovel Mass Path**: Increases shovel weight for different physics behavior

---

## Part 2: Data Structure

### File: res://data/techniques.gd

**IMPORTANT**: Using class_name for global access pattern (no preload needed).

**Cost Field Note**: The `cost` field in technique definitions is for future multi-resource system ([2.x-additional-resource-pools.md](2.x-additional-resource-pools.md)). It is NOT displayed in Mind scene UI and NOT deducted during selection. Players select from available options without spending resources.

**Technique Description Display**: Descriptions include exact percentages by default. A `show_exact_values` flag (planned as purchasable feature) can toggle between "Reduces stamina drain by 25%" and "Reduces stamina drain" to align with knowledge-based progression principles.

```gdscript
# Technique pool definitions for upgrade system
# Referenced by Mind scene and effect application
# Using class_name for global access (no need to preload)
class_name TechniquesData

const TECHNIQUES = {
    # ========================================================================
    # CORE STAT TECHNIQUES
    # ========================================================================

    "rhythm": {
        "name": "Rhythm",
        "rarity": "common",
        "cost": 10,
        "max_level": 5,
        "description": "Reduces stamina drain from holding shovel",
        "effect": {"base_bonus": 0.25},  # -25% drain per selection
        "category": "core"
    },
    "determination": {
        "name": "Determination",
        "rarity": "rare",
        "cost": 16,
        "max_level": 5,
        "description": "All stamina drains slower",
        "effect": {"base_bonus": 0.15},  # -15% all drain per selection
        "category": "core"
    },
    "economy_of_motion": {
        "name": "Economy of Motion",
        "rarity": "uncommon",
        "cost": 20,
        "max_level": 5,
        "description": "Reduces stamina drain while carrying coal",
        "effect": {"base_bonus": 0.10},  # -10% coal carrying drain per selection
        "category": "core"
    },

    # ========================================================================
    # NO-DROP COMBO TECHNIQUES
    # ========================================================================
    # Selecting any of these unlocks the no-drop combo mechanic
    # Combo increases by 1 for each coal delivered without dropping
    # Combo resets to 0 when coal is dropped (unless Forgiveness prevents it)

    "cadence": {
        "name": "Cadence",
        "rarity": "uncommon",
        "cost": 15,
        "max_level": 5,
        "description": "Streak reduces stamina drain (stacks with combo)",
        "effect": {"base_bonus": 0.05},  # -5% per combo stack per selection
        "category": "nodrop_combo",
        "unlocks_combo": true
    },
    "repetition_learning": {
        "name": "Repetition Learning",
        "rarity": "rare",
        "cost": 18,
        "max_level": 5,
        "description": "Streak multiplies XP earned (stacks with combo)",
        "effect": {"base_bonus": 0.10},  # +10% XP per combo stack per selection
        "category": "nodrop_combo",
        "unlocks_combo": true
    },
    "perfect_form": {
        "name": "Perfect Form",
        "rarity": "legendary",
        "cost": 50,
        "max_level": 1,
        "description": "At 10+ streak, massive stamina reduction",
        "effect": {"type": "boolean", "threshold": 10, "reduction": 0.50},
        "category": "nodrop_combo",
        "unlocks_combo": true
    },
    "forgiveness": {
        "name": "Forgiveness",
        "rarity": "epic",
        "cost": 30,
        "max_level": 5,
        "description": "Prevents combo loss from occasional drops",
        "effect": {"base_bonus": 1.0},  # First: sets threshold, Later: C/U/R reduce threshold, E/L add capacity
        "category": "nodrop_combo",
        "unlocks_combo": true
    },
    "combo_ceiling": {
        "name": "Combo Ceiling",
        "rarity": "uncommon",
        "cost": 20,
        "max_level": 5,
        "description": "Increases combo cap for stronger bonuses",
        "effect": {"base_bonus": 10},  # +10 to max combo per selection
        "category": "nodrop_combo",
        "unlocks_combo": true
    },

    # ========================================================================
    # HEAVY LOAD COMBO TECHNIQUES
    # ========================================================================
    # Selecting any of these unlocks the heavy load combo mechanic
    # Heavy load = successfully dumping 3+ coal from shovel (all deliveries within 1 second)
    # Each successful heavy delivery increments stacks and refreshes the 5-second decay timer
    # Timer expiration or dropping coal resets stacks to 0
    # Rewards risky play of carrying multiple coal pieces without spilling

    "power_surge": {
        "name": "Power Surge",
        "rarity": "rare",
        "cost": 18,
        "max_level": 5,
        "description": "Heavy deliveries reduce stamina drain temporarily",
        "effect": {"base_bonus": 0.15},  # -15% stamina per heavy stack per selection
        "category": "heavy_combo",
        "unlocks_combo": true
    },
    "pressure_training": {
        "name": "Pressure Training",
        "rarity": "rare",
        "cost": 20,
        "max_level": 5,
        "description": "Heavy deliveries multiply XP earned",
        "effect": {"base_bonus": 0.50},  # +50% XP per heavy stack per selection
        "category": "heavy_combo",
        "unlocks_combo": true
    },
    "extended_window": {
        "name": "Extended Window",
        "rarity": "uncommon",
        "cost": 22,
        "max_level": 5,
        "description": "Heavy load bonus lasts longer",
        "effect": {"base_bonus": 1.0},  # +1.0s to timer per selection
        "category": "heavy_combo",
        "unlocks_combo": true
    },

    # ========================================================================
    # SHOVEL MASS TECHNIQUES
    # ========================================================================

    "mass_training": {
        "name": "Mass Training",
        "rarity": "common",
        "cost": 12,
        "max_level": 5,
        "description": "Increases shovel weight",
        "effect": {"base_bonus": 0.15},  # +15% mass per selection
        "category": "mass"
    },
    "weighted_mastery": {
        "name": "Weighted Mastery",
        "rarity": "epic",
        "cost": 35,
        "max_level": 5,
        "description": "Combo increases shovel mass dynamically",
        "effect": {"base_bonus": 0.02},  # +2% mass per combo stack per selection
        "category": "mass",
        "requires": "nodrop_combo"  # Must have unlocked no-drop combo system
    },
}
```

**Loading pattern in other files**:
```gdscript
# In mind.gd or level_1_vars.gd
# TechniquesData is globally available via class_name, no preload needed
const TECHNIQUES = TechniquesData.TECHNIQUES
```

---

## Part 3: Draw Quality System

When upgrade options are generated for display, each technique has a **draw quality** randomly assigned that determines how powerful that particular instance is. Players choose between technique+quality combinations.

### Quality Tiers

Each technique has a base bonus defined in its data structure. The quality tier multiplies this bonus:

| Quality Tier | Quality Multiplier | Example (Rhythm base 0.25) |
|--------------|-------------------|----------------------------|
| Common | x1.0 | 0.25 x 1.0 = 0.25 |
| Uncommon | x1.1 | 0.25 x 1.1 = 0.275 |
| Rare | x1.2 | 0.25 x 1.2 = 0.30 |
| Epic | x1.4 | 0.25 x 1.4 = 0.35 |
| Legendary | x1.6 | 0.25 x 1.6 = 0.40 |

**Formula**: `actual_bonus = base_bonus x quality_multiplier`

**Why multiplicative**: Rare quality gives 20% MORE effect (1.2x instead of 1.0x). For Rhythm's base 25% bonus, a Rare draw gives 30% (25% base x 1.2 = 30%).

### Draw Quality Weights

**All techniques use the same quality distribution** regardless of technique rarity. This keeps the reward system simple: technique rarity affects how often it appears in the pool, quality affects how powerful this specific draw is.

**Uniform quality distribution for all techniques**:

| Quality | Chance | Cumulative |
|---------|--------|------------|
| Common | 40% | 0.00-0.40 |
| Uncommon | 30% | 0.40-0.70 |
| Rare | 20% | 0.70-0.90 |
| Epic | 8% | 0.90-0.98 |
| Legendary | 2% | 0.98-1.00 |

**Design intent**: Seeing a rare technique is exciting because it appears infrequently in the pool (when rarity-weighted selection is implemented). Quality roll is independent - all techniques have equal chance for high-quality draws.

**Implementation**: See `_draw_quality_for_technique()` in Part 4.5 for roll logic.

---

## Part 4: Rarity System

**Appearance Rarity** controls how often a technique appears in level-up pools (NOT implemented yet - all techniques have equal appearance chance currently).

**Future Distribution** (for rarity-weighted selection):
- **Common**: 40% chance to appear
- **Uncommon**: 30% chance to appear
- **Rare**: 20% chance to appear
- **Epic**: 8% chance to appear
- **Legendary**: 2% chance to appear

**Visual Indicator**: Border color on technique card (see Part 4.5 below for UI implementation)

| Rarity | Color Name | RGB Values | Godot Color |
|--------|-----------|-----------|-------------|
| Common | Gray | (153, 153, 153) | Color(0.6, 0.6, 0.6) |
| Uncommon | Green | (102, 204, 102) | Color(0.4, 0.8, 0.4) |
| Rare | Blue | (51, 128, 255) | Color(0.2, 0.5, 1.0) |
| Epic | Purple | (179, 77, 255) | Color(0.7, 0.3, 1.0) |
| Legendary | Gold | (255, 204, 51) | Color(1.0, 0.8, 0.2) |

---

## Part 4.5: Mind Scene UI and Selection Flow

### Mind Button Visibility Logic

When player levels up (`Level1Vars.player_level` increases via coal delivery XP), the Mind button appears in the furnace menu allowing access to the upgrade selection scene.

**Location**: [level1/furnace.gd](../../game/v0.1/level1/furnace.gd)

**Add Mind button to furnace menu**:
- Mind button should be hidden by default in furnace.tscn
- Button text: "Mind" (theme: ForwardNavButton)
- Position: Below existing furnace menu buttons

**Visibility check function**:
```gdscript
# In furnace.gd
func _update_mind_button_visibility():
    # Show Mind button when player has unspent level-ups
    var has_pending_upgrades = Level1Vars.player_level > Level1Vars.upgrades_qty
    mind_button.visible = has_pending_upgrades
```

**When to call**:
- When furnace scene loads (`_ready()`)
- When returning from Mind scene
- After player level-up (Level1Vars should emit signal when leveling up)

### Mind Scene UI Layout

Create the upgrade selection interface with space for up to 4 options (currently showing 2).

**File**: [level1/mind.tscn](../../game/v0.1/level1/mind.tscn)

**Scene structure**:
```
Mind (inherits scene_template.tscn)
  AspectContainer/MainContainer
    Background (TextureRect - mind.jpg)
    mainarea/
      Menu/
        ToFurnaceButton (existing)
      PlayArea/
        UpgradeContainer (HBoxContainer)
          UpgradeCard1 (Panel - custom style)
          UpgradeCard2 (Panel - custom style)
          UpgradeCard3 (Panel - hidden initially, for future expansion)
          UpgradeCard4 (Panel - hidden initially, for future expansion)
```

**Layout specifications**:
- **UpgradeContainer**: Centered in PlayArea, uses HBoxContainer with spacing
- **Card count**: Show 2 cards currently, hide cards 3-4 (reserved for future upgrade)
- **Card sizing**: Each card ~300-400px wide, flexible height
- **Spacing**: 20-30px between cards

**Individual upgrade card structure**:
```
UpgradeCard (Panel with custom theme)
  VBoxContainer (margin 10px)
    IconContainer (TextureRect or ColorRect placeholder)
    NameLabel (Label - larger font, technique name)
    LevelLabel (Label - "Level X" or "NEW")
    DescriptionLabel (RichTextLabel - technique description)
    SelectButton (Button - "Select")
```

**Card styling**:
- Use Panel with custom StyleBox (border, background color)
- Rarity-based border colors (from table above)
- Hover state: Slight scale or brightness change

### Mind Scene Script Implementation

**File**: [level1/mind.gd](../../game/v0.1/level1/mind.gd)

**Load technique data**:
```gdscript
# At top of mind.gd
# TechniquesData is globally available via class_name
const TECHNIQUES = TechniquesData.TECHNIQUES
```

**Generate upgrade options**:
```gdscript
func _generate_upgrade_options(count: int) -> Array:
    # Returns array of dictionaries: [{"tech_id": "rhythm", "quality": "rare"}, ...]

    var available_techniques = []

    for tech_id in TECHNIQUES.keys():
        var tech = TECHNIQUES[tech_id]

        # Exclude maxed techniques
        var current_level = Level1Vars.get_technique_level(tech_id)
        var max_level = tech.get("max_level", 5)
        if current_level >= max_level:
            continue

        # Check if technique requires unlocked combo system
        if tech.has("requires"):
            if tech["requires"] == "nodrop_combo" and not Level1Vars.nodrop_combo_unlocked:
                continue

        available_techniques.append(tech_id)

    # Shuffle and take first 'count' items
    available_techniques.shuffle()
    var selected = available_techniques.slice(0, count)

    # Roll quality for each selected technique
    var options = []
    for tech_id in selected:
        var quality = _draw_quality_for_technique(tech_id)
        options.append({"tech_id": tech_id, "quality": quality})

    return options
```

**Display upgrade cards**:
```gdscript
func _display_upgrade_options(options: Array):
    # Populate card 1 and card 2 with technique+quality data
    for i in range(min(options.size(), 2)):
        var option = options[i]
        var tech_id = option["tech_id"]
        var quality = option["quality"]
        var tech = TECHNIQUES[tech_id]
        var card = upgrade_cards[i]  # Reference to UpgradeCard1/2 nodes

        # Set technique name (no quality or cost shown in name)
        card.get_node("VBoxContainer/NameLabel").text = tech["name"]

        # Calculate and show actual bonus with quality multiplier
        var base_bonus = tech["effect"].get("base_bonus", 0.0)
        var quality_mult = _get_quality_multiplier(quality)
        var actual_bonus = base_bonus * quality_mult

        # Build description with actual values (in quality color if exact values enabled)
        var description = tech["description"]
        var description_label = card.get_node("VBoxContainer/DescriptionLabel")

        if Level1Vars.show_exact_technique_values and base_bonus > 0:
            # For percentage bonuses, show the quality-scaled value in quality color
            var percentage_text = ""
            if base_bonus < 1.0:  # Percentage bonus
                percentage_text = " (%.0f%%)" % (actual_bonus * 100)
            else:  # Flat bonus
                percentage_text = " (+%.1f)" % actual_bonus

            # Set description with colored percentage
            description_label.text = description + percentage_text
            # Apply quality color to percentage text (requires RichTextLabel)
            # This will be styled by _apply_card_styling()
        else:
            description_label.text = description

        # Show current level or "NEW"
        var current_level = Level1Vars.get_technique_level(tech_id)
        if current_level > 0:
            card.get_node("VBoxContainer/LevelLabel").text = "Level %d" % current_level
        else:
            card.get_node("VBoxContainer/LevelLabel").text = "NEW"

        # Set rarity-based border color and quality-based text color
        _apply_card_styling(card, tech_id, quality)

        # Connect Select button
        var select_btn = card.get_node("VBoxContainer/SelectButton")
        # Disconnect previous signals if any
        if select_btn.is_connected("pressed", _on_upgrade_selected):
            select_btn.disconnect("pressed", _on_upgrade_selected)
        select_btn.pressed.connect(_on_upgrade_selected.bind(tech_id, quality))

        card.visible = true
```

**Handle selection**:
```gdscript
func _on_upgrade_selected(tech_id: String, quality: String):
    # Quality was already rolled when options were generated
    Level1Vars.add_technique(tech_id, quality)

    # Increment total upgrades
    Level1Vars.upgrades_qty += 1

    # Check if more upgrades needed
    if Level1Vars.upgrades_qty < Level1Vars.player_level:
        # Generate new options with fresh quality rolls
        var new_options = _generate_upgrade_options(2)
        _display_upgrade_options(new_options)
    else:
        # All caught up, return to furnace
        Global.change_scene("res://level1/furnace.tscn")

func _draw_quality_for_technique(tech_id: String) -> String:
    # Uniform quality distribution for all techniques (see Part 3)
    var roll = randf()

    # 40% common, 30% uncommon, 20% rare, 8% epic, 2% legendary
    if roll < 0.40:
        return "common"
    elif roll < 0.70:  # 0.40 + 0.30
        return "uncommon"
    elif roll < 0.90:  # 0.70 + 0.20
        return "rare"
    elif roll < 0.98:  # 0.90 + 0.08
        return "epic"
    else:  # 0.98 + 0.02
        return "legendary"
```

**Apply card styling**:
```gdscript
func _apply_card_styling(card: Panel, tech_id: String, quality: String):
    # Border color based on technique rarity (how rare it is to appear)
    var tech_rarity = TECHNIQUES[tech_id]["rarity"]
    var border_color: Color

    match tech_rarity:
        "common":
            border_color = Color(0.6, 0.6, 0.6)  # Gray
        "uncommon":
            border_color = Color(0.4, 0.8, 0.4)  # Green
        "rare":
            border_color = Color(0.2, 0.5, 1.0)  # Blue
        "epic":
            border_color = Color(0.7, 0.3, 1.0)  # Purple
        "legendary":
            border_color = Color(1.0, 0.8, 0.2)  # Gold
        _:
            border_color = Color.WHITE

    # Apply border color to Panel's StyleBox
    var stylebox = card.get_theme_stylebox("panel").duplicate()
    stylebox.border_color = border_color
    card.add_theme_stylebox_override("panel", stylebox)

    # Text color based on quality (how powerful this draw is)
    var quality_color: Color

    match quality:
        "common":
            quality_color = Color(0.6, 0.6, 0.6)  # Gray
        "uncommon":
            quality_color = Color(0.4, 0.8, 0.4)  # Green
        "rare":
            quality_color = Color(0.2, 0.5, 1.0)  # Blue
        "epic":
            quality_color = Color(0.7, 0.3, 1.0)  # Purple
        "legendary":
            quality_color = Color(1.0, 0.8, 0.2)  # Gold
        _:
            quality_color = Color.WHITE

    # Apply quality color to percentage text in description
    # Note: Requires DescriptionLabel to be RichTextLabel for BBCode support
    var description_label = card.get_node("VBoxContainer/DescriptionLabel")
    if description_label is RichTextLabel:
        # Use BBCode to color the percentage portion
        var text = description_label.text
        if "(" in text:  # Has percentage text
            var parts = text.split("(", true, 1)
            var color_hex = quality_color.to_html(false)
            description_label.text = parts[0] + "[color=#" + color_hex + "](" + parts[1] + "[/color]"
            description_label.bbcode_enabled = true

func _get_quality_multiplier(quality: String) -> float:
    match quality:
        "common": return 1.0
        "uncommon": return 1.1
        "rare": return 1.2
        "epic": return 1.4
        "legendary": return 1.6
        _: return 1.0
```

---

## Part 5: Storage and State Management

### Data Storage in Level1Vars

**Location**: `level_1_vars.gd`

**Variables to add**:
```gdscript
# Upgrade tracking
var upgrades_qty: int = 0  # Total upgrades selected this run (for Mind button visibility)

# Technique selection tracking
var selected_techniques: Dictionary = {}
# Structure: { technique_id: { "level": int, "qualities": Array[String] } }

# Example after selecting Rhythm three times with different draw qualities:
# selected_techniques = {
#     "rhythm": {
#         "level": 3,
#         "qualities": ["common", "rare", "common"]
#     },
#     "cadence": {
#         "level": 1,
#         "qualities": ["rare"]
#     }
# }

# Combo system unlock flags
var nodrop_combo_unlocked: bool = false
var heavy_combo_unlocked: bool = false

# UI display settings
var show_exact_technique_values: bool = true  # Show exact percentages in descriptions (purchasable toggle feature)

# No-drop combo state
var nodrop_combo_count: int = 0
var nodrop_combo_max: int = 20  # Increased by Combo Ceiling technique
var forgiveness_charges: int = 0  # Charges available to save combo from drops
var forgiveness_coal_counter: int = 0  # Coal delivered since last charge earned
var forgiveness_threshold: int = 0  # Coal needed to earn 1 charge (set by first selection quality)
var forgiveness_max_capacity: int = 0  # Maximum charges that can be banked

# Heavy load combo state
var heavy_combo_stacks: int = 0
var heavy_combo_timer: float = 0.0  # Counts down from 5.0s + bonuses
var recent_delivery_timestamps: Array[float] = []  # Timestamps of recent deliveries for batch detection
const HEAVY_LOAD_BATCH_WINDOW: float = 1.0  # Time window for detecting 3+ coal deliveries (seconds)

# Signals for UI updates
signal technique_updated(technique_id: String, new_level: int)
signal nodrop_combo_changed(new_count: int)
signal heavy_combo_changed(new_stacks: int, timer_remaining: float)
```

### Basic Management Functions

**Add to level_1_vars.gd**:

```gdscript
# TechniquesData is globally available via class_name
const TECHNIQUES = TechniquesData.TECHNIQUES

func add_technique(technique_id: String, draw_quality: String) -> void:
    if technique_id not in selected_techniques:
        selected_techniques[technique_id] = {
            "level": 1,
            "qualities": [draw_quality]
        }
    else:
        selected_techniques[technique_id]["level"] += 1
        selected_techniques[technique_id]["qualities"].append(draw_quality)

    # Check if this technique unlocks a combo system
    if technique_id in TECHNIQUES:
        var tech_data = TECHNIQUES[technique_id]
        if tech_data.has("unlocks_combo") and tech_data["unlocks_combo"]:
            if tech_data["category"] == "nodrop_combo":
                nodrop_combo_unlocked = true
            elif tech_data["category"] == "heavy_combo":
                heavy_combo_unlocked = true

    emit_signal("technique_updated", technique_id, selected_techniques[technique_id]["level"])

func get_technique_level(technique_id: String) -> int:
    if technique_id not in selected_techniques:
        return 0
    return selected_techniques[technique_id]["level"]

func reset_techniques() -> void:
    upgrades_qty = 0
    selected_techniques.clear()
    nodrop_combo_unlocked = false
    heavy_combo_unlocked = false
    nodrop_combo_count = 0
    nodrop_combo_max = 20
    forgiveness_charges = 0
    forgiveness_coal_counter = 0
    forgiveness_threshold = 0
    forgiveness_max_capacity = 0
    heavy_combo_stacks = 0
    heavy_combo_timer = 0.0
    recent_delivery_timestamps.clear()
```

### Save/Load Integration

**Add to level_1_vars.gd save/load functions**:

```gdscript
# In get_save_data()
func get_save_data() -> Dictionary:
    return {
        # ...existing save data...
        # NOTE: Techniques are NOT saved - they reset each run (per-run progression)
        # Combo state IS saved - combos reset when new day begins, but persist during same-day saves
        "show_exact_technique_values": show_exact_technique_values,
        "nodrop_combo_count": nodrop_combo_count,
        "nodrop_combo_max": nodrop_combo_max,
        "forgiveness_charges": forgiveness_charges,
        "forgiveness_coal_counter": forgiveness_coal_counter,
        "forgiveness_threshold": forgiveness_threshold,
        "forgiveness_max_capacity": forgiveness_max_capacity,
        "heavy_combo_stacks": heavy_combo_stacks,
        "heavy_combo_timer": heavy_combo_timer,
        "recent_delivery_timestamps": recent_delivery_timestamps.duplicate(),
    }

# In load_save_data()
func load_save_data(data: Dictionary):
    # ...existing load code...
    # Techniques NOT loaded - reset each run
    show_exact_technique_values = data.get("show_exact_technique_values", true)
    # Load combo state (persists during same day, resets when new day begins)
    nodrop_combo_count = data.get("nodrop_combo_count", 0)
    nodrop_combo_max = data.get("nodrop_combo_max", 20)
    forgiveness_charges = data.get("forgiveness_charges", 0)
    forgiveness_coal_counter = data.get("forgiveness_coal_counter", 0)
    forgiveness_threshold = data.get("forgiveness_threshold", 0)
    forgiveness_max_capacity = data.get("forgiveness_max_capacity", 0)
    heavy_combo_stacks = data.get("heavy_combo_stacks", 0)
    heavy_combo_timer = data.get("heavy_combo_timer", 0.0)
    recent_delivery_timestamps = data.get("recent_delivery_timestamps", [])
```

**Backward Compatibility**: Using `data.get(key, default)` ensures old save files without technique data load correctly with empty/default values. Existing player progress (XP, currency, etc.) preserved.

**Per-Run Design**: Techniques and unlock flags reset each run (roguelike build variety). Combo state persists during same-day saves but resets when new day begins.

---

## Part 6: Effect Application

### Core Helper Functions

**Add to level_1_vars.gd**:

```gdscript
# ============================================================================
# TECHNIQUE EFFECT HELPERS
# ============================================================================

# Core calculation function - sums all quality-scaled bonuses for a technique
func get_technique_total_bonus(technique_id: String) -> float:
    if technique_id not in selected_techniques:
        return 0.0

    # Validate technique exists in definition
    if technique_id not in TECHNIQUES:
        push_warning("Unknown technique: " + technique_id)
        return 0.0

    # Handle boolean techniques (like Perfect Form, Perfect Balance)
    var effect_data = TECHNIQUES[technique_id]["effect"]
    if effect_data.has("type") and effect_data["type"] == "boolean":
        return 0.0  # Boolean techniques checked with has_technique(), not bonus calculation

    var base_bonus = effect_data["base_bonus"]
    var qualities = selected_techniques[technique_id]["qualities"]
    var total = 0.0

    for quality in qualities:
        var quality_mult = get_quality_multiplier(quality)
        total += base_bonus * quality_mult

    return total

func get_quality_multiplier(quality: String) -> float:
    match quality:
        "common": return 1.0
        "uncommon": return 1.1
        "rare": return 1.2
        "epic": return 1.4
        "legendary": return 1.6
        _:
            push_warning("Unknown quality tier: " + quality)
            return 1.0
```

**Example calculation (Rhythm with Common + Rare + Common)**:
- Draw 1 (Common): 0.25 x 1.0 = 0.25
- Draw 2 (Rare): 0.25 x 1.2 = 0.30
- Draw 3 (Common): 0.25 x 1.0 = 0.25
- **Total bonus**: 0.25 + 0.30 + 0.25 = 0.80
- **Final multiplier applied to stamina drain**: 1.0 - 0.80 = 0.20 (20% of original drain)

### Stamina Drain Modifiers

**Add to level_1_vars.gd**:

```gdscript
# Returns multiplier for base stamina drain (from holding shovel)
# Affected by: Rhythm, Determination, Cadence, Perfect Form
func get_base_stamina_drain_multiplier() -> float:
    var total_reduction = 0.0

    # Rhythm: -25% base drain per selection
    if "rhythm" in selected_techniques:
        total_reduction += get_technique_total_bonus("rhythm")

    # Determination: -15% all stamina drain per selection
    if "determination" in selected_techniques:
        total_reduction += get_technique_total_bonus("determination")

    # Cadence: -5% per combo stack per selection
    if "cadence" in selected_techniques and nodrop_combo_unlocked:
        var cadence_bonus = get_technique_total_bonus("cadence")
        total_reduction += cadence_bonus * nodrop_combo_count

    # Perfect Form: -50% at 10+ combo (boolean)
    if "perfect_form" in selected_techniques and nodrop_combo_count >= 10:
        total_reduction += 0.50

    var mult = 1.0 - total_reduction
    return max(0.1, mult)  # Never reduce below 10% of base

# Returns multiplier for coal carrying stamina drain
# Affected by: Economy of Motion, Determination, Power Surge
func get_coal_stamina_drain_multiplier() -> float:
    var total_reduction = 0.0

    # Economy of Motion: -10% coal carrying drain per selection
    if "economy_of_motion" in selected_techniques:
        total_reduction += get_technique_total_bonus("economy_of_motion")

    # Determination: -15% all stamina drain per selection
    if "determination" in selected_techniques:
        total_reduction += get_technique_total_bonus("determination")

    # Power Surge: -15% per heavy stack per selection (while timer active)
    if "power_surge" in selected_techniques and heavy_combo_unlocked and heavy_combo_timer > 0.0:
        var surge_bonus = get_technique_total_bonus("power_surge")
        total_reduction += surge_bonus * heavy_combo_stacks

    var mult = 1.0 - total_reduction
    return max(0.1, mult)  # Never reduce below 10% of base
```

**Usage in shovel.gd**:
```gdscript
func _physics_process(delta):
    # ...existing code...

    if coal_count >= 1 and is_in_work_zone:
        var base_drain = 0.2 * Level1Vars.get_base_stamina_drain_multiplier()
        var coal_drain = coal_count * 0.1 * Level1Vars.get_coal_stamina_drain_multiplier()
        var total_drain = base_drain + coal_drain
        Level1Vars.modify_stamina(-total_drain * delta)
```

### XP Multiplier

**Add to level_1_vars.gd**:

```gdscript
# Returns XP multiplier based on combo states
# Affected by: Repetition Learning, Pressure Training
func get_xp_multiplier() -> float:
    var mult = 1.0

    # Repetition Learning: +10% XP per combo stack per selection
    if "repetition_learning" in selected_techniques and nodrop_combo_unlocked:
        var learning_bonus = get_technique_total_bonus("repetition_learning")
        mult += learning_bonus * nodrop_combo_count

    # Pressure Training: +50% XP per heavy stack per selection
    if "pressure_training" in selected_techniques and heavy_combo_unlocked:
        var pressure_bonus = get_technique_total_bonus("pressure_training")
        mult += pressure_bonus * heavy_combo_stacks

    return mult
```

**Integration in furnace.gd**:
Modify `_on_coal_entered_delivery_zone()` (currently at furnace.gd:292-297):
```gdscript
func _on_coal_entered_delivery_zone(body: Node2D):
    # Only coal can trigger this (collision_mask = 4)
    if body._on_entered_delivery_zone():
        # Award player XP for successful delivery with multiplier
        var base_xp = 1.0
        var xp_with_multiplier = base_xp * Level1Vars.get_xp_multiplier()
        Level1Vars.add_player_exp(xp_with_multiplier)

        # Check for heavy load batch (see Part 7)
        if Level1Vars.heavy_combo_unlocked:
            _check_heavy_load_batch()
```

### Shovel Mass Multiplier

**Add to level_1_vars.gd**:

```gdscript
# Returns shovel mass multiplier
# Affected by: Mass Training, Weighted Mastery
func get_shovel_mass_multiplier() -> float:
    var mult = 1.0

    # Mass Training: +15% per selection
    if "mass_training" in selected_techniques:
        mult += get_technique_total_bonus("mass_training")

    # Weighted Mastery: +2% per combo stack per selection
    if "weighted_mastery" in selected_techniques and nodrop_combo_unlocked:
        var weighted_bonus = get_technique_total_bonus("weighted_mastery")
        mult += weighted_bonus * nodrop_combo_count

    return mult
```

**Usage in shovel.gd**:
```gdscript
# In shovel.gd _ready() or physics setup
func _ready():
    # Connect to Level1Vars signal for dynamic mass updates
    Level1Vars.nodrop_combo_changed.connect(_on_nodrop_combo_changed)
    update_shovel_mass()

func update_shovel_mass():
    var base_mass = Level1Vars.shovel_mass  # Use base value from Level1Vars
    var mass_mult = Level1Vars.get_shovel_mass_multiplier()
    mass = base_mass * mass_mult

# Signal handler for combo changes
func _on_nodrop_combo_changed(new_count: int):
    # If Weighted Mastery is active, update shovel mass dynamically
    if "weighted_mastery" in Level1Vars.selected_techniques:
        update_shovel_mass()
```

**Architecture Notes**:
- Shovel.gd is a scene instance (RigidBody2D) spawned by furnace.gd
- Signal connection happens in shovel's _ready() function
- Uses Level1Vars.shovel_mass as base value (existing variable at line 16 of level_1_vars.gd)
- Dynamic mass updates only apply when Weighted Mastery technique is selected

### Combo System Helpers

**Add to level_1_vars.gd**:

```gdscript
# Returns maximum no-drop combo count (base 20 + Combo Ceiling bonuses)
func get_nodrop_combo_max() -> int:
    var base_max = 20
    if "combo_ceiling" not in selected_techniques:
        return base_max

    var bonus = get_technique_total_bonus("combo_ceiling")
    return base_max + int(bonus)

# Returns coal threshold for earning 1 forgiveness charge
# First selection sets base threshold (20/18/16/14/12 based on quality)
# Subsequent C/U/R selections reduce threshold (-2/-3/-4)
# Epic/Legendary selections don't affect threshold (they add capacity instead)
func get_forgiveness_threshold() -> int:
    if "forgiveness" not in selected_techniques:
        return 0

    var qualities = selected_techniques["forgiveness"]["qualities"]
    if qualities.size() == 0:
        return 0

    # First selection sets base threshold
    var first_quality = qualities[0]
    var threshold = 20  # Base
    match first_quality:
        "common": threshold = 20
        "uncommon": threshold = 18
        "rare": threshold = 16
        "epic": threshold = 14
        "legendary": threshold = 12

    # Subsequent C/U/R selections reduce threshold
    for i in range(1, qualities.size()):
        var quality = qualities[i]
        match quality:
            "common": threshold -= 2
            "uncommon": threshold -= 3
            "rare": threshold -= 4
            # Epic and legendary don't reduce threshold

    return max(1, threshold)  # Never go below 1

# Returns maximum forgiveness charges that can be banked
# First selection grants 1 capacity
# Subsequent Epic selections grant +1, Legendary grant +2
func get_forgiveness_max_capacity() -> int:
    if "forgiveness" not in selected_techniques:
        return 0

    var qualities = selected_techniques["forgiveness"]["qualities"]
    if qualities.size() == 0:
        return 0

    # First selection always grants 1 capacity
    var capacity = 1

    # Subsequent Epic/Legendary selections add capacity
    for i in range(1, qualities.size()):
        var quality = qualities[i]
        match quality:
            "epic": capacity += 1
            "legendary": capacity += 2
            # Common, uncommon, rare don't add capacity

    return capacity

# Returns heavy load timer extension in seconds
func get_heavy_timer_extension() -> float:
    if "extended_window" not in selected_techniques:
        return 0.0

    return get_technique_total_bonus("extended_window")
```

---

## Part 7: Combo System Implementation

### No-Drop Combo Tracking

**Integration Point 1: coal_piece.gd**

Modify `_on_entered_delivery_zone()` (currently at coal_piece.gd:55-74):

```gdscript
# Called by delivery zone Area2D when coal enters furnace
# Returns true if coal was successfully delivered, false if already tracked
func _on_entered_delivery_zone() -> bool:
    # Skip if already counted (matches drop handler pattern)
    if has_been_tracked:
        queue_free()  # Still remove it, just don't count
        return false

    # Mark as tracked FIRST (prevents drop zone from counting it during fade)
    has_been_tracked = true

    # Track as delivered
    Level1Vars.coal_delivered += 1
    if Level1Vars.DEBUG_COAL_TRACKING:
        print("[COAL] Delivered! Total: ", Level1Vars.coal_delivered)

    # No-drop combo tracking (if unlocked)
    if Level1Vars.nodrop_combo_unlocked:
        Level1Vars.nodrop_combo_count = min(
            Level1Vars.nodrop_combo_count + 1,
            Level1Vars.get_nodrop_combo_max()
        )

        # Forgiveness charge tracking (hybrid threshold + capacity system)
        if "forgiveness" in Level1Vars.selected_techniques:
            Level1Vars.forgiveness_coal_counter += 1
            var threshold = Level1Vars.get_forgiveness_threshold()
            if Level1Vars.forgiveness_coal_counter >= threshold:
                # Award 1 charge if below capacity
                var max_capacity = Level1Vars.get_forgiveness_max_capacity()
                if Level1Vars.forgiveness_charges < max_capacity:
                    Level1Vars.forgiveness_charges += 1
                    if Level1Vars.DEBUG_COAL_TRACKING:
                        print("[COMBO] Earned forgiveness charge! Total: %d/%d" % [Level1Vars.forgiveness_charges, max_capacity])
                Level1Vars.forgiveness_coal_counter = 0

        Level1Vars.emit_signal("nodrop_combo_changed", Level1Vars.nodrop_combo_count)

    # Red fade animation: gradually change color to red over 0.3 seconds, then remove
    var tween = create_tween()
    tween.tween_property(self, "modulate", Color.RED, 0.3)
    tween.finished.connect(queue_free)

    return true
```

**Integration Point 2: coal_piece.gd**

Modify `_on_entered_drop_zone()` (currently at coal_piece.gd:37-51):

```gdscript
# Called by border zone Area2D when coal enters drop zone
func _on_entered_drop_zone():
    # Skip if already counted as delivered
    if has_been_tracked:
        queue_free()  # Still remove it, just don't count
        return

    # Mark as tracked FIRST (before incrementing)
    has_been_tracked = true

    # Track as dropped
    Level1Vars.coal_dropped += 1
    if Level1Vars.DEBUG_COAL_TRACKING:
        print("[COAL] Dropped! Total: ", Level1Vars.coal_dropped)

    # No-drop combo penalty (if unlocked)
    if Level1Vars.nodrop_combo_unlocked:
        # Check if forgiveness charges available
        if Level1Vars.forgiveness_charges > 0:
            # Use one forgiveness charge - don't break combo
            Level1Vars.forgiveness_charges -= 1
            print("[COMBO] Forgiveness saved combo! Charges remaining: %d" % Level1Vars.forgiveness_charges)
        else:
            # No forgiveness available - reset combo
            Level1Vars.nodrop_combo_count = 0
            Level1Vars.forgiveness_coal_counter = 0
            Level1Vars.emit_signal("nodrop_combo_changed", 0)

    queue_free()  # Remove immediately
```

### Heavy Load Combo Tracking

**Integration Point 1: furnace.gd**

Add batch detection helper function to furnace.gd:

```gdscript
# Check if recent deliveries constitute a heavy load (3+ coal in 1 second)
func _check_heavy_load_batch():
    var current_time = Time.get_ticks_msec() / 1000.0

    # Clean old timestamps (older than batch window)
    var cleaned_timestamps: Array[float] = []
    for timestamp in Level1Vars.recent_delivery_timestamps:
        if current_time - timestamp <= Level1Vars.HEAVY_LOAD_BATCH_WINDOW:
            cleaned_timestamps.append(timestamp)
    Level1Vars.recent_delivery_timestamps = cleaned_timestamps

    # Add current delivery
    Level1Vars.recent_delivery_timestamps.append(current_time)

    # Check if we hit heavy load threshold (3+ deliveries in window)
    if Level1Vars.recent_delivery_timestamps.size() >= 3:
        # Trigger heavy load combo
        Level1Vars.heavy_combo_stacks += 1

        # Refresh timer
        var base_timer = 5.0
        var timer_bonus = Level1Vars.get_heavy_timer_extension()
        Level1Vars.heavy_combo_timer = base_timer + timer_bonus

        # Clear timestamps (batch consumed)
        Level1Vars.recent_delivery_timestamps.clear()

        Level1Vars.emit_signal("heavy_combo_changed", Level1Vars.heavy_combo_stacks, Level1Vars.heavy_combo_timer)

        if Level1Vars.DEBUG_COAL_TRACKING:
            print("[COMBO] Heavy load triggered! Stacks: %d, Timer: %.1fs" % [Level1Vars.heavy_combo_stacks, Level1Vars.heavy_combo_timer])
```

**Integration Point 2: furnace.gd**

Add timer countdown to furnace.gd `_process()`:

```gdscript
func _process(delta):
    # Apply continuous tilt torque while mouse buttons are held
    if left_mouse_held:
        shovel_body.tilt_left(delta)
    if right_mouse_held:
        shovel_body.tilt_right(delta)

    # Spawn coal from tap continuously if below max count
    if active_coal_count < MAX_COAL_PIECES:
        coal_spawn_timer += delta
        if coal_spawn_timer >= COAL_SPAWN_RATE:
            coal_spawn_timer = 0.0
            spawn_coal_from_tap()

    # Heavy combo timer countdown (if unlocked)
    if Level1Vars.heavy_combo_unlocked and Level1Vars.heavy_combo_timer > 0.0:
        Level1Vars.heavy_combo_timer -= delta

        if Level1Vars.heavy_combo_timer <= 0.0:
            # Timer expired - reset stacks
            Level1Vars.heavy_combo_stacks = 0
            Level1Vars.heavy_combo_timer = 0.0
            Level1Vars.emit_signal("heavy_combo_changed", 0, 0.0)
            if Level1Vars.DEBUG_COAL_TRACKING:
                print("[COMBO] Heavy combo expired")
```

**Integration Point 3: coal_piece.gd**

Add heavy combo reset to `_on_entered_drop_zone()` (in the nodrop_combo_unlocked block):

```gdscript
    # No-drop combo penalty (if unlocked)
    if Level1Vars.nodrop_combo_unlocked:
        # Check if forgiveness charges available
        if Level1Vars.forgiveness_charges > 0:
            # Use one forgiveness charge - don't break combo
            Level1Vars.forgiveness_charges -= 1
            print("[COMBO] Forgiveness saved combo! Charges remaining: %d" % Level1Vars.forgiveness_charges)
        else:
            # No forgiveness available - reset combo
            Level1Vars.nodrop_combo_count = 0
            Level1Vars.forgiveness_coal_counter = 0
            Level1Vars.emit_signal("nodrop_combo_changed", 0)

    # Heavy combo penalty (if unlocked) - dropping coal resets heavy stacks
    if Level1Vars.heavy_combo_unlocked:
        Level1Vars.heavy_combo_stacks = 0
        Level1Vars.heavy_combo_timer = 0.0
        Level1Vars.recent_delivery_timestamps.clear()
        Level1Vars.emit_signal("heavy_combo_changed", 0, 0.0)
```

**Design Notes - Heavy Load Mechanics**:
- **Heavy load = multi-coal dump**: Player carries 3+ coal on shovel, tilts to dump them all at furnace
- **1-second window**: All coal pieces from one dump enter delivery zone within ~1 second of each other
- **Batch detection**: Tracks recent delivery timestamps, triggers when 3+ deliveries occur within window
- **Skill-based**: Requires successfully carrying multiple coal without spilling (higher stamina drain, higher risk)
- **Sequential batches**: Delivering 6 coal fast = 2 heavy load stacks (3+3)

---

## Testing Strategy

### Manual Test Criteria

**Core Stat Techniques**:
- [ ] Rhythm reduces base stamina drain (check debug overlay with F3)
- [ ] Economy reduces coal stamina drain (check debug overlay)
- [ ] Determination stacks with both Rhythm AND Economy
- [ ] Multiple selections stack additively
- [ ] Quality tiers modify bonuses correctly (Common/Rare/Epic/Legendary)

**No-Drop Combo System**:
- [ ] No-drop combo increments on coal delivery
- [ ] No-drop combo resets on coal drop (unless forgiveness active)
- [ ] Forgiveness threshold set by first selection quality (20/18/16/14/12)
- [ ] Forgiveness threshold reduced by subsequent C/U/R selections (-2/-3/-4)
- [ ] Forgiveness max capacity starts at 1, increased by subsequent E/L selections (+1/+2)
- [ ] Forgiveness charges earned when coal counter reaches threshold
- [ ] Forgiveness charges respect max capacity (won't exceed limit)
- [ ] Forgiveness charges consumed when dropping coal (saves combo)
- [ ] Combo Ceiling increases max combo above 20
- [ ] Combo counter caps at maximum value
- [ ] Cadence reduces stamina based on combo count
- [ ] Repetition Learning increases XP based on combo count
- [ ] Perfect Form activates at 10+ combo (50% stamina reduction)

**Heavy Load Combo System**:
- [ ] Heavy load combo triggers on 3+ coal in 1 second
- [ ] Heavy combo timer refreshes on each heavy delivery
- [ ] Heavy combo resets on timer expiration
- [ ] Heavy combo resets on coal drop
- [ ] Power Surge reduces stamina during heavy timer
- [ ] Pressure Training increases XP during heavy timer
- [ ] Extended Window lengthens heavy timer

**Shovel Mass**:
- [ ] Mass Training increases shovel mass
- [ ] Weighted Mastery dynamically scales mass with combo
- [ ] Shovel mass updates when combo changes (if Weighted Mastery active)

**System Integration**:
- [ ] Combo systems unlock when first relevant technique selected
- [ ] All combo signals emit correctly for UI updates
- [ ] Run reset clears all technique selections and combo states
- [ ] Save/load preserves combo state during same day (techniques NOT saved - reset per run)
- [ ] Combo state resets when new day begins

---

## Files to Create

- `game/v0.1/data/techniques.gd` - Technique pool definitions (TECHNIQUES dictionary)

## Files to Modify

- `game/v0.1/level1/mind.gd`:
  - Currently exists with basic navigation (30 lines)
  - Add upgrade selection UI logic and card display
  - Preserve existing navigation and settings button connections

- `game/v0.1/level1/level_1_vars.gd`:
  - Add upgrades_qty variable
  - Add selected_techniques dictionary
  - Add combo state variables (unlock flags, counters, timers)
  - Add signals (technique_updated, nodrop_combo_changed, heavy_combo_changed)
  - Add management functions (add_technique, get_technique_level, reset_techniques)
  - Add all helper functions (get_technique_total_bonus, stamina multipliers, XP multiplier, mass multiplier, combo helpers)
  - Update save/load functions to persist technique selections and upgrades_qty

- `game/v0.1/level1/furnace.gd`:
  - Add Mind button to scene (initially hidden)
  - Add _update_mind_button_visibility() function
  - Call visibility check in _ready() and when returning from Mind scene
  - Modify `_on_coal_entered_delivery_zone()` to add XP multiplier and call `_check_heavy_load_batch()`
  - Add `_check_heavy_load_batch()` function for batch detection
  - Add heavy combo timer countdown in `_process()`

- `game/v0.1/level1/furnace.tscn`:
  - Add Mind button to menu (hidden by default)

- `game/v0.1/level1/mind.tscn`:
  - Add UpgradeContainer (HBoxContainer) with 4 upgrade card panels (2 visible, 2 hidden)
  - Structure each card with VBoxContainer containing icon, name, level, description, select button

- `game/v0.1/level1/mind.gd`:
  - Implement _generate_upgrade_options() to filter available techniques and roll quality
  - Implement _display_upgrade_options() to populate cards with technique+quality data
  - Implement _on_upgrade_selected() to handle selection and looping
  - Implement _draw_quality_for_technique() for quality rolls
  - Implement _apply_quality_styling() for card borders
  - Implement _get_quality_multiplier() helper

- `game/v0.1/level1/shovel.gd`:
  - Modify stamina drain to query drain multipliers
  - Add update_shovel_mass() function
  - Connect to nodrop_combo_changed signal for dynamic mass updates (if Weighted Mastery)

- `game/v0.1/level1/coal_piece.gd`:
  - Modify `_on_entered_delivery_zone()` to track no-drop combo increments and forgiveness charge earning
  - Modify `_on_entered_drop_zone()` to handle forgiveness charge consumption and combo resets (both no-drop and heavy)

---

## Implementation Checklist

### Phase 1: Data Structure
- [ ] Create `data/techniques.gd` with TECHNIQUES dictionary
- [ ] Verify all technique definitions are complete
- [ ] Test preload pattern works from level_1_vars.gd

### Phase 2: Mind Scene UI
- [ ] Add Mind button to furnace.tscn (hidden by default)
- [ ] Add UpgradeContainer with 4 card panels to mind.tscn (2 visible, 2 hidden)
- [ ] Structure each card with VBoxContainer (icon, name, level, description, select button)
- [ ] Create mind.gd with basic structure
- [ ] Implement _update_mind_button_visibility() in furnace.gd
- [ ] Implement _generate_upgrade_options() in mind.gd
- [ ] Implement _display_upgrade_options() in mind.gd
- [ ] Implement _on_upgrade_selected() with looping logic in mind.gd
- [ ] Implement _draw_quality_for_technique() with uniform distribution in mind.gd
- [ ] Implement _apply_card_styling() in mind.gd (handles both border rarity and text quality colors)
- [ ] Test Mind button appears on level-up
- [ ] Test upgrade selection loop works correctly
- [ ] Test card styling shows rarity colors

### Phase 3: Storage Setup
- [ ] Add upgrades_qty variable to Level1Vars
- [ ] Add selected_techniques dictionary to Level1Vars
- [ ] Add combo system variables to Level1Vars
- [ ] Add signals to Level1Vars
- [ ] Implement add_technique() with combo unlocking
- [ ] Implement get_technique_level()
- [ ] Implement reset_techniques() with full state reset (resets techniques per-run)
- [ ] Update save/load functions to persist combo state (NOT techniques - per-run design)
- [ ] Test save/load preserves combo state but NOT techniques

### Phase 4: Core Helpers
- [ ] Implement get_technique_total_bonus()
- [ ] Implement get_quality_multiplier()
- [ ] Test bonus calculation with multiple qualities
- [ ] Verify boolean techniques return 0.0 for bonus

### Phase 5: Stamina Effects
- [ ] Implement get_base_stamina_drain_multiplier()
- [ ] Implement get_coal_stamina_drain_multiplier()
- [ ] Modify shovel.gd to use drain multipliers
- [ ] Test Rhythm technique (base drain reduction)
- [ ] Test Economy technique (coal drain reduction)
- [ ] Test Determination technique (all drain reduction)
- [ ] Test stacking of multiple techniques

### Phase 6: No-Drop Combo
- [ ] Implement get_nodrop_combo_max()
- [ ] Implement get_forgiveness_threshold() (hybrid: first quality sets base, C/U/R reduce)
- [ ] Implement get_forgiveness_max_capacity() (hybrid: first grants 1, E/L add capacity)
- [ ] Add combo tracking to coal_piece._on_entered_delivery_zone()
- [ ] Add forgiveness charge earning to coal_piece._on_entered_delivery_zone() (uses threshold + capacity)
- [ ] Add combo reset to coal_piece._on_entered_drop_zone()
- [ ] Test combo increments correctly
- [ ] Test combo resets on drop
- [ ] Test forgiveness threshold varies by first selection quality (20/18/16/14/12)
- [ ] Test forgiveness threshold reduced by subsequent C/U/R selections (-2/-3/-4)
- [ ] Test forgiveness capacity increased by subsequent E/L selections (+1/+2)
- [ ] Test forgiveness charges earned when counter reaches threshold
- [ ] Test forgiveness charges respect max capacity (won't exceed limit)
- [ ] Test forgiveness charge consumption saves combo
- [ ] Test Combo Ceiling increases max
- [ ] Test Cadence scales with combo
- [ ] Test Repetition Learning scales XP with combo
- [ ] Test Perfect Form activates at 10+ combo

### Phase 7: Heavy Load Combo
- [ ] Implement get_heavy_timer_extension()
- [ ] Add heavy load trigger logic to furnace._check_heavy_load_batch()
- [ ] Add heavy timer countdown in furnace._process()
- [ ] Add heavy combo reset to coal_piece._on_entered_drop_zone()
- [ ] Test heavy load triggers on 3+ coal in 1s
- [ ] Test timer refreshes on heavy delivery
- [ ] Test timer expiration resets stacks
- [ ] Test Power Surge scales with heavy stacks
- [ ] Test Pressure Training scales XP with heavy stacks
- [ ] Test Extended Window lengthens timer

### Phase 8: Shovel Mass
- [ ] Implement get_shovel_mass_multiplier()
- [ ] Add update_shovel_mass() to shovel.gd
- [ ] Connect to nodrop_combo_changed signal
- [ ] Test Mass Training increases mass
- [ ] Test Weighted Mastery scales mass dynamically
- [ ] Test mass updates when combo changes

### Phase 9: Integration Testing
- [ ] Test combo systems unlock when first technique selected
- [ ] Test all signals fire correctly
- [ ] Test run reset clears all state
- [ ] Test with debug overlay (F3) to verify values
- [ ] Play full run with various technique combinations

---

## Design Notes

### Combo System Unlocking

**Decision**: Combo systems unlock dynamically when first relevant technique selected.

**Rationale**: Players can ignore combo mechanics entirely if they prefer simpler stat upgrades. Unlocking on first technique selection creates "aha!" moment and tutorial opportunity.

**Alternatives rejected**:
- Both combos always active (clutters UI for players not using them)
- Separate unlock items (adds complexity)

### No-Drop Combo Persistence

**Decision**: No-drop combo persists indefinitely until broken (by dropping coal without forgiveness).

**Rationale**: Rewards long-term consistency, creates high-stakes moments. Forgiveness system adds flexibility without removing tension.

**Alternatives rejected**:
- Time-based decay (punishes slow/careful play)
- Reset on delivery (no meaningful persistence)
- Cap at lower value (less satisfying progression)

### Heavy Load Timer

**Decision**: Heavy load uses decay timer (5s base, extendable).

**Rationale**: Creates distinct rhythm from no-drop combo. Time pressure encourages aggressive burst play style that contrasts with careful no-drop approach.

**Alternatives rejected**:
- Persistent stacks (no urgency, too similar to no-drop)
- Instant bursts only (no stacking depth)
- Shorter timer (too punishing, frustrating)

### Effect Stacking

**Decision**: Percentage bonuses stack additively, then apply to base value. Combo effects scale multiplicatively with technique level.

**Rationale**: Higher combo + higher technique level = exponential power, but requires both investment AND skill to achieve.

**Alternatives rejected**:
- Multiplicative stacking (too explosive, balance nightmare)
- Combo replaces technique level (removes upgrade choice depth)

### Run Persistence

**Decision**: Techniques reset each run (roguelike build variety). Combo state persists during same-day saves but resets when new day begins.

**Rationale**: Per-run technique selection creates build variety and strategic choices. Combo reset on new day prevents exploitation without needing complex save-scumming prevention. Players start each run fresh with clean slate for technique selection.

### Minimum Caps

**Decision**: Stamina drain multipliers clamped at 0.1 (10% minimum).

**Rationale**: Prevents complete elimination of stamina drain, preserves challenge even with max upgrades. Players should still need skill, not just strong builds.

### Forgiveness Hybrid System

**Decision**: First forgiveness selection sets threshold (coal needed to earn 1 charge) based on quality. Subsequent selections either reduce threshold (Common/Uncommon/Rare) or add capacity (Epic/Legendary).

**How It Works**:

**First Selection** - Sets base threshold:
- Common: 20 coal per charge
- Uncommon: 18 coal per charge
- Rare: 16 coal per charge
- Epic: 14 coal per charge
- Legendary: 12 coal per charge
- First selection always grants 1 capacity

**Subsequent Selections** - Quality determines effect:
- Common: -2 to threshold
- Uncommon: -3 to threshold
- Rare: -4 to threshold
- Epic: +1 to max capacity (no threshold change)
- Legendary: +2 to max capacity (no threshold change)

**Examples**:
- 1 Common: 20 coal per charge, max 1 charge
- 1 Common + 1 Rare: 16 coal per charge (20-4), max 1 charge
- 1 Legendary + 1 Epic: 12 coal per charge, max 4 charges (1+1+2)
- 1 Rare + 2 Common + 1 Legendary: 12 coal per charge (16-2-2), max 3 charges (1+2)

**Rationale**:
- Lower rarities make forgiveness more frequent (reduce threshold)
- Higher rarities make forgiveness more powerful (increase capacity for big streaks)
- Creates meaningful choice: frequent small safety vs rare big safety
- First draw quality matters strategically (sets starting threshold)
- Hybrid approach captures both progression vectors (frequency + capacity)

### Technique Description Display

**Decision**: Descriptions show exact percentages by default with optional hide/show toggle (planned as purchasable feature).

**Implementation**: Add `show_exact_technique_values: bool` to Level1Vars (default true). Mind scene UI checks this flag before rendering descriptions.

**Future Feature**: "Mysterious Mastery" upgrade - toggle to hide exact values, aligning with knowledge-based progression principle. Player learns through observation instead of explicit numbers.

**Examples**:
- `show_exact_technique_values = true`: "Reduces stamina drain by 25%"
- `show_exact_technique_values = false`: "Reduces stamina drain"

### Batch Detection Architecture

**Decision**: Heavy load uses rolling timestamp window (1 second) with batch consumption on trigger.

**How It Works**:
1. Each coal delivery adds timestamp to `recent_delivery_timestamps` array
2. Old timestamps (>1 second) removed before checking
3. If 3+ timestamps exist, trigger heavy load and clear array
4. Allows sequential batches (6 coal fast = 2 heavy loads)

**Rationale**: Matches actual gameplay (dump multi-coal load  all pieces enter within 1 second). Simple, performant, intuitive.

**Alternative considered**: Track "heavy delivery" events separately (rejected - adds complexity, harder to understand).

### Boolean Technique Pattern

**Decision**: Boolean techniques (Perfect Form) require two checks:
1. Technique presence: `"perfect_form" in selected_techniques`
2. Threshold condition: `nodrop_combo_count >= 10`

**Rationale**: Presence check ensures player owns technique, threshold check ensures activation condition met. Both necessary.

**Note**: Boolean techniques return 0.0 from `get_technique_total_bonus()` since they don't use additive bonuses.

### Uniform Quality Distribution

**Decision**: All techniques use the same quality roll distribution (40% common, 30% uncommon, 20% rare, 8% epic, 2% legendary) regardless of technique rarity.

**Rationale**: Separates two distinct reward axes:
- **Technique rarity**: How often it appears in the pool (excitement from seeing rare technique)
- **Quality**: How powerful this specific draw is (excitement from high-quality roll)

**Why not rarity-weighted quality**: Having rare techniques also roll better quality creates double-dipping that makes common techniques feel bad. With uniform distribution, seeing a Common technique with Legendary quality is exciting, and seeing a Legendary technique with Common quality creates interesting "do I take this now or wait?" decisions.

### Dual-Color Card System

**Decision**: Upgrade cards display two colors - border shows technique rarity (gray/green/blue/purple/gold), percentage text shows quality (same color scheme).

**Rationale**: Both pieces of information matter for selection:
- Border color = "this technique is rare to see" (pool frequency)
- Text color = "this draw is powerful" (quality multiplier)

**Example**: Uncommon technique (green border) with Epic quality (purple percentage text) - player sees it's not a super-rare technique, but this particular roll is very strong.

### Combo Reset on New Day

**Decision**: Combo state persists during same-day saves but resets when new day begins.

**How it works**:
1. Combo counters, timers, and charges save/load normally during same day
2. When new day begins (day boundary event), all combo state resets
3. No auto-save triggers on combo breaks - unnecessary with day-based reset
4. Players can save mid-session without losing combo progress

**Rationale**: Natural reset boundary prevents long-term exploitation while allowing normal save/load during play sessions. Simpler than save-scumming prevention logic. Combo systems are session-based, not persistent progression.

**Alternative considered**: Auto-save on combo breaks - rejected because combos already reset on day boundary, making save-scumming prevention redundant.

---

## Open Questions

- [ ] Should there be visual feedback for combo milestones (10, 20, 30+)?
- [ ] Should heavy load threshold be upgradeable (reduce from 3 coal to 2)?
- [ ] Should combo values display in UI outside of debug overlay?
- [ ] Should there be audio cues for combo events (unlock, milestone, break)?

---

## Future Expansion Hooks

**Multi-Resource Costs**: Experience costs currently informational. See [2.x-additional-resource-pools.md](2.x-additional-resource-pools.md) for Insight, Passion, Drive integration.

**Rarity-Weighted Selection**: Appearance rarity defined but not enforced. Will filter pool by rarity percentages when implemented.

**Pool Expansion**: Current pool has 13 techniques. Room for 30+ in [2.x-content-and-balance.md](2.x-content-and-balance.md).

**Visual Feedback**: Combo meters, timer displays, particle effects, milestone celebrations.

---

**Last Updated**: 2025-12-30
**Status**: Ready for Implementation
**Version**: 5.5 (Critical fixes - per-run progression + proper architecture)
**Supersedes**: Plans 2.12-upgrade-pool.md, 2.13-apply-upgrade.md, and 2.14-shovelling-level-up.md

**Changelog v5.5** (2025-12-30):
- **CRITICAL FIX**: Removed SceneNetwork references - using existing Global.change_scene() pattern
- **CRITICAL FIX**: Changed techniques.gd from `extends Node` to `class_name TechniquesData` for proper global access
- **CRITICAL FIX**: Moved mind.gd from "Files to Create" to "Files to Modify" (file already exists with 30 lines)
- **CRITICAL FIX**: Techniques now reset per-run (roguelike design) - removed from save/load persistence
- **CRITICAL FIX**: Removed auto-save triggers on combo breaks (combos reset on new day, not save-scum prevention)
- Added shovel signal connection architecture notes (RigidBody2D scene instance pattern)
- Updated Design Notes "Run Persistence" section - techniques reset each run for build variety
- Updated Design Notes "Save-Scumming Prevention" to "Combo Reset on New Day" - simpler natural reset
- Removed `selected_techniques` from save/load functions (per-run design)
- Updated all preload patterns to use class_name global access
- Updated test criteria and implementation checklist to match per-run design

**Changelog v5.4**:
- **MAJOR CHANGE**: All techniques now use uniform quality distribution (40% common, 30% uncommon, 20% rare, 8% epic, 2% legendary)
- Removed technique rarity-based quality roll tables - quality is now independent of technique rarity
- **UI CHANGE**: Card border color = technique rarity, percentage text color = quality rarity (dual-color system)
- Renamed `_apply_quality_styling()` to `_apply_card_styling()` - now handles both border and text colors
- Simplified `_draw_quality_for_technique()` to use single uniform distribution
- Removed cost display from Mind scene cards (cost field is for future multi-resource system only)
- Updated save/load functions to include combo state variables
- Added Design Notes sections: Uniform Quality Distribution, Dual-Color Card System
- Updated test criteria and implementation checklist to reflect changes

**Changelog v5.3**:
- **IMPLEMENTED**: Hybrid forgiveness system (threshold + capacity mechanics)
- First forgiveness selection sets threshold based on quality (20/18/16/14/12 for C/U/R/E/L)
- Subsequent C/U/R selections reduce threshold (-2/-3/-4)
- Subsequent E/L selections add max capacity (+1/+2)
- First selection always grants 1 capacity
- Updated coal delivery logic in Part 7 to use get_forgiveness_threshold() and get_forgiveness_max_capacity()
- Charges now respect max capacity (won't exceed limit)
- Updated Design Notes section with complete hybrid system documentation
- Updated test criteria to reflect threshold and capacity mechanics
- Updated implementation checklist Phase 6 with hybrid system tests
- Fixed get_quality_multiplier() in Part 6 to include uncommon tier (1.1x)

**Changelog v5.2**:
- **ADDED**: Uncommon rarity tier between Common and Rare (5 total rarities now)
- Added Uncommon quality multiplier: 1.1x (between Common 1.0x and Rare 1.2x)
- Added Uncommon visual indicator: Green border color (0.4, 0.8, 0.4)
- Updated draw quality distribution tables for all 5 rarity tiers
- Updated _draw_quality_for_technique() to include uncommon tier in all match cases
- Updated _apply_quality_styling() to handle uncommon green border
- Updated _get_quality_multiplier() to return 1.1 for uncommon
- Updated technique appearance rarity distribution (40% common, 30% uncommon, 20% rare, 8% epic, 2% legendary)
- Reassigned 4 techniques to uncommon rarity: Economy of Motion, Cadence, Combo Ceiling, Extended Window
- Updated all quality tier tables and examples throughout plan

**Changelog v5.1**:
- **CRITICAL FIX**: Quality now rolled when generating options (not when selecting) - players choose technique+quality combo
- **CRITICAL FIX**: Forgiveness now uses charge system instead of backwards threshold system
- Removed deferred techniques (Pattern Recognition, Flow, Perfect Balance) to eliminate dead code
- Updated _generate_upgrade_options() to return {tech_id, quality} dictionaries
- Updated _display_upgrade_options() to show quality in card title and border color
- Updated _on_upgrade_selected() to receive quality as parameter instead of rolling it
- Renamed _apply_rarity_styling() to _apply_quality_styling() (border color = draw quality, not technique rarity)
- Added _get_quality_multiplier() helper to mind.gd
- Changed forgiveness_coal_count to forgiveness_charges + forgiveness_coal_counter variables
- Updated get_forgiveness_threshold() to get_forgiveness_charges_per_milestone()
- Forgiveness now earns charges every 10 coal (additive with quality scaling)
- Updated all coal delivery/drop logic to use charge system
- Updated all test criteria and checklists to reflect changes
- Technique count: 13 (was 16, removed 3 deferred)

**Changelog v5.0**:
- **MAJOR**: Merged Mind scene UI flow from 2.14-shovelling-level-up.md
- Added Part 4.5: Mind Scene UI and Selection Flow (UI layout, card display, selection logic)
- Added `upgrades_qty` variable for tracking total selections (Mind button visibility)
- Added complete mind.gd implementation (option generation, display, selection handling, quality drawing, styling)
- Removed branch-locking system (was incompatible with single-pool design)
- Updated Files to Create/Modify sections with Mind UI components
- Added Phase 2 to implementation checklist for Mind scene UI
- Renumbered subsequent phases (3-9)
- Plan now self-contained: no references to archived/obsolete plans
