# Apply Upgrade

**Goal**: Implement mechanical effects of techniques selected from the upgrade pool

**Success Criteria**: All technique effects correctly modify gameplay mechanics, combo systems track state properly

## Overview

When a player selects a technique in the Mind scene, the effect must be applied to the actual gameplay mechanics. Each technique modifies specific systems (stamina drain, XP gain, shovel mass) or unlocks/enhances combo mechanics.

**Draw Quality System**: See [2.12-upgrade-pool.md#draw-quality-system](2.12-upgrade-pool.md#draw-quality-system) for how technique selection assigns quality tiers (Common/Rare/Epic/Legendary) that modify base bonuses.

This plan covers core stat techniques and the two combo systems (no-drop and heavy load).

### Key Design Principles

- Percentage bonuses stack additively: `total_mult = 1.0 + sum_of_bonuses`
- Each selection draws a quality that modifies base bonus (see 2.12)
- Helper functions centralized in Level1Vars for maintainability
- Minimum clamps prevent complete elimination of challenge
- Combo systems unlock dynamically when first combo technique is selected

---

## Implementation Tasks

### 1. Data Storage Structure

**Location**: `level_1_vars.gd`

**Variables needed**:
```gdscript
# In level_1_vars.gd
var selected_techniques: Dictionary = {}
# Structure: { technique_id: { level: int, qualities: Array[String] } }

# Combo system flags
var nodrop_combo_unlocked: bool = false
var heavy_combo_unlocked: bool = false

# No-drop combo state
var nodrop_combo_count: int = 0
var nodrop_combo_max: int = 20  # Increased by Combo Ceiling technique
var forgiveness_coal_count: int = 0  # Coal delivered since last forgiveness use

# Heavy load combo state
var heavy_combo_stacks: int = 0
var heavy_combo_timer: float = 0.0  # Counts down from 5.0s + bonuses
var heavy_load_last_delivery_time: float = 0.0  # For detecting 3+ coal in 1 second

signal technique_updated(technique_id: String, new_level: int)
signal nodrop_combo_changed(new_count: int)
signal heavy_combo_changed(new_stacks: int, timer_remaining: float)
```

**Implementation details:**
- Dictionary maps technique_id to level and draw quality history
- Each selection appends a draw_quality to the qualities array
- Signals emit when state changes for UI updates
- Combo systems start locked, unlock on first relevant technique selection

**Functions to add**:
```gdscript
func add_technique(technique_id: String, draw_quality: String) -> void:
    if technique_id not in selected_techniques:
        selected_techniques[technique_id] = {
            "level": 1,
            "qualities": [draw_quality]
        }
    else:
        selected_techniques[technique_id]["level"] += 1
        selected_techniques[technique_id]["qualities"].append(draw_quality)

    # Check if this technique unlocks a combo system
    const TechniquesData = preload("res://data/techniques.gd")
    var tech_data = TechniquesData.TECHNIQUES[technique_id]

    if tech_data.has("unlocks_combo") and tech_data["unlocks_combo"]:
        if tech_data["category"] == "nodrop_combo":
            nodrop_combo_unlocked = true
        elif tech_data["category"] == "heavy_combo":
            heavy_combo_unlocked = true

    emit_signal("technique_updated", technique_id, selected_techniques[technique_id]["level"])

func get_technique_level(technique_id: String) -> int:
    if technique_id not in selected_techniques:
        return 0
    return selected_techniques[technique_id]["level"]

func reset_techniques() -> void:
    selected_techniques.clear()
    nodrop_combo_unlocked = false
    heavy_combo_unlocked = false
    nodrop_combo_count = 0
    nodrop_combo_max = 20
    forgiveness_coal_count = 0
    heavy_combo_stacks = 0
    heavy_combo_timer = 0.0
    heavy_load_last_delivery_time = 0.0
```

---

### 2. Core Stat Techniques

These techniques modify base stats and stack multiplicatively.

#### Rhythm (-25% stamina drain from shovel weight)

**Location**: `shovel.gd` (stamina drain calculation)

**Modified implementation**:
```gdscript
func _physics_process(delta):
    # ...existing code...

    if coal_count >= 1 and is_in_work_zone:
        var base_drain = 0.2 * Level1Vars.get_base_stamina_drain_multiplier()
        var coal_drain = coal_count * 0.1 * Level1Vars.get_coal_stamina_drain_multiplier()
        var total_drain = base_drain + coal_drain
        Level1Vars.modify_stamina(-total_drain * delta)
```

#### Determination (-15% all stamina drain)

Applied via multipliers in both base and coal drain helpers (see section 7).

#### Economy of Motion (-10% stamina drain while holding coal)

Applied via coal drain multiplier helper (see section 7).

#### Pattern Recognition (+1s shake warning time)

**Status**: Deferred until shake warning system designed.

---

### 3. No-Drop Combo System

Tracks consecutive coal deliveries without drops. Combo persists between deliveries until coal is dropped.

**Trigger Logic** (in furnace interaction or coal delivery code):
```gdscript
# When coal is successfully delivered to furnace
func on_coal_delivered(coal_amount: int) -> void:
    if not Level1Vars.nodrop_combo_unlocked:
        return  # System not unlocked yet

    # Increment combo (capped at combo_max)
    Level1Vars.nodrop_combo_count = min(
        Level1Vars.nodrop_combo_count + coal_amount,
        Level1Vars.get_nodrop_combo_max()
    )

    # Track for forgiveness system
    Level1Vars.forgiveness_coal_count += coal_amount

    emit_signal("nodrop_combo_changed", Level1Vars.nodrop_combo_count)

# When coal is dropped
func on_coal_dropped(coal_amount: int) -> void:
    if not Level1Vars.nodrop_combo_unlocked:
        return

    # Check if forgiveness can save the combo
    var forgiveness_threshold = Level1Vars.get_forgiveness_threshold()
    if forgiveness_threshold > 0 and Level1Vars.forgiveness_coal_count >= forgiveness_threshold:
        # Use forgiveness - don't break combo
        Level1Vars.forgiveness_coal_count = 0  # Reset forgiveness counter
        print("Forgiveness saved combo!")
        return

    # No forgiveness available - reset combo
    Level1Vars.nodrop_combo_count = 0
    Level1Vars.forgiveness_coal_count = 0
    emit_signal("nodrop_combo_changed", 0)
```

**Helper Functions** (in Level1Vars):
```gdscript
func get_nodrop_combo_max() -> int:
    var base_max = 20
    if "combo_ceiling" not in selected_techniques:
        return base_max

    # Combo Ceiling adds +10 per selection (scaled by quality)
    var bonus = get_technique_total_bonus("combo_ceiling")
    return base_max + int(bonus)

func get_forgiveness_threshold() -> int:
    if "forgiveness" not in selected_techniques:
        return 0  # No forgiveness

    # Base: 1 forgiveness per 10 coal delivered
    # Returns the threshold at which forgiveness becomes available
    var bonus = get_technique_total_bonus("forgiveness")
    return int(bonus)  # Typically 10, 12, 14, 16 depending on quality
```

---

### 4. Heavy Load Combo System

Tracks burst bonuses for delivering 3+ coal within 1 second. Uses decay timer.

**Trigger Logic** (in furnace interaction):
```gdscript
# When coal is successfully delivered to furnace
func on_coal_delivered(coal_amount: int) -> void:
    if not Level1Vars.heavy_combo_unlocked:
        return

    var current_time = Time.get_ticks_msec() / 1000.0
    var time_since_last = current_time - Level1Vars.heavy_load_last_delivery_time

    # Check if this qualifies as a heavy load (3+ coal in 1 second)
    if coal_amount >= 3 and time_since_last <= 1.0:
        # Increment heavy stacks
        Level1Vars.heavy_combo_stacks += 1

        # Refresh timer
        var base_timer = 5.0
        var timer_bonus = Level1Vars.get_heavy_timer_extension()
        Level1Vars.heavy_combo_timer = base_timer + timer_bonus

        emit_signal("heavy_combo_changed", Level1Vars.heavy_combo_stacks, Level1Vars.heavy_combo_timer)

    Level1Vars.heavy_load_last_delivery_time = current_time

# In _process or _physics_process
func _process(delta):
    if Level1Vars.heavy_combo_unlocked and Level1Vars.heavy_combo_timer > 0.0:
        Level1Vars.heavy_combo_timer -= delta

        if Level1Vars.heavy_combo_timer <= 0.0:
            # Timer expired - reset stacks
            Level1Vars.heavy_combo_stacks = 0
            Level1Vars.heavy_combo_timer = 0.0
            emit_signal("heavy_combo_changed", 0, 0.0)

# When coal is dropped
func on_coal_dropped(coal_amount: int) -> void:
    if not Level1Vars.heavy_combo_unlocked:
        return

    # Dropping coal resets heavy combo
    Level1Vars.heavy_combo_stacks = 0
    Level1Vars.heavy_combo_timer = 0.0
    emit_signal("heavy_combo_changed", 0, 0.0)
```

**Helper Functions** (in Level1Vars):
```gdscript
func get_heavy_timer_extension() -> float:
    if "extended_window" not in selected_techniques:
        return 0.0

    # Extended Window adds +1.0s per selection (scaled by quality)
    return get_technique_total_bonus("extended_window")
```

---

### 5. Combo-Dependent Techniques

These techniques scale with active combo counters.

#### Cadence (-5% stamina drain per combo stack)

**Effect**: Reduces stamina drain based on no-drop combo count.

**Helper Function** (in Level1Vars):
```gdscript
func get_base_stamina_drain_multiplier() -> float:
    var total_reduction = 0.0

    # Rhythm: -25% base drain per selection
    if "rhythm" in selected_techniques:
        total_reduction += get_technique_total_bonus("rhythm")

    # Determination: -15% all stamina drain per selection
    if "determination" in selected_techniques:
        total_reduction += get_technique_total_bonus("determination")

    # Cadence: -5% per combo stack per selection
    if "cadence" in selected_techniques and nodrop_combo_unlocked:
        var cadence_bonus = get_technique_total_bonus("cadence")
        total_reduction += cadence_bonus * nodrop_combo_count

    # Perfect Form: -50% at 10+ combo (boolean)
    if "perfect_form" in selected_techniques and nodrop_combo_count >= 10:
        total_reduction += 0.50

    var mult = 1.0 - total_reduction
    return max(0.1, mult)  # Never reduce below 10% of base
```

#### Repetition Learning (+10% XP per combo stack)

**Effect**: Multiplies XP gain based on no-drop combo count.

**Helper Function** (in Level1Vars):
```gdscript
func get_xp_multiplier() -> float:
    var mult = 1.0

    # Repetition Learning: +10% XP per combo stack per selection
    if "repetition_learning" in selected_techniques and nodrop_combo_unlocked:
        var learning_bonus = get_technique_total_bonus("repetition_learning")
        mult += learning_bonus * nodrop_combo_count

    # Pressure Training: +50% XP per heavy stack per selection
    if "pressure_training" in selected_techniques and heavy_combo_unlocked:
        var pressure_bonus = get_technique_total_bonus("pressure_training")
        mult += pressure_bonus * heavy_combo_stacks

    return mult
```

**Usage** (when awarding XP):
```gdscript
# In furnace delivery or XP award code
var base_xp = 10  # Example base XP
var final_xp = base_xp * Level1Vars.get_xp_multiplier()
Level1Vars.add_experience(final_xp)
```

#### Power Surge (-15% stamina drain per heavy stack)

**Effect**: Temporarily reduces stamina drain based on heavy combo stacks (active while timer is running).

**Helper Function** (in Level1Vars):
```gdscript
func get_coal_stamina_drain_multiplier() -> float:
    var total_reduction = 0.0

    # Economy of Motion: -10% coal carrying drain per selection
    if "economy_of_motion" in selected_techniques:
        total_reduction += get_technique_total_bonus("economy_of_motion")

    # Determination: -15% all stamina drain per selection
    if "determination" in selected_techniques:
        total_reduction += get_technique_total_bonus("determination")

    # Power Surge: -15% per heavy stack per selection (while timer active)
    if "power_surge" in selected_techniques and heavy_combo_unlocked and heavy_combo_timer > 0.0:
        var surge_bonus = get_technique_total_bonus("power_surge")
        total_reduction += surge_bonus * heavy_combo_stacks

    var mult = 1.0 - total_reduction
    return max(0.1, mult)  # Never reduce below 10% of base
```

#### Flow (+0.5 focus regen per combo stack)

**Status**: Deferred until focus system implemented.

#### Perfect Balance (Cannot spill at 5+ heavy stacks)

**Effect**: Prevents coal spills when heavy combo stacks >= 5 and timer is active.

**Helper Function** (in Level1Vars):
```gdscript
func has_perfect_balance_active() -> bool:
    if "perfect_balance" not in selected_techniques:
        return false

    return heavy_combo_unlocked and heavy_combo_stacks >= 5 and heavy_combo_timer > 0.0
```

**Usage** (in coal spill logic):
```gdscript
# In shovel.gd or coal handling code
func check_coal_spill() -> bool:
    if Level1Vars.has_perfect_balance_active():
        return false  # Cannot spill

    # Normal spill logic
    # ...
```

---

### 6. Shovel Mass Techniques

#### Mass Training (+15% shovel mass)

**Location**: `shovel.gd` (mass/inertia calculation)

**Modified implementation**:
```gdscript
# In shovel.gd _ready() or physics setup
func _ready():
    update_shovel_mass()

func update_shovel_mass():
    var base_mass = 10.0  # Example base mass
    var mass_mult = Level1Vars.get_shovel_mass_multiplier()
    mass = base_mass * mass_mult
```

**Helper Function** (in Level1Vars):
```gdscript
func get_shovel_mass_multiplier() -> float:
    var mult = 1.0

    # Mass Training: +15% per selection
    if "mass_training" in selected_techniques:
        mult += get_technique_total_bonus("mass_training")

    # Weighted Mastery: +2% per combo stack per selection
    if "weighted_mastery" in selected_techniques and nodrop_combo_unlocked:
        var weighted_bonus = get_technique_total_bonus("weighted_mastery")
        mult += weighted_bonus * nodrop_combo_count

    return mult
```

**Dynamic Update** (call when combo changes):
```gdscript
# In Level1Vars signal handler or combo update code
func _on_nodrop_combo_changed(new_count: int):
    # If Weighted Mastery is active, update shovel mass dynamically
    if "weighted_mastery" in selected_techniques:
        var shovel = get_tree().get_nodes_in_group("shovel")[0]
        if shovel:
            shovel.update_shovel_mass()
```

---

### 7. Complete Helper Functions

**Add to level_1_vars.gd**:

```gdscript
# ============================================================================
# TECHNIQUE EFFECT HELPERS
# ============================================================================

const TechniquesData = preload("res://data/techniques.gd")
const TECHNIQUES = TechniquesData.TECHNIQUES

# Core calculation function
func get_technique_total_bonus(technique_id: String) -> float:
    if technique_id not in selected_techniques:
        return 0.0

    # Validate technique exists in definition
    if technique_id not in TECHNIQUES:
        push_warning("Unknown technique: " + technique_id)
        return 0.0

    # Handle boolean techniques (like Perfect Form, Perfect Balance)
    var effect_data = TECHNIQUES[technique_id]["effect"]
    if effect_data.has("type") and effect_data["type"] == "boolean":
        return 0.0  # Boolean techniques checked with has_technique(), not bonus calculation

    var base_bonus = effect_data["base_bonus"]
    var qualities = selected_techniques[technique_id]["qualities"]
    var total = 0.0

    for quality in qualities:
        var quality_mult = get_quality_multiplier(quality)
        total += base_bonus * quality_mult

    return total

func get_quality_multiplier(quality: String) -> float:
    match quality:
        "common": return 1.0
        "rare": return 1.2
        "epic": return 1.4
        "legendary": return 1.6
        _:
            push_warning("Unknown quality tier: " + quality)
            return 1.0

# Stamina drain modifiers
func get_base_stamina_drain_multiplier() -> float:
    var total_reduction = 0.0

    # Rhythm: -25% base drain per selection
    if "rhythm" in selected_techniques:
        total_reduction += get_technique_total_bonus("rhythm")

    # Determination: -15% all stamina drain per selection
    if "determination" in selected_techniques:
        total_reduction += get_technique_total_bonus("determination")

    # Cadence: -5% per combo stack per selection
    if "cadence" in selected_techniques and nodrop_combo_unlocked:
        var cadence_bonus = get_technique_total_bonus("cadence")
        total_reduction += cadence_bonus * nodrop_combo_count

    # Perfect Form: -50% at 10+ combo (boolean)
    if "perfect_form" in selected_techniques and nodrop_combo_count >= 10:
        total_reduction += 0.50

    var mult = 1.0 - total_reduction
    return max(0.1, mult)  # Never reduce below 10% of base

func get_coal_stamina_drain_multiplier() -> float:
    var total_reduction = 0.0

    # Economy of Motion: -10% coal carrying drain per selection
    if "economy_of_motion" in selected_techniques:
        total_reduction += get_technique_total_bonus("economy_of_motion")

    # Determination: -15% all stamina drain per selection
    if "determination" in selected_techniques:
        total_reduction += get_technique_total_bonus("determination")

    # Power Surge: -15% per heavy stack per selection (while timer active)
    if "power_surge" in selected_techniques and heavy_combo_unlocked and heavy_combo_timer > 0.0:
        var surge_bonus = get_technique_total_bonus("power_surge")
        total_reduction += surge_bonus * heavy_combo_stacks

    var mult = 1.0 - total_reduction
    return max(0.1, mult)  # Never reduce below 10% of base

# XP multiplier
func get_xp_multiplier() -> float:
    var mult = 1.0

    # Repetition Learning: +10% XP per combo stack per selection
    if "repetition_learning" in selected_techniques and nodrop_combo_unlocked:
        var learning_bonus = get_technique_total_bonus("repetition_learning")
        mult += learning_bonus * nodrop_combo_count

    # Pressure Training: +50% XP per heavy stack per selection
    if "pressure_training" in selected_techniques and heavy_combo_unlocked:
        var pressure_bonus = get_technique_total_bonus("pressure_training")
        mult += pressure_bonus * heavy_combo_stacks

    return mult

# Shovel mass
func get_shovel_mass_multiplier() -> float:
    var mult = 1.0

    # Mass Training: +15% per selection
    if "mass_training" in selected_techniques:
        mult += get_technique_total_bonus("mass_training")

    # Weighted Mastery: +2% per combo stack per selection
    if "weighted_mastery" in selected_techniques and nodrop_combo_unlocked:
        var weighted_bonus = get_technique_total_bonus("weighted_mastery")
        mult += weighted_bonus * nodrop_combo_count

    return mult

# Combo system helpers
func get_nodrop_combo_max() -> int:
    var base_max = 20
    if "combo_ceiling" not in selected_techniques:
        return base_max

    var bonus = get_technique_total_bonus("combo_ceiling")
    return base_max + int(bonus)

func get_forgiveness_threshold() -> int:
    if "forgiveness" not in selected_techniques:
        return 0

    var bonus = get_technique_total_bonus("forgiveness")
    return int(bonus)

func get_heavy_timer_extension() -> float:
    if "extended_window" not in selected_techniques:
        return 0.0

    return get_technique_total_bonus("extended_window")

func has_perfect_balance_active() -> bool:
    if "perfect_balance" not in selected_techniques:
        return false

    return heavy_combo_unlocked and heavy_combo_stacks >= 5 and heavy_combo_timer > 0.0
```

---

## Testing Strategy

### Manual Test Criteria

- [ ] Rhythm reduces base stamina drain (check debug overlay with F3)
- [ ] Economy reduces coal stamina drain (check debug overlay)
- [ ] Determination stacks with both Rhythm AND Economy
- [ ] No-drop combo increments on coal delivery
- [ ] No-drop combo resets on coal drop (unless forgiveness active)
- [ ] Forgiveness saves combo once per threshold
- [ ] Combo Ceiling increases max combo above 20
- [ ] Heavy load combo triggers on 3+ coal in 1 second
- [ ] Heavy combo timer refreshes on each heavy delivery
- [ ] Heavy combo resets on timer expiration or coal drop
- [ ] Cadence reduces stamina based on combo count
- [ ] Repetition Learning increases XP based on combo count
- [ ] Power Surge reduces stamina during heavy timer
- [ ] Pressure Training increases XP during heavy timer
- [ ] Perfect Form activates at 10+ combo
- [ ] Perfect Balance prevents spills at 5+ heavy stacks
- [ ] Mass Training increases shovel mass
- [ ] Weighted Mastery dynamically scales mass with combo
- [ ] Extended Window lengthens heavy timer
- [ ] All combo signals emit correctly for UI updates

---

## Files to Create

None (all changes are modifications to existing files)

## Files to Modify

- `level_1_vars.gd` - Add selected_techniques dictionary, combo state variables, all helper functions, signals
- `shovel.gd` - Modify stamina drain to query drain multipliers, add mass update function
- `furnace.gd` (or coal delivery handler) - Add combo tracking logic (on_coal_delivered, on_coal_dropped)
- `data/techniques.gd` - Already created in 2.12-upgrade-pool.md

---

## Notes & Decisions

**Decision 1**: Combo systems unlock dynamically
- **Rationale**: Players can ignore combo mechanics entirely if they prefer simpler stat upgrades. Unlocking on first technique selection creates "aha!" moment.
- **Alternatives**: Both combos always active (clutters UI for players not using them), separate unlock items (adds complexity)

**Decision 2**: No-drop combo persists indefinitely until broken
- **Rationale**: Rewards long-term consistency, creates high-stakes moments. Forgiveness system adds flexibility.
- **Alternatives**: Time-based decay (punishes slow play), reset on delivery (no persistence), cap at lower value (less satisfying)

**Decision 3**: Heavy load uses decay timer (5s base)
- **Rationale**: Creates distinct rhythm from no-drop combo. Time pressure encourages aggressive burst play.
- **Alternatives**: Persistent stacks (no urgency), instant bursts only (no stacking depth), shorter timer (too punishing)

**Decision 4**: Combo effects stack multiplicatively with technique level
- **Rationale**: Higher combo + higher technique level = exponential power, but requires both investment and skill.
- **Alternatives**: Additive only (less exciting scaling), combo replaces technique level (removes upgrade choice)

**Open Questions**:
- [ ] Should combos carry between runs (persistent progression)?
- [ ] Should there be visual feedback for combo milestones (10, 20, 30+)?
- [ ] Should heavy load threshold be upgradeable (reduce from 3 coal to 2)?

---

## Implementation Checklist

- [ ] Add selected_techniques dictionary to Level1Vars
- [ ] Add combo system variables to Level1Vars
- [ ] Add technique_updated signal to Level1Vars
- [ ] Add combo-related signals to Level1Vars
- [ ] Implement add_technique() function with combo unlocking
- [ ] Implement get_technique_level() function
- [ ] Implement reset_techniques() function with combo reset
- [ ] Implement get_technique_total_bonus() helper
- [ ] Implement get_quality_multiplier() helper
- [ ] Implement get_base_stamina_drain_multiplier() helper
- [ ] Implement get_coal_stamina_drain_multiplier() helper
- [ ] Implement get_xp_multiplier() helper
- [ ] Implement get_shovel_mass_multiplier() helper
- [ ] Implement combo system helpers (max, forgiveness, timer, etc.)
- [ ] Modify shovel.gd stamina drain to use drain multipliers
- [ ] Add shovel.gd mass update function
- [ ] Add furnace.gd combo tracking (on_coal_delivered)
- [ ] Add furnace.gd combo reset (on_coal_dropped)
- [ ] Add heavy combo timer countdown in _process
- [ ] Test Rhythm technique (base drain reduction)
- [ ] Test Economy technique (coal drain reduction)
- [ ] Test Determination technique (all drain reduction)
- [ ] Test no-drop combo increments correctly
- [ ] Test no-drop combo resets on drop
- [ ] Test forgiveness system saves combo
- [ ] Test Combo Ceiling increases max
- [ ] Test heavy load combo triggers on 3+ coal
- [ ] Test heavy combo timer refresh
- [ ] Test heavy combo timer expiration
- [ ] Test Cadence scales with combo
- [ ] Test Repetition Learning scales XP with combo
- [ ] Test Power Surge scales with heavy stacks
- [ ] Test Pressure Training scales XP with heavy stacks
- [ ] Test Perfect Form activates at 10+ combo
- [ ] Test Perfect Balance prevents spills at 5+ heavy
- [ ] Test Mass Training increases shovel mass
- [ ] Test Weighted Mastery scales mass dynamically
- [ ] Test Extended Window lengthens timer
- [ ] Verify all signals fire correctly
- [ ] Test run reset clears all state

---

**Last Updated**: 2025-12-28
**Status**: Ready for Implementation
**Version**: 3.0 (Removed automation mechanics, added combo systems, removed torque upgrades, added mass mechanics)
