# Stamina Drain System

**Goal**: Implement stamina drain mechanic that rewards speed and efficient coal loading while punishing wasteful single-piece carries

**Success Criteria**:
- Stamina drains continuously when shovel carries coal in the work zone (right 2/3 of playfield)
- Drain rate = base_rate + (coal_count × per_coal_rate)
- Drain updates in real-time as coal is dropped or added
- Empty shovel or being in safe zone (left 1/3) = no drain
- Player can complete ~25 delivery batches averaging 3 coal each with 50 starting stamina
- Stamina bar in furnace scene updates in real-time
- No visual marker for work zone boundary

## Overview

This creates a risk-reward economy for the shoveling mechanic:
- **Carrying 1-2 coal is inefficient**: Base shovel weight penalty makes small loads wasteful
- **Carrying 3+ coal is optimal**: Amortizes base cost across more pieces
- **Carrying 5+ coal is risky but efficient**: Better stamina economy, but higher drop risk from tilt/balance
- **Speed is rewarded**: Less time in work zone = less total drain regardless of load size
- **Standing still is punished**: Drain continues even when not moving (no stalling strategies)

**Dependencies**:
- Requires [2.3-physics-objects.md](2.3-physics-objects.md) for shovel and playarea setup
- Requires [2.4-coal-physics-spawning.md](2.4-coal-physics-spawning.md) for coal pieces (RigidBody2D on collision layer 3)
- Requires [2.x-furnace-bars.md](2.x-furnace-bars.md) for stamina bar display
- Modifies `level1/furnace.gd` and `level1/shovel.gd`
- Uses `level_1_vars.gd` for stamina modification and drain rate variables
- **Coal lifecycle** (freed/removed) is handled by [2.11-dropped-delivered-coal.md](2.11-dropped-delivered-coal.md)
- **Stamina depletion consequence** (what happens at 0 stamina) is handled by [2.10-day-end.md](2.10-day-end.md)

---

## Playarea Reference

From [2.3-physics-objects.md](2.3-physics-objects.md):

**Playarea node**:
- Type: Control node
- Path: `$AspectContainer/MainContainer/mainarea/PlayArea`
- Part of responsive layout system ([1.10-responsive-layout.md](../1/1.10-responsive-layout.md))
- Has `.size` property for dimensions
- Has `.get_global_rect()` method for global positioning

**Usage in this plan**:
```gdscript
var playarea: Control = $AspectContainer/MainContainer/mainarea/PlayArea

# Get playarea boundaries
var playarea_rect = playarea.get_global_rect()
var work_zone_boundary_x = playarea_rect.position.x + (playarea_rect.size.x / 3.0)
```

---

## Implementation Tasks

### 1. Add Coal Counting to Shovel

Track how many coal pieces are currently on the shovel surface.

Coal pieces come from [2.4-coal-physics-spawning.md](2.4-coal-physics-spawning.md):
- RigidBody2D on collision_layer = 3 (binary: 4)
- CircleShape2D collision with radius from Level1Vars.coal_radius
- Spawned automatically from coal tap into container

**In shovel.gd:**

Add variables for coal tracking:
```gdscript
# Coal detection shape dimensions (defined in plan 2.3-physics-objects.md)
const COAL_DETECTION_WIDTH: float = 80.0  # Example value, see plan 2.3
const COAL_DETECTION_HEIGHT: float = 20.0  # Example value, see plan 2.3

# Coal tracking
var coal_on_shovel: int = 0
var coal_bodies_on_shovel: Array[RigidBody2D] = []
```

Add Area2D detection setup in _ready():
```gdscript
func _ready():
	# ... (existing setup code)

	# Setup coal detection area
	setup_coal_detection()

func setup_coal_detection():
	# Create Area2D to detect coal pieces
	var detection_area = Area2D.new()
	detection_area.name = "CoalDetectionArea"
	add_child(detection_area)

	# Set collision layers: detect layer 3 (coal)
	detection_area.collision_layer = 0
	detection_area.collision_mask = 4  # Layer 3 (coal pieces)

	# Create CollisionShape2D matching shovel bowl
	# Shape dimensions should be defined in plan 2.3-physics-objects.md
	var collision_shape = CollisionShape2D.new()
	var rect_shape = RectangleShape2D.new()
	rect_shape.size = Vector2(COAL_DETECTION_WIDTH, COAL_DETECTION_HEIGHT)
	collision_shape.shape = rect_shape
	collision_shape.position = Vector2(0, 0)  # Center on shovel
	detection_area.add_child(collision_shape)

	# Connect signals
	detection_area.body_entered.connect(_on_coal_entered)
	detection_area.body_exited.connect(_on_coal_exited)

func _on_coal_entered(body: Node2D):
	if body is RigidBody2D and body.collision_layer & 4:  # Verify it's coal (layer 3)
		if body not in coal_bodies_on_shovel:
			coal_bodies_on_shovel.append(body)
			coal_on_shovel = coal_bodies_on_shovel.size()

func _on_coal_exited(body: Node2D):
	if body in coal_bodies_on_shovel:
		coal_bodies_on_shovel.erase(body)
		coal_on_shovel = coal_bodies_on_shovel.size()

func clean_invalid_coal_references():
	# Remove dangling references to freed coal pieces
	# Called by 2.11-dropped-delivered-coal.md when coal is freed/delivered
	# NOT called every frame - only when coal lifecycle events occur
	coal_bodies_on_shovel = coal_bodies_on_shovel.filter(func(body): return is_instance_valid(body))
	coal_on_shovel = coal_bodies_on_shovel.size()
```

**Note:** `clean_invalid_coal_references()` is exposed as a public function for [2.11-dropped-delivered-coal.md](2.11-dropped-delivered-coal.md) to call when freeing coal. It should NOT be called every frame.

**Why Area2D instead of contact tracking:**
- Simpler and more reliable than tracking collision_shape contacts
- Automatically handles coal entering/exiting shovel bowl
- Prevents double-counting same coal piece
- Collision layers ensure only coal pieces are counted

---

### 2. Add Work Zone Detection

Determine if shovel is in the work zone (right 2/3 of playfield).

**In shovel.gd:**

Add work zone tracking variables:
```gdscript
var in_work_zone: bool = false
var work_zone_boundary_x: float = 0.0
```

Add boundary calculation in _ready():
```gdscript
func _ready():
	# ... (existing setup code)

	# Calculate initial work zone boundary
	calculate_work_zone_boundary()

	# Recalculate boundary when viewport resizes
	get_viewport().size_changed.connect(_on_viewport_size_changed)

func calculate_work_zone_boundary():
	if playarea:
		var playarea_rect = playarea.get_global_rect()
		work_zone_boundary_x = playarea_rect.position.x + (playarea_rect.size.x / 3.0)

func _on_viewport_size_changed():
	# Recalculate boundary when window is resized
	calculate_work_zone_boundary()
```

Add work zone check in _physics_process(delta):
```gdscript
func _physics_process(delta):
	# ... (existing mouse following code)

	# Update work zone status (use cached boundary)
	in_work_zone = global_position.x > work_zone_boundary_x

	# Calculate and apply stamina drain
	update_stamina_drain(delta)
```

**Design decision: Why right 2/3?**
- Coal pile is in bottom-left (safe zone)
- Furnace is on far right (work zone)
- Gives player small safe area to load coal without pressure
- Most of the travel distance is under stamina drain (creates tension)
- No visual marker keeps UI clean, player learns boundary through feedback

**Why cache boundary instead of calculating every frame?**
- Window resizes are rare events, no need to recalculate constantly
- Eliminates unnecessary division and get_global_rect() calls every frame
- Resize signal ensures boundary stays correct
- More efficient, cleaner code

---

### 3. Update Stamina to Float and Add Drain Variables

**In level_1_vars.gd:**

Change stamina from int to float:
```gdscript
# Stamina (changed from int to float for smooth drain)
var stamina: float = 50.0
var stamina_max: float = 50.0
```

Update modify_stamina to work with float:
```gdscript
func modify_stamina(amount: float) -> bool:
	stamina = clampf(stamina + amount, 0.0, stamina_max)
	emit_signal("stamina_changed", stamina, stamina_max)
	return true
```

Add drain rate variables after existing stamina variables:
```gdscript
# Stamina drain rates (stamina per second)
var stamina_drain_base: float = 0.2  # Base drain for shovel weight
var stamina_drain_per_coal: float = 0.1  # Additional drain per coal piece
```

**Why float instead of int?**
- No accumulator needed - directly subtract `drain_rate * delta`
- Simpler code, fewer state variables, no precision loss
- Drain feels smooth at all framerates

**Why these drain values?**
- Target: 25 deliveries × 3 coal avg × 4 seconds = 100 seconds carrying time
- 50 stamina / 100 seconds = 0.5 stamina/second average
- For 3 coal: 0.2 base + (3 × 0.1) = 0.5 stamina/second ✓
- See "Balance Tuning" section for efficiency breakdown

---

### 4. Implement Stamina Drain Logic

**In shovel.gd:**

Add drain rate caching variables:
```gdscript
# Drain rate caching (recalculate only when coal count changes for 300ms)
var cached_drain_rate: float = 0.0
var pending_coal_count: int = 0
var coal_change_timer: float = 0.0
const COAL_CHANGE_DEBOUNCE: float = 0.3  # 300ms
```

Add stamina drain calculation in _physics_process(delta):
```gdscript
func _physics_process(delta):
	# ... (existing mouse following and work zone check)

	# Update drain rate cache when coal count changes
	update_drain_rate_cache(delta)

	# Calculate and apply stamina drain
	update_stamina_drain(delta)

func update_drain_rate_cache(delta: float):
	# Debounce coal count changes to prevent jitter
	if coal_on_shovel != pending_coal_count:
		# Coal count changed, reset timer
		pending_coal_count = coal_on_shovel
		coal_change_timer = 0.0
	else:
		# Coal count stable, increment timer
		coal_change_timer += delta

	# Recalculate drain rate if change persists for 300ms
	if coal_change_timer >= COAL_CHANGE_DEBOUNCE:
		cached_drain_rate = Level1Vars.stamina_drain_base + (coal_on_shovel * Level1Vars.stamina_drain_per_coal)

func update_stamina_drain(delta: float):
	# Early exit if no coal on shovel
	if coal_on_shovel == 0:
		cached_drain_rate = 0.0
		return

	# Check drain condition: has coal AND in work zone
	var should_drain = in_work_zone

	if should_drain:
		# Apply drain using cached rate (stamina is now float)
		Level1Vars.modify_stamina(-cached_drain_rate * delta)
```

**Implementation notes:**
- `cached_drain_rate` is stamina per second, recalculated only when coal count is stable for 300ms
- Debouncing prevents drain rate jitter when coal briefly enters/exits detection area
- Multiply cached rate by `delta` to get fractional drain for this frame
- No accumulator needed - stamina is float, direct subtraction works
- `modify_stamina()` clamps to [0, max] and emits signals
- Early exit when no coal improves performance and resets cached rate

**Why cache drain rate with debounce?**
- Prevents recalculation every frame (only when coal count actually changes)
- 300ms debounce smooths out physics jitter when coal bounces on shovel edge
- Cleaner performance profile, easier to debug
- Still responsive enough for player feedback

---

### 5. Add Debug Visualization (Optional)

Add optional debug overlay to show drain state.

**In shovel.gd:**

Add debug toggle and visualization:
```gdscript
# Debug settings (toggle manually via input or debug menu - not automatic)
var show_debug_overlay: bool = false

func _ready():
	# ... (existing setup)

	# No automatic debug overlay - must be enabled manually

func _input(event):
	# Toggle debug overlay with F3 key
	if event is InputEventKey and event.pressed and event.keycode == KEY_F3:
		show_debug_overlay = !show_debug_overlay

func _physics_process(delta):
	# ... (existing code)

	# Queue redraw for debug overlay
	if show_debug_overlay:
		queue_redraw()

func _draw():
	if not show_debug_overlay:
		return

	# Draw coal count and drain rate
	var debug_text = "Coal: %d" % coal_on_shovel
	if cached_drain_rate > 0.0:
		debug_text += " | Drain: %.2f/s" % cached_drain_rate

	# Draw text above shovel using Godot 4 TextLine API
	var text_line = TextLine.new()
	text_line.add_string(debug_text, ThemeDB.fallback_font, 12)
	text_line.draw(get_canvas_item(), Vector2(-20, -30), Color.RED)
```

**Debug visualization shows:**
- Coal count on shovel
- Current drain rate when draining
- Text appears above shovel, moves with it
- Toggle with F3 key (manual control, not automatic)

**Note:** Debug overlay is optional - remove if visual clutter is a problem. Players should learn mechanics through stamina bar feedback.

---

## Testing Notes

**Key behaviors to verify:**
- Coal counting tracks correctly (enter/exit shovel Area2D)
- Coal detection shape uses constants from plan 2.3 (COAL_DETECTION_WIDTH, COAL_DETECTION_HEIGHT)
- Work zone boundary cached at 1/3 playarea width, recalculated on resize
- Work zone separates safe zone (left) from work zone (right)
- Drain only occurs when coal_on_shovel >= 1 AND in_work_zone
- Drain rate cached and only recalculated when coal count stable for 300ms (debounce prevents jitter)
- Drain rate = base (0.2) + (coal_count × 0.1) stamina per second
- Stamina bar updates smoothly with direct float subtraction using cached drain rate
- modify_stamina() clamps to [0, max]
- clean_invalid_coal_references() called by plan 2.11 when coal is freed (not every frame)
- Debug overlay toggles with F3 key and shows cached_drain_rate (manual, not automatic)

**Target performance:**
- 25 deliveries × 3 coal avg = 75 coal delivered with 50 starting stamina
- 4 second delivery time at 0.5 stamina/sec drain rate (3 coal)

---

## Balance Tuning

### Current Design Values

```gdscript
stamina_drain_base = 0.2  # Stamina per second (shovel weight penalty)
stamina_drain_per_coal = 0.1  # Additional stamina per second per coal piece
stamina_max = 50  # Starting stamina (upgradable)
```

### Efficiency Breakdown (4 second delivery time)

| Coal Count | Drain Rate | Total Drain | Stamina/Coal | Verdict |
|------------|------------|-------------|--------------|---------|
| 1 coal | 0.3/sec | 1.2 | 1.20 | ✗ Very inefficient |
| 2 coal | 0.4/sec | 1.6 | 0.80 | ⚠️ Poor |
| 3 coal | 0.5/sec | 2.0 | 0.67 | ✓ Balanced target |
| 4 coal | 0.6/sec | 2.4 | 0.60 | ✓ Good |
| 5 coal | 0.7/sec | 2.8 | 0.56 | ✓✓ Efficient (risky) |
| 6 coal | 0.8/sec | 3.2 | 0.53 | ✓✓ Very efficient (very risky) |

**Key insight:** Base cost (0.2) creates ~40% overhead for 1 coal, but only ~7% overhead for 6 coal. This strongly incentivizes larger loads.

### Speed Impact (3 coal load)

| Delivery Time | Total Drain | Total Deliveries | Total Coal Delivered |
|---------------|-------------|------------------|----------------------|
| 2 sec (fast) | 1.0 | 50 | 150 coal ✓✓✓ |
| 3 sec (quick) | 1.5 | 33 | 99 coal ✓✓ |
| 4 sec (normal) | 2.0 | 25 | 75 coal ✓ (target) |
| 6 sec (slow) | 3.0 | 16 | 48 coal ⚠️ |
| 8 sec (very slow) | 4.0 | 12 | 36 coal ✗ |

**Speed is king:** Halving delivery time DOUBLES total coal output.

### Tuning Knobs for Future Balancing

If playtesting reveals issues, adjust these variables in Level1Vars:

**Problem: Stamina drains too fast, runs end too quickly**
- Decrease `stamina_drain_base` (0.15 instead of 0.2)
- Decrease `stamina_drain_per_coal` (0.08 instead of 0.1)
- Increase `stamina_max` starting value (75 instead of 50)

**Problem: No incentive to carry more coal (1-coal spam is optimal)**
- Increase `stamina_drain_base` (0.3 instead of 0.2) - punish small loads harder
- Decrease `stamina_drain_per_coal` (0.05 instead of 0.1) - reduce penalty for large loads

**Problem: Players just rush and ignore coal count**
- Increase `stamina_drain_per_coal` (0.15 instead of 0.1) - punish overloading
- Make tilt mechanic harder with more coal (separate plan, not stamina-related)

**Problem: Work zone boundary feels wrong (too early/late)**
- Adjust boundary calculation: `playarea_width / 2.0` for 50% split
- Or make it a Level1Vars variable: `work_zone_boundary_percent = 0.33`

### Expected Upgrade Path (Future Plans)

Players should be able to upgrade:
1. `stamina_max`: 50 → 75 → 100 → 150 (more deliveries per run)
2. `stamina_drain_base`: 0.2 → 0.15 → 0.1 → 0.05 (reduce shovel weight penalty)
3. `stamina_drain_per_coal`: 0.1 → 0.08 → 0.06 → 0.04 (carry more coal efficiently)
4. Work zone boundary: 33% → 40% → 50% (larger safe zone)

---

## Files to Create

None - all changes are additions to existing files

## Files to Modify

- [shovel.gd](../../game/v0.1/level1/shovel.gd) - Add coal counting, work zone detection, stamina drain calculation with cached drain rate, optional debug visualization
- [level_1_vars.gd](../../game/v0.1/level1/level_1_vars.gd) - Change stamina to float, add drain rate variables
- **Note**: Shovel coal detection shape uses constants (COAL_DETECTION_WIDTH, COAL_DETECTION_HEIGHT) that should be defined in plan 2.3-physics-objects.md

---

## Design Values (Reference)

### Stamina Drain Rates

- **Base drain**: 0.2 stamina/second (shovel weight tax)
- **Per-coal drain**: 0.1 stamina/second per coal piece
- **Work zone**: Right 2/3 of playfield (boundary at playarea_width / 3)
- **Safe zone**: Left 1/3 of playfield (near coal pile)

### Target Performance

- **Starting stamina**: 50
- **Average deliveries**: 25 batches
- **Average coal per batch**: 3 pieces
- **Average delivery time**: 4 seconds
- **Total coal delivered**: ~75 pieces per run

### Formulas

- **Drain rate**: `base_drain + (coal_count × per_coal_drain)` stamina/second
- **Frame drain**: `drain_rate × delta` stamina/frame (direct float subtraction)
- **Work zone check**: `shovel.global_position.x > work_zone_boundary_x` (cached boundary from playarea)
- **Drain condition**: `(coal_on_shovel >= 1) AND (in_work_zone)`

---

## Notes & Decisions

### Why base drain + per-coal scaling?

**Base drain (0.2/sec) creates "shovel weight tax":**
- Punishes carrying shovel with only 1 coal (inefficient)
- Makes empty shovel safe (can retreat to reload without penalty)
- Provides fixed cost that gets amortized across more coal pieces

**Per-coal drain (0.1/sec each) creates risk/reward:**
- More coal = faster drain, but more efficient per piece
- Ties into existing tilt mechanic: more coal = harder to balance
- Creates decision: safe 2-coal vs risky 5-coal

**Combined effect:**
- 1 coal: 70% overhead (base 0.2 / total 0.3)
- 3 coal: 40% overhead (base 0.2 / total 0.5)
- 5 coal: 28% overhead (base 0.2 / total 0.7)

This creates strong incentive to load 3+ coal without making 1-coal literally unplayable.

### Why right 2/3 work zone instead of heat-based or furnace proximity?

**Spatial work zone advantages:**
- Simple to implement (single X-coordinate check)
- No visual clutter (no heat shimmer effects needed)
- Clear binary state (in/out) - easier to understand than gradient
- Player learns boundary through stamina bar feedback
- Gives safe loading area in bottom-left near coal pile

**Why not heat-based drain near furnace?**
- Furnace is required destination - forced punishment, no choice
- Doesn't reward speed (heat would punish you MORE for being near goal)
- Positional drain feels arbitrary ("why does standing here drain stamina?")

**Why not drain on scoop action?**
- Player moves shovel through coal bin to collect desired amount
- No clear "scoop moment" to trigger drain
- Would punish exploration/positioning instead of commitment

### Why continuous drain instead of snapshot at checkpoint?

**Continuous tracking creates more skill expression:**
- Drop coal mid-delivery → drain decreases immediately
- Player can make tactical decisions: "drop 1 to save stamina"
- Rewards precision: fewer accidental drops = better efficiency
- Ties into existing drop penalties (separate mechanic)

**Snapshot would be simpler but less dynamic:**
- Lock drain rate when crossing boundary, ignore future changes
- Less player agency during delivery
- Doesn't reward careful balance/tilt management

### Why no visual marker for work zone boundary?

**Clean UI philosophy:**
- Stamina bar provides all feedback needed
- Player learns boundary organically: "stamina started draining here"
- No line/marker to clutter playfield
- Keeps visual focus on coal and shovel

**If playtesting shows confusion:**
- Add subtle floor color change at boundary
- Or temporary tutorial hint: "Entering work zone" first few runs
- Or particle effect when crossing boundary
- But start without visual marker - trust player learning

### Why drain continues when standing still?

**Prevents stalling strategies:**
- Player can't "rest" mid-delivery to regenerate stamina (no regen mechanic)
- Encourages decisive action: commit to delivery or retreat
- Creates time pressure without explicit timer
- Rewards fast, confident play over hesitant creeping

**Alternative would allow planning:**
- Player could pause mid-delivery to line up shot
- Feels less dynamic, more "puzzle-like" than action-oriented
- Not necessarily bad, but less aligned with "speed is rewarded" design goal

---

## Common Issues & Prevention

### Issue: Coal count is wrong (too high, too low, or fluctuating)

**Cause:** Area2D detecting non-coal objects, missing exited signals, or dangling references
- Check collision layers: Area2D mask = 4 (layer 3), coal layer = 4 (binary)
- Verify coal RigidBody2D has `collision_layer = 4` set
- Coal pieces freed without triggering `body_exited` leave dangling references

**Solution:** Already handled in this plan:
- Layer validation in `_on_coal_entered/exited`: `if body is RigidBody2D and body.collision_layer & 4`
- `clean_invalid_coal_references()` called when coal is freed ([2.11-dropped-delivered-coal.md](2.11-dropped-delivered-coal.md))
- Uses `is_instance_valid()` to detect dangling references

### Issue: Work zone boundary wrong after window resize

**Cause:** Boundary not recalculating when playarea size changes

**Solution:** Already handled - boundary cached and updated on resize:
```gdscript
func _on_viewport_size_changed():
	calculate_work_zone_boundary()
```
- Cached boundary updated via viewport size_changed signal
- Eliminates per-frame recalculation overhead
- Always stays correct on resize

### Issue: Stamina drains when shovel is empty in work zone

**Cause:** Missing early exit check for zero coal

**Solution:** Already handled in this plan:
```gdscript
if coal_on_shovel == 0:
	return  # Early exit
```

### Issue: Stamina goes negative

**Cause:** `modify_stamina()` not clamping properly

**Solution:** Use `clampf()` for float stamina:
```gdscript
func modify_stamina(amount: float) -> bool:
	stamina = clampf(stamina + amount, 0.0, stamina_max)
	emit_signal("stamina_changed", stamina, stamina_max)
	return true
```

---

## Implementation Checklist

**Code implementation:**
- [ ] Stamina changed from int to float in level_1_vars.gd
- [ ] `modify_stamina()` updated to use `clampf()` with float parameters
- [ ] Coal tracking variables added to shovel.gd
- [ ] Area2D coal detection setup in shovel.gd with shape from plan 2.3
- [ ] `_on_coal_entered()` and `_on_coal_exited()` handlers implemented
- [ ] `clean_invalid_coal_references()` function implemented (called by plan 2.11, not every frame)
- [ ] Work zone boundary cached and calculated in `_ready()`
- [ ] Work zone boundary recalculated on viewport resize via signal
- [ ] Work zone status updated in `_physics_process()` using cached boundary
- [ ] Drain rate variables added to level_1_vars.gd
- [ ] Drain rate caching variables added to shovel.gd (cached_drain_rate, pending_coal_count, coal_change_timer)
- [ ] `update_drain_rate_cache()` function implemented with 300ms debounce
- [ ] `update_stamina_drain()` function implemented with early exit using cached drain rate
- [ ] Drain calculation uses direct float subtraction (no accumulator, no ceil())
- [ ] (Optional) Debug visualization in shovel.gd with F3 toggle using Godot 4 TextLine API

---

**Last Updated**: 2025-12-16
**Status**: Ready for implementation
