# Stamina Drain System

**Goal**: Implement stamina drain mechanic that rewards speed and efficient coal loading while punishing wasteful single-piece carries

**Success Criteria**:
- Stamina drains continuously when shovel carries coal in the work zone (right 2/3 of playfield)
- Drain rate = base_rate + (coal_count × per_coal_rate)
- Drain updates in real-time as coal is dropped or added
- Empty shovel or being in safe zone (left 1/3) = no drain
- Player can complete ~25 delivery batches averaging 3 coal each with 50 starting stamina
- Stamina bar in furnace scene updates in real-time
- No visual marker for work zone boundary

## Overview

This creates a risk-reward economy for the shoveling mechanic:
- **Carrying 1-2 coal is inefficient**: Base shovel weight penalty makes small loads wasteful
- **Carrying 3+ coal is optimal**: Amortizes base cost across more pieces
- **Carrying 5+ coal is risky but efficient**: Better stamina economy, but higher drop risk from tilt/balance
- **Speed is rewarded**: Less time in work zone = less total drain regardless of load size
- **Standing still is punished**: Drain continues even when not moving (no stalling strategies)

**Dependencies**:
- Requires [2.x-physics-objects.md](2.x-physics-objects.md) for shovel and playarea setup
- Requires [2.x-furnace-bars.md](2.x-furnace-bars.md) for stamina bar display
- Requires coal spawning/tracking system (not yet implemented - assume coal pieces are RigidBody2D on collision layer 3)
- Modifies `level1/furnace.gd` and `level1/shovel.gd`
- Uses `level_1_vars.gd` for stamina modification and drain rate variables

---

## Implementation Tasks

### 1. Add Coal Counting to Shovel

Track how many coal pieces are currently on the shovel surface.

**In shovel.gd:**

Add variables for coal tracking:
```gdscript
# Coal tracking
var coal_on_shovel: int = 0
var coal_bodies_on_shovel: Array[RigidBody2D] = []
```

Add Area2D detection setup in _ready():
```gdscript
func _ready():
	# ... (existing setup code)

	# Setup coal detection area
	setup_coal_detection()

func setup_coal_detection():
	# Create Area2D to detect coal pieces
	var detection_area = Area2D.new()
	detection_area.name = "CoalDetectionArea"
	add_child(detection_area)

	# Set collision layers: detect layer 3 (coal)
	detection_area.collision_layer = 0
	detection_area.collision_mask = 4  # Layer 3 (coal pieces)

	# Create CollisionShape2D matching shovel bowl
	var collision_shape = CollisionShape2D.new()
	var rect_shape = RectangleShape2D.new()
	rect_shape.size = Vector2(SHOVEL_WIDTH, 20)  # Cover shovel bowl area
	collision_shape.shape = rect_shape
	collision_shape.position = Vector2(0, 0)  # Center on shovel
	detection_area.add_child(collision_shape)

	# Connect signals
	detection_area.body_entered.connect(_on_coal_entered)
	detection_area.body_exited.connect(_on_coal_exited)

func _on_coal_entered(body: Node2D):
	if body is RigidBody2D and body.collision_layer & 4:  # Verify it's coal (layer 3)
		if body not in coal_bodies_on_shovel:
			coal_bodies_on_shovel.append(body)
			coal_on_shovel = coal_bodies_on_shovel.size()

func _on_coal_exited(body: Node2D):
	if body in coal_bodies_on_shovel:
		coal_bodies_on_shovel.erase(body)
		coal_on_shovel = coal_bodies_on_shovel.size()
```

**Why Area2D instead of contact tracking:**
- Simpler and more reliable than tracking collision_shape contacts
- Automatically handles coal entering/exiting shovel bowl
- Prevents double-counting same coal piece
- Collision layers ensure only coal pieces are counted

---

### 2. Add Work Zone Detection

Determine if shovel is in the work zone (right 2/3 of playfield).

**In shovel.gd:**

Add work zone tracking variable:
```gdscript
var in_work_zone: bool = false
var work_zone_boundary_x: float = 0.0
```

Add work zone calculation in _ready() after playarea reference is set:
```gdscript
func _ready():
	# Get reference to playarea (parent's parent)
	playarea = get_parent().get_parent()

	# ... (existing setup)

	# Wait for layout to be applied
	await get_tree().process_frame

	# Calculate initial work zone boundary
	_recalculate_work_zone_boundary()

	# Recalculate on viewport resize (responsive layout changes)
	get_viewport().size_changed.connect(_recalculate_work_zone_boundary)

func _recalculate_work_zone_boundary():
	# Calculate work zone boundary (left 1/3 is safe, right 2/3 is work zone)
	if playarea:
		var playarea_rect = playarea.get_global_rect()
		work_zone_boundary_x = playarea_rect.position.x + (playarea_rect.size.x / 3.0)
```

Add work zone check in _physics_process(delta):
```gdscript
func _physics_process(delta):
	# ... (existing mouse following code)

	# Update work zone status
	in_work_zone = global_position.x > work_zone_boundary_x
```

**Design decision: Why right 2/3?**
- Coal pile is in bottom-left (safe zone)
- Furnace is on far right (work zone)
- Gives player small safe area to load coal without pressure
- Most of the travel distance is under stamina drain (creates tension)
- No visual marker keeps UI clean, player learns boundary through feedback

---

### 3. Add Stamina Drain Variables to Level1Vars

**In level_1_vars.gd:**

Add drain rate variables after existing stamina variables:
```gdscript
# Stamina drain rates (stamina per second)
var stamina_drain_base: float = 0.2  # Base drain for shovel weight
var stamina_drain_per_coal: float = 0.1  # Additional drain per coal piece

# Stamina drain state (runtime tracking)
var is_draining_stamina: bool = false
var current_drain_rate: float = 0.0
var accumulated_stamina_drain: float = 0.0  # Fractional drain accumulator
```

**Why these values?**
- Target: 25 deliveries × 3 coal avg × 4 seconds = 100 seconds carrying time
- 50 stamina / 100 seconds = 0.5 stamina/second average
- For 3 coal: 0.2 base + (3 × 0.1) = 0.5 stamina/second ✓
- See "Balance Tuning" section for efficiency breakdown

---

### 4. Implement Stamina Drain Logic

**In shovel.gd:**

Add stamina drain calculation in _physics_process(delta):
```gdscript
func _physics_process(delta):
	# ... (existing mouse following and work zone check)

	# Calculate and apply stamina drain
	update_stamina_drain(delta)

func update_stamina_drain(delta: float):
	# Check drain condition: has coal AND in work zone
	var should_drain = (coal_on_shovel >= 1) and in_work_zone

	if should_drain:
		# Calculate drain rate based on current coal count
		var drain_rate = Level1Vars.stamina_drain_base + (coal_on_shovel * Level1Vars.stamina_drain_per_coal)

		# Accumulate fractional drain (prevents rounding errors at high framerates)
		Level1Vars.accumulated_stamina_drain += drain_rate * delta

		# Apply integer drain when accumulated >= 1.0
		if Level1Vars.accumulated_stamina_drain >= 1.0:
			var drain_amount = int(Level1Vars.accumulated_stamina_drain)
			Level1Vars.modify_stamina(-drain_amount)
			Level1Vars.accumulated_stamina_drain -= drain_amount

		# Update Level1Vars tracking (for debugging/UI)
		Level1Vars.is_draining_stamina = true
		Level1Vars.current_drain_rate = drain_rate
	else:
		# Not draining
		Level1Vars.is_draining_stamina = false
		Level1Vars.current_drain_rate = 0.0
```

**Implementation notes:**
- `drain_rate` is stamina per second
- Multiply by `delta` to get fractional drain for this frame
- Accumulate fractional values in `accumulated_stamina_drain` to prevent precision loss at high framerates
- Only subtract integer amounts when accumulated >= 1.0
- `modify_stamina()` already clamps to [0, max] and emits signals
- Tracking variables allow debug UI to show current drain state

**Why continuous tracking instead of snapshot?**
- Player gets immediate feedback when dropping coal
- Encourages strategic coal management mid-delivery
- Dropping 1 coal to stabilize reduces drain immediately
- More dynamic and skill-expressive

---

### 5. Add Debug Visualization (Optional)

Add optional debug overlay to show work zone boundary and drain state.

**In furnace.gd:**

Add debug toggle and visualization:
```gdscript
# Debug settings
var show_debug_overlay: bool = false  # Toggle with F12 or debug menu

func _ready():
	# ... (existing setup)

	# Enable debug overlay in development
	if OS.is_debug_build():
		show_debug_overlay = true

func _process(delta):
	# ... (existing tilt input handling)

	# Debug overlay
	if show_debug_overlay:
		queue_redraw()

func _draw():
	if not show_debug_overlay:
		return

	# Draw work zone boundary line
	var playarea_rect = playarea.get_global_rect()
	var boundary_x = playarea_rect.size.x / 3.0
	var boundary_local = Vector2(boundary_x, 0)

	draw_line(
		boundary_local,
		boundary_local + Vector2(0, playarea_rect.size.y),
		Color(1, 0, 0, 0.3),  # Red, 30% opacity
		2.0
	)

	# Draw drain status text
	if Level1Vars.is_draining_stamina:
		var drain_text = "DRAINING: %.2f/sec" % Level1Vars.current_drain_rate
		# Note: Actual text rendering requires Label node or custom font setup
		# This is pseudocode - implement with Label if needed
```

**Debug visualization shows:**
- Red vertical line at work zone boundary (playarea_width / 3)
- Current drain rate in stamina/second
- Active/inactive drain status

**Note:** Debug overlay is optional - remove if visual clutter is a problem. Players should learn the boundary organically through stamina bar feedback.

---

## Testing Strategy

### Manual Test Criteria

**Coal counting:**
- [ ] Coal pieces entering shovel bowl increment `coal_on_shovel`
- [ ] Coal pieces leaving shovel bowl decrement `coal_on_shovel`
- [ ] Same coal piece isn't double-counted
- [ ] `coal_on_shovel` never goes negative
- [ ] Area2D only detects layer 3 (coal), not other objects

**Work zone detection:**
- [ ] Shovel in left 1/3 of playfield: `in_work_zone = false`
- [ ] Shovel in right 2/3 of playfield: `in_work_zone = true`
- [ ] Boundary calculated correctly after ResponsiveLayout applies
- [ ] Crossing boundary updates `in_work_zone` immediately

**Stamina drain activation:**
- [ ] Drain ONLY when: `(coal_on_shovel >= 1) AND (in_work_zone)`
- [ ] No drain when: empty shovel in work zone
- [ ] No drain when: loaded shovel in safe zone (left 1/3)
- [ ] No drain when: empty shovel in safe zone
- [ ] Drain starts immediately when both conditions met

**Drain calculation:**
- [ ] 1 coal: drain rate = 0.2 + 0.1 = 0.3 stamina/second
- [ ] 2 coal: drain rate = 0.2 + 0.2 = 0.4 stamina/second
- [ ] 3 coal: drain rate = 0.2 + 0.3 = 0.5 stamina/second
- [ ] 5 coal: drain rate = 0.2 + 0.5 = 0.7 stamina/second
- [ ] Drain updates continuously as coal is dropped mid-delivery

**Stamina bar integration:**
- [ ] Stamina bar decreases smoothly during drain
- [ ] Stamina bar updates immediately when drain rate changes
- [ ] Stamina reaches 0 and stops (doesn't go negative)
- [ ] `modify_stamina()` signals trigger bar updates

### Efficiency Tests

Target: 25 deliveries × 3 coal avg with 50 stamina

**Scenario 1: Optimal play (3 coal, 4 sec delivery)**
- Drain rate: 0.5 stamina/second
- Per delivery: 0.5 × 4 = 2.0 stamina
- Total deliveries: 50 / 2.0 = 25 ✓ TARGET MET

**Scenario 2: Greedy play (5 coal, 4 sec delivery)**
- Drain rate: 0.7 stamina/second
- Per delivery: 0.7 × 4 = 2.8 stamina
- Total deliveries: 50 / 2.8 = 17.8 (~18) - Fewer deliveries, but 5 coal each = 90 total coal vs 75 coal in Scenario 1 ✓ REWARDED

**Scenario 3: Wasteful play (1 coal, 4 sec delivery)**
- Drain rate: 0.3 stamina/second
- Per delivery: 0.3 × 4 = 1.2 stamina
- Total deliveries: 50 / 1.2 = 41.6 (~42) - More deliveries, but only 42 total coal vs 75 coal in Scenario 1 ✗ PUNISHED

**Scenario 4: Speed play (3 coal, 2 sec delivery)**
- Drain rate: 0.5 stamina/second
- Per delivery: 0.5 × 2 = 1.0 stamina
- Total deliveries: 50 / 1.0 = 50 - 150 total coal! ✓✓ SPEED REWARDED

### Edge Cases

- [ ] Stamina reaches exactly 0: drain stops, no negative values
- [ ] Coal dropped while standing still in work zone: drain rate decreases immediately
- [ ] All coal dropped in work zone: drain stops (0 coal)
- [ ] Re-entering work zone with same coal load: drain resumes at correct rate
- [ ] Playarea resize (responsive layout): work zone boundary recalculates correctly
- [ ] Multiple rapid coal enter/exit events: count stays accurate

### Performance Tests

- [ ] No noticeable frame drops during continuous drain
- [ ] Delta scaling works correctly (drain rate consistent at 30fps vs 60fps)
- [ ] No console errors or warnings during normal gameplay
- [ ] Coal tracking array doesn't grow unbounded (coal pieces removed properly)

---

## Balance Tuning

### Current Design Values

```gdscript
stamina_drain_base = 0.2  # Stamina per second (shovel weight penalty)
stamina_drain_per_coal = 0.1  # Additional stamina per second per coal piece
stamina_max = 50  # Starting stamina (upgradable)
```

### Efficiency Breakdown (4 second delivery time)

| Coal Count | Drain Rate | Total Drain | Stamina/Coal | Verdict |
|------------|------------|-------------|--------------|---------|
| 1 coal | 0.3/sec | 1.2 | 1.20 | ✗ Very inefficient |
| 2 coal | 0.4/sec | 1.6 | 0.80 | ⚠️ Poor |
| 3 coal | 0.5/sec | 2.0 | 0.67 | ✓ Balanced target |
| 4 coal | 0.6/sec | 2.4 | 0.60 | ✓ Good |
| 5 coal | 0.7/sec | 2.8 | 0.56 | ✓✓ Efficient (risky) |
| 6 coal | 0.8/sec | 3.2 | 0.53 | ✓✓ Very efficient (very risky) |

**Key insight:** Base cost (0.2) creates ~40% overhead for 1 coal, but only ~7% overhead for 6 coal. This strongly incentivizes larger loads.

### Speed Impact (3 coal load)

| Delivery Time | Total Drain | Total Deliveries | Total Coal Delivered |
|---------------|-------------|------------------|----------------------|
| 2 sec (fast) | 1.0 | 50 | 150 coal ✓✓✓ |
| 3 sec (quick) | 1.5 | 33 | 99 coal ✓✓ |
| 4 sec (normal) | 2.0 | 25 | 75 coal ✓ (target) |
| 6 sec (slow) | 3.0 | 16 | 48 coal ⚠️ |
| 8 sec (very slow) | 4.0 | 12 | 36 coal ✗ |

**Speed is king:** Halving delivery time DOUBLES total coal output.

### Tuning Knobs for Future Balancing

If playtesting reveals issues, adjust these variables in Level1Vars:

**Problem: Stamina drains too fast, runs end too quickly**
- Decrease `stamina_drain_base` (0.15 instead of 0.2)
- Decrease `stamina_drain_per_coal` (0.08 instead of 0.1)
- Increase `stamina_max` starting value (75 instead of 50)

**Problem: No incentive to carry more coal (1-coal spam is optimal)**
- Increase `stamina_drain_base` (0.3 instead of 0.2) - punish small loads harder
- Decrease `stamina_drain_per_coal` (0.05 instead of 0.1) - reduce penalty for large loads

**Problem: Players just rush and ignore coal count**
- Increase `stamina_drain_per_coal` (0.15 instead of 0.1) - punish overloading
- Make tilt mechanic harder with more coal (separate plan, not stamina-related)

**Problem: Work zone boundary feels wrong (too early/late)**
- Adjust boundary calculation: `playarea_width / 2.0` for 50% split
- Or make it a Level1Vars variable: `work_zone_boundary_percent = 0.33`

### Expected Upgrade Path (Future Plans)

Players should be able to upgrade:
1. `stamina_max`: 50 → 75 → 100 → 150 (more deliveries per run)
2. `stamina_drain_base`: 0.2 → 0.15 → 0.1 → 0.05 (reduce shovel weight penalty)
3. `stamina_drain_per_coal`: 0.1 → 0.08 → 0.06 → 0.04 (carry more coal efficiently)
4. Work zone boundary: 33% → 40% → 50% (larger safe zone)

---

## Files to Create

None - all changes are additions to existing files

## Files to Modify

- [shovel.gd](../../game/v0.1/level1/shovel.gd) - Add coal counting, work zone detection, stamina drain calculation
- [level_1_vars.gd](../../game/v0.1/level1/level_1_vars.gd) - Add drain rate variables and tracking state
- [furnace.gd](../../game/v0.1/level1/furnace.gd) - (Optional) Add debug visualization overlay

---

## Design Values (Reference)

### Stamina Drain Rates

- **Base drain**: 0.2 stamina/second (shovel weight tax)
- **Per-coal drain**: 0.1 stamina/second per coal piece
- **Work zone**: Right 2/3 of playfield (boundary at playarea_width / 3)
- **Safe zone**: Left 1/3 of playfield (near coal pile)

### Target Performance

- **Starting stamina**: 50
- **Average deliveries**: 25 batches
- **Average coal per batch**: 3 pieces
- **Average delivery time**: 4 seconds
- **Total coal delivered**: ~75 pieces per run

### Formulas

- **Drain rate**: `base_drain + (coal_count × per_coal_drain)` stamina/second
- **Frame drain**: `drain_rate × delta` stamina/frame (rounded up with `ceil()`)
- **Work zone check**: `shovel.global_position.x > (playarea.global_rect.position.x + playarea.global_rect.size.x / 3.0)`
- **Drain condition**: `(coal_on_shovel >= 1) AND (in_work_zone)`

---

## Notes & Decisions

### Why base drain + per-coal scaling?

**Base drain (0.2/sec) creates "shovel weight tax":**
- Punishes carrying shovel with only 1 coal (inefficient)
- Makes empty shovel safe (can retreat to reload without penalty)
- Provides fixed cost that gets amortized across more coal pieces

**Per-coal drain (0.1/sec each) creates risk/reward:**
- More coal = faster drain, but more efficient per piece
- Ties into existing tilt mechanic: more coal = harder to balance
- Creates decision: safe 2-coal vs risky 5-coal

**Combined effect:**
- 1 coal: 70% overhead (base 0.2 / total 0.3)
- 3 coal: 40% overhead (base 0.2 / total 0.5)
- 5 coal: 28% overhead (base 0.2 / total 0.7)

This creates strong incentive to load 3+ coal without making 1-coal literally unplayable.

### Why right 2/3 work zone instead of heat-based or furnace proximity?

**Spatial work zone advantages:**
- Simple to implement (single X-coordinate check)
- No visual clutter (no heat shimmer effects needed)
- Clear binary state (in/out) - easier to understand than gradient
- Player learns boundary through stamina bar feedback
- Gives safe loading area in bottom-left near coal pile

**Why not heat-based drain near furnace?**
- Furnace is required destination - forced punishment, no choice
- Doesn't reward speed (heat would punish you MORE for being near goal)
- Positional drain feels arbitrary ("why does standing here drain stamina?")

**Why not drain on scoop action?**
- Player moves shovel through coal bin to collect desired amount
- No clear "scoop moment" to trigger drain
- Would punish exploration/positioning instead of commitment

### Why continuous drain instead of snapshot at checkpoint?

**Continuous tracking creates more skill expression:**
- Drop coal mid-delivery → drain decreases immediately
- Player can make tactical decisions: "drop 1 to save stamina"
- Rewards precision: fewer accidental drops = better efficiency
- Ties into existing drop penalties (separate mechanic)

**Snapshot would be simpler but less dynamic:**
- Lock drain rate when crossing boundary, ignore future changes
- Less player agency during delivery
- Doesn't reward careful balance/tilt management

### Why no visual marker for work zone boundary?

**Clean UI philosophy:**
- Stamina bar provides all feedback needed
- Player learns boundary organically: "stamina started draining here"
- No line/marker to clutter playfield
- Keeps visual focus on coal and shovel

**If playtesting shows confusion:**
- Add subtle floor color change at boundary
- Or temporary tutorial hint: "Entering work zone" first few runs
- Or particle effect when crossing boundary
- But start without visual marker - trust player learning

### Why drain continues when standing still?

**Prevents stalling strategies:**
- Player can't "rest" mid-delivery to regenerate stamina (no regen mechanic)
- Encourages decisive action: commit to delivery or retreat
- Creates time pressure without explicit timer
- Rewards fast, confident play over hesitant creeping

**Alternative would allow planning:**
- Player could pause mid-delivery to line up shot
- Feels less dynamic, more "puzzle-like" than action-oriented
- Not necessarily bad, but less aligned with "speed is rewarded" design goal

---

## Common Issues & Prevention

### Issue: Drain feels "choppy" or inconsistent

**Cause:** Converting float drain to integer every frame causes precision loss at high framerates
- Small drain values (0.3 stamina/sec at 60fps = 0.005 per frame) get lost with direct conversion
- Drain rate becomes inconsistent or too fast with rounding

**Solution:** Use accumulated drain approach (already implemented in this plan)
- Accumulate fractional drain in `Level1Vars.accumulated_stamina_drain`
- Only subtract integer amounts when accumulated >= 1.0
- This ensures accurate drain rate regardless of framerate

### Issue: Coal count is wrong (too high, too low, or fluctuating)

**Cause:** Area2D detecting non-coal objects or missing exited signals
- Check collision layers: Area2D mask = 4 (layer 3), coal layer = 4
- Verify coal RigidBody2D has `collision_layer = 4` set
- Ensure coal pieces don't get deleted without triggering `body_exited`

**Solution:** Add validation in `_on_coal_entered/exited`:
```gdscript
if body is RigidBody2D and body.collision_layer & 4:  # Verify layer 3
```

### Issue: Work zone boundary is wrong after window resize

**Cause:** `work_zone_boundary_x` calculated once in _ready(), not updated on resize

**Solution:** Already handled in this plan - viewport.size_changed signal recalculates boundary
- `_recalculate_work_zone_boundary()` is called on viewport resize
- Only recalculates when actually needed (not every frame)
- Efficient and responsive to window size changes

### Issue: Stamina drains when shovel is empty in work zone

**Cause:** Drain condition doesn't check for `coal_on_shovel >= 1`

**Solution:** Verify drain check:
```gdscript
var should_drain = (coal_on_shovel >= 1) and in_work_zone
```

### Issue: Stamina goes negative

**Cause:** `modify_stamina()` not clamping properly, or drain applying after stamina = 0

**Solution:** Verify `level_1_vars.gd`:
```gdscript
func modify_stamina(amount: int) -> bool:
	stamina = clampi(stamina + amount, 0, stamina_max)  # Clamp prevents negative
	emit_signal("stamina_changed", stamina, stamina_max)
	return true
```

---

## Implementation Checklist

**Code implementation:**
- [ ] Coal tracking variables added to shovel.gd
- [ ] Area2D coal detection setup in shovel.gd
- [ ] `_on_coal_entered()` and `_on_coal_exited()` handlers implemented
- [ ] Work zone boundary calculation in `_recalculate_work_zone_boundary()`
- [ ] Viewport resize signal connected to recalculate boundary
- [ ] Work zone status updated in `_physics_process()`
- [ ] Drain rate variables added to level_1_vars.gd
- [ ] `accumulated_stamina_drain` variable added to level_1_vars.gd
- [ ] `update_stamina_drain()` function implemented
- [ ] Drain calculation uses accumulation approach to prevent precision loss
- [ ] (Optional) Debug visualization in furnace.gd

**Testing:**
- [ ] Coal counting works correctly (enter/exit)
- [ ] Work zone detection accurate
- [ ] Stamina drains only when conditions met
- [ ] Drain rate updates with coal count changes
- [ ] Stamina bar shows real-time updates
- [ ] Edge cases handled (0 stamina, all coal dropped, etc.)
- [ ] Performance acceptable (no frame drops)
- [ ] No console errors

**Balance validation:**
- [ ] 3 coal, 4 sec delivery uses ~2.0 stamina
- [ ] 25 deliveries possible with 50 stamina
- [ ] Speed rewarded (2 sec delivery = better efficiency)
- [ ] Large loads rewarded (5+ coal more efficient per piece)
- [ ] Small loads punished (1-2 coal wasteful)

---

**Last Updated**: 2025-12-15
**Status**: Ready for implementation (pending coal spawning system)
