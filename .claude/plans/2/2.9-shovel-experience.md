# Shovel Experience System

**Goal**: Award player experience when coal is delivered to furnace, with separate leveling system for shoveling progression

**UPDATE (2025-12-29)**: The technique branch system referenced in this plan was removed in 2.x-upgrade-pool.md v3.0. All techniques are now in a single pool with no branch locking. This plan predates that change but the XP system design remains valid.

**Success Criteria**:
- Coal delivery awards XP to player level (stored in Level1Vars)
- Player levels up using exponential XP curve
- Level-up notifications display when reaching new levels
- Integration requires minimal code (single function call in furnace.gd)

## Overview

This system rewards players for successfully delivering coal to the furnace by granting experience toward their player level. This is a separate progression system from Global's 6 D&D-style stats (STR/DEX/CON/INT/WIS/CHA) - the player level represents shoveling mastery and unlocks technique upgrades.

### Key Design Principles

- **1 XP per coal delivered** - Simple, clear reward rate
- **Separate from Global stats** - Player level is shoveling-specific, not tied to Strength/Constitution/etc
- **Single integration point** - Award XP in furnace delivery callback
- **Exponential curve** - Same scaling pattern as Global stats for consistency
- **Level-up notification** - Clear feedback when player levels up

---

## Implementation Approach (TDD)

Following RED-GREEN-REFACTOR methodology:

1. **Write failing tests** for coal delivery XP integration
2. **Implement minimum code** to pass tests
3. **Refactor** if needed
4. **Verify** level-up logic works correctly

### Why Separate from Global Stats?

**Global stats (STR/DEX/CON/INT/WIS/CHA)**:
- Represent character attributes (D&D style)
- Could be trained through various activities across the game
- Persist across all game areas and levels
- May affect different systems (Strength for damage, Dexterity for aim, etc.)

**Player level (shoveling)**:
- Represents mastery at coal shoveling specifically
- Earned only through coal delivery in furnace scene
- Used exclusively for technique upgrade unlocks (plan 2.x-shovelling-level-up.md)
- Reset on prestige/run restart

**Rationale**:
- Clear separation of concerns: Stats are character attributes, player level is skill mastery
- Allows Global.strength to remain independent (could be trained through other activities later)
- Shoveling level can reset per run (roguelike), while stats persist
- Avoids confusing "why does Strength increase stamina but also unlock shovel upgrades?"

---

## TDD Implementation

### Test Suite: test_shovel_experience.gd

Following TDD cycle structure from test_currencies.gd pattern.

```gdscript
extends GutTest

# Test suite for shovel experience integration (Plan 2.9)
# Following TDD approach: Tests written FIRST, implementation comes after

# Reset to known state before each test
func before_each():
	# Reset player level and XP
	Level1Vars.player_level = 1
	Level1Vars.player_exp = 0.0

	# Reset coal tracking
	Level1Vars.coal_delivered = 0
	Level1Vars.coal_dropped = 0

# =============================================================================
# TDD CYCLE 1: XP Award System
# =============================================================================

func test_coal_delivery_awards_xp():
	# Record initial XP
	var initial_xp = Level1Vars.player_exp

	# Award XP for coal delivery
	Level1Vars.add_player_exp(1.0)

	# Verify XP awarded
	assert_eq(Level1Vars.player_exp, initial_xp + 1.0, "Coal delivery awards 1 XP")

func test_multiple_deliveries_accumulate():
	# Deliver 10 coal pieces
	for i in range(10):
		Level1Vars.add_player_exp(1.0)

	assert_eq(Level1Vars.player_exp, 10.0, "Multiple deliveries accumulate XP")

func test_zero_xp_award_safe():
	# Verify 0 XP doesn't break anything
	var initial_xp = Level1Vars.player_exp
	Level1Vars.add_player_exp(0.0)

	assert_eq(Level1Vars.player_exp, initial_xp, "Zero XP award is safe")

func test_negative_xp_rejected():
	# Verify negative XP is rejected
	var initial_xp = Level1Vars.player_exp
	Level1Vars.add_player_exp(-5.0)

	assert_eq(Level1Vars.player_exp, initial_xp, "Negative XP is rejected")

# =============================================================================
# TDD CYCLE 2: Level-Up Logic
# =============================================================================

func test_player_levels_up_at_threshold():
	# Calculate XP needed for level 2
	var xp_for_level_2 = Level1Vars.get_xp_for_level(2)

	# Award exact amount
	Level1Vars.add_player_exp(xp_for_level_2)

	assert_eq(Level1Vars.player_level, 2, "Player levels up at correct XP threshold")

func test_leftover_xp_carries_over():
	# Get XP for level 2
	var xp_for_level_2 = Level1Vars.get_xp_for_level(2)

	# Award more than needed
	Level1Vars.add_player_exp(xp_for_level_2 + 10.0)

	# Should be level 2 with 10 XP toward level 3
	assert_eq(Level1Vars.player_level, 2, "Player reaches level 2")
	assert_eq(Level1Vars.player_exp, 10.0, "Leftover XP carries to next level")

func test_multiple_level_ups_from_big_xp_dump():
	# Award massive XP (enough for multiple levels)
	var xp_for_level_5 = Level1Vars.get_xp_for_level(5)
	Level1Vars.add_player_exp(xp_for_level_5)

	assert_gte(Level1Vars.player_level, 5, "Multiple level-ups process correctly")

# =============================================================================
# TDD CYCLE 3: XP Curve Calculations
# =============================================================================

func test_xp_curve_exponential():
	# XP requirements should grow exponentially
	var xp_lvl_2 = Level1Vars.get_xp_for_level(2)
	var xp_lvl_3 = Level1Vars.get_xp_for_level(3)
	var xp_lvl_4 = Level1Vars.get_xp_for_level(4)

	# Each level should require more XP than previous
	assert_gt(xp_lvl_3, xp_lvl_2, "Level 3 requires more XP than level 2")
	assert_gt(xp_lvl_4, xp_lvl_3, "Level 4 requires more XP than level 3")

func test_get_xp_for_current_level():
	# Set player to level 3
	Level1Vars.player_level = 3

	var xp_needed = Level1Vars.get_xp_for_next_level()

	# Should return XP needed for level 4
	assert_eq(xp_needed, Level1Vars.get_xp_for_level(4), "Returns XP for next level")

func test_level_progress_calculation():
	# Level 1, need 100 XP for level 2, have 50 XP
	Level1Vars.player_level = 1
	Level1Vars.player_exp = 50.0

	var progress = Level1Vars.get_level_progress()

	# Should be 0.5 (50% to next level)
	assert_almost_eq(progress, 0.5, 0.01, "Progress calculation correct")

# =============================================================================
# TDD CYCLE 4: Save/Load Integration
# =============================================================================

func test_player_xp_persists_in_save():
	# Award some XP
	Level1Vars.player_level = 3
	Level1Vars.player_exp = 42.0

	# Get save data
	var save_data = Level1Vars.get_save_data()

	# Verify saved
	assert_eq(save_data.player_level, 3, "Player level saved")
	assert_eq(save_data.player_exp, 42.0, "Player XP saved")

func test_player_xp_loads_correctly():
	# Create mock save data
	var mock_save = {
		"player_level": 5,
		"player_exp": 123.5
	}

	# Load it
	Level1Vars.load_save_data(mock_save)

	# Verify loaded correctly
	assert_eq(Level1Vars.player_level, 5, "Player level loads")
	assert_eq(Level1Vars.player_exp, 123.5, "Player XP loads")
```

**Run tests (should FAIL initially)**:
```bash
godot --headless --script res://tests/test_runner.gd
```

---

## Implementation: Level1Vars XP System

After tests are written and failing (RED phase), implement minimal code to pass (GREEN phase).

### Add to level_1_vars.gd

**File**: [level1/level_1_vars.gd](../../game/v0.1/level1/level_1_vars.gd)

**Add variables**:
```gdscript
# Player progression (shoveling mastery)
var player_level: int = 1
var player_exp: float = 0.0

# XP curve configuration
const BASE_XP_FOR_LEVEL = 12.0
const EXP_SCALING = 1.25  # Gentler than Global stats (1.8) for faster early progression
```

**Add XP functions**:
```gdscript
# Award experience and check for level-ups
func add_player_exp(amount: float) -> void:
	if amount <= 0:
		return  # Reject zero/negative XP

	player_exp += amount

	# Check for level-up(s)
	while player_exp >= get_xp_for_next_level():
		# Deduct XP for current level
		player_exp -= get_xp_for_next_level()

		# Level up
		player_level += 1

		# Show notification
		_show_levelup_notification()

# Calculate total cumulative XP needed to reach a specific level from level 1
# Returns TOTAL XP, not incremental (e.g., level 3 returns sum of all XP from 1->2->3)
func get_xp_for_level(level: int) -> float:
	if level <= 1:
		return 0.0

	# Sum XP for all levels from 2 to target level
	var total_xp = 0.0
	for lvl in range(2, level + 1):
		# Each level's XP requirement: BASE_XP * (level - 1) ^ EXP_SCALING
		total_xp += BASE_XP_FOR_LEVEL * pow(lvl - 1, EXP_SCALING)

	return total_xp

# Get XP needed for next level from current level
func get_xp_for_next_level() -> float:
	return get_xp_for_level(player_level + 1) - get_xp_for_level(player_level)

# Get progress toward next level (0.0 to 1.0)
func get_level_progress() -> float:
	var xp_needed = get_xp_for_next_level()
	if xp_needed <= 0:
		return 0.0
	return clampf(player_exp / xp_needed, 0.0, 1.0)

# Show level-up notification
func _show_levelup_notification() -> void:
	if Global.has_method("show_notification"):
		Global.show_notification("Level up! You are now level %d" % player_level)
	else:
		print("LEVEL UP: Player is now level %d" % player_level)
```

**Add to save/load**:
```gdscript
# In get_save_data()
func get_save_data() -> Dictionary:
	return {
		# ... existing save data ...
		"player_level": player_level,
		"player_exp": player_exp,
	}

# In load_save_data()
func load_save_data(data: Dictionary):
	# ... existing load code ...
	player_level = data.get("player_level", 1)
	player_exp = data.get("player_exp", 0.0)
```

**Add to reset_to_defaults()**:

Since player_level is run-specific (resets on new run), add these lines to the existing `reset_to_defaults()` function:

```gdscript
# In reset_to_defaults()
func reset_to_defaults():
	# ... existing resource/physics resets ...

	# Player progression (reset for new run - run-specific)
	player_level = 1
	player_exp = 0.0

	# ... rest of function ...
```

---

### Integrate with Coal Delivery

**File**: [level1/furnace.gd](../../game/v0.1/level1/furnace.gd)

**Location**: Coal delivery callback (around line 269-271)

**Current code**:
```gdscript
func _on_coal_entered_delivery_zone(body: Node2D):
	# Only coal can trigger this (collision_mask = 4)
	body._on_entered_delivery_zone()
```

**Modified code**:
```gdscript
func _on_coal_entered_delivery_zone(body: Node2D):
	# Only coal can trigger this (collision_mask = 4)
	body._on_entered_delivery_zone()

	# Award player XP for successful delivery (Plan 2.9)
	Level1Vars.add_player_exp(1.0)
```

**That's it.** One line of code for integration.

---

## Verification (GREEN phase)

### Run Tests
```bash
godot --headless --script res://tests/test_runner.gd
```

**Expected results**:
- All tests in test_shovel_experience.gd pass
- Level-up logic handles single and multiple levels
- XP curve calculations are correct
- Save/load preserves player level and XP

### Manual Testing

1. **Basic XP Award**:
   - Start furnace scene
   - Check initial player_exp: `print(Level1Vars.player_exp)`
   - Deliver 1 coal to furnace
   - Verify player_exp increased by 1.0

2. **Level-Up Notification**:
   - Calculate XP needed: `var xp = Level1Vars.get_xp_for_level(2)`
   - Deliver that many coal pieces (12 coal for level 2)
   - Verify "Level up! You are now level 2" notification appears
   - Verify `Level1Vars.player_level == 2`

3. **Save/Load Persistence**:
   - Award some player XP via coal delivery
   - Save game (Level1Vars.get_save_data() should include player_level and player_exp)
   - Reload game
   - Verify player_level and player_exp persist

4. **Multiple Level-Ups**:
   - Use debug button to add massive XP
   - Verify multiple level-ups process without errors
   - Check Level1Vars.player_level increased appropriately
   - Check leftover XP carried to next level

---

## Design Rationale

### Decision 1: Separate Player Level from Global Stats

**Why not use Global.strength?**
- **Conceptual clarity**: Strength is a D&D-style attribute (physical power), player level is skill mastery (shoveling technique)
- **Flexibility**: Global.strength could be trained through other activities in future content
- **Reset mechanics**: Player level can reset on prestige/run restart, while stats persist
- **Upgrade confusion**: Strength affecting both damage AND technique unlocks would be confusing

**Chosen approach**:
- `Level1Vars.player_level` - Shoveling mastery level (run-specific)
- `Level1Vars.player_exp` - Progress toward next level
- Independent from Global's 6-stat system

### Decision 2: Gentler XP Curve Than Global Stats

**Rationale**:
- **Faster early progression**: Shoveling level-ups should feel more frequent than stat increases
- **Roguelike pacing**: Players need upgrades earlier to feel build variety per run
- **Balance**: BASE_XP (12) much lower than Global (100), and EXP_SCALING (1.25) lower than Global's (1.8)
- **Very gentle curve**: Near-linear progression in early levels for consistent upgrade pacing

**XP Requirements** (1 coal = 1 XP):

| Level | Total XP Needed | XP This Level | Coal Needed |
|-------|-----------------|---------------|-------------|
| 1     | 0               | 0             | 0           |
| 2     | 12              | 12            | 12          |
| 3     | 27              | 15            | 15 more     |
| 4     | 44              | 17            | 17 more     |
| 5     | 63              | 19            | 19 more     |

The "Total XP Needed" column shows cumulative XP from level 1, while "XP This Level" shows incremental XP required for that specific level increase.

### Decision 3: 1 XP Per Coal (No Multipliers Yet)

**Current approach**:
- Flat 1.0 XP per coal delivered
- Simple, predictable, easy to balance
- Future upgrades can modify this (see plan 2.x-upgrade-pool.md for XP multiplier techniques)

**No experience_gain_rate variable yet**:
- YAGNI: Don't add until upgrade system needs it
- Can add later when technique that boosts XP gain is implemented

---

## Future Enhancements

These are NOT implemented in this plan (YAGNI):

1. **XP Multipliers** (when upgrade system exists):
   - Could multiply XP at call site: `Level1Vars.add_player_exp(1.0 * xp_multiplier)`
   - Technique upgrade could increase multiplier (e.g., "Fast Learner" +20% XP)

2. **Variable XP by Coal Quality** (if coal types added):
   - Could check coal.quality: `Level1Vars.add_player_exp(coal.xp_value)`
   - Requires coal type system first (separate plan)

3. **Level-Up Bonuses** (stamina restore, temporary buffs):
   - Could restore stamina on level-up: `Level1Vars.modify_stamina(stamina_max)`
   - Could grant temporary boost: "Inspired" status effect

4. **XP from Other Actions** (if desired):
   - Could award XP for flawless deliveries, combos, perfect aim
   - Wait for design doc on XP sources

---

## Files Modified

- [level1/level_1_vars.gd](../../game/v0.1/level1/level_1_vars.gd):
  - Add `player_level` and `player_exp` variables
  - Add `add_player_exp()`, `get_xp_for_level()`, `get_xp_for_next_level()`, `get_level_progress()` functions
  - Add level-up notification helper
  - Update save/load functions
  - Update `reset_to_defaults()` to reset player_level and player_exp

- [level1/furnace.gd](../../game/v0.1/level1/furnace.gd):
  - Add single line: `Level1Vars.add_player_exp(1.0)` in delivery callback

## Files Created

- `tests/test_shovel_experience.gd` - TDD test suite (written FIRST)

---

## Implementation Checklist (TDD Order)

**RED Phase** (Write failing tests):
- [ ] Create tests/test_shovel_experience.gd
- [ ] Write TDD Cycle 1 tests (XP award system)
- [ ] Write TDD Cycle 2 tests (level-up logic)
- [ ] Write TDD Cycle 3 tests (XP curve calculations)
- [ ] Write TDD Cycle 4 tests (save/load)
- [ ] Run tests, verify all FAIL (RED state confirmed)

**GREEN Phase** (Make tests pass):
- [ ] Add player_level and player_exp to Level1Vars
- [ ] Implement add_player_exp() with level-up logic
- [ ] Implement XP curve functions
- [ ] Add save/load support
- [ ] Add player_level and player_exp reset to reset_to_defaults()
- [ ] Add `Level1Vars.add_player_exp(1.0)` to furnace.gd delivery callback
- [ ] Run tests, verify all PASS (GREEN state achieved)

**REFACTOR Phase** (Improve without changing behavior):
- [ ] Review implementation for clarity
- [ ] Add code comments if needed
- [ ] Verify tests still pass after any refactoring

**VERIFY Phase** (Manual testing):
- [ ] Manual test: Deliver coal, verify XP awarded
- [ ] Manual test: Reach level 2, verify notification
- [ ] Manual test: Save/load preserves player_level and player_exp
- [ ] Manual test: Multiple level-ups work correctly with leftover XP

---

## Notes

**Separation of Concerns**:
- **Global stats** (STR/DEX/CON/INT/WIS/CHA): Character attributes, persist across game
- **Player level** (Level1Vars): Shoveling mastery, used for technique unlocks, run-specific

**Integration with Other Plans**:
- **Plan 2.x-shovelling-level-up.md**: Uses `Level1Vars.player_level` to determine when Mind button appears
- **Plan 2.x-upgrade-pool.md**: Techniques unlock based on player level, not Global.strength

**Why This Is Better Than Using Global.strength**:
- Clear conceptual separation (attributes vs skills)
- Avoids coupling Global stat system to shoveling-specific mechanics
- Allows future expansion (strength could be trained elsewhere)
- Run-specific progression (can reset without affecting character stats)

---

**Last Updated**: 2025-12-27
**Maintainer**: Claude + User collaboration
**Plan Version**: 3.0 (Rewritten to use separate player level system in Level1Vars)
