# Shovel Experience System

**Goal**: Award Strength XP when coal is delivered to furnace, leveraging Global's existing stat experience system

**Success Criteria**:
- Coal delivery awards XP to Strength stat via Global.add_stat_exp()
- Strength levels up automatically using Global's existing XP curve (exponential)
- Level-up notifications display via Global's existing stat setters
- Integration requires minimal code (single function call in furnace.gd)

## Overview

This system rewards players for successfully delivering coal to the furnace by granting experience to their Strength stat. The implementation leverages Global's existing 6-stat experience system rather than creating a parallel progression system.

### Key Design Principles

- **1 XP per coal delivered** - Simple, clear reward rate
- **Use existing Global stat system** - No duplicate progression tracking
- **Single integration point** - Award XP in furnace delivery callback
- **Strength represents physical labor** - Coal shoveling builds physical power
- **No new save data** - Global already persists strength_exp

---

## Implementation Approach (TDD)

Following RED-GREEN-REFACTOR methodology:

1. **Write failing tests** for coal delivery XP integration
2. **Implement minimum code** to pass tests
3. **Refactor** if needed
4. **Verify** existing Global stat system handles level-ups correctly

### Why Use Global's Stat System?

**Existing infrastructure**:
- `Global.add_stat_exp(stat_name, amount)` - Awards XP and checks level-ups
- `Global.get_xp_for_level(level)` - Exponential curve (BASE_XP_FOR_LEVEL * pow(level - 1, EXP_SCALING))
- `Global.get_stat_level_progress(stat_name)` - Returns 0.0-1.0 progress
- Automatic notifications via stat setters ("You feel stronger")
- Save/load already implemented

**Benefits**:
- No duplicate code
- Consistent XP curve across all stats
- Notifications work immediately
- No new save variables
- Future UI can use existing progress functions

---

## TDD Implementation

### Test Suite: test_shovel_experience.gd

Following TDD cycle structure from test_currencies.gd pattern.

```gdscript
extends GutTest

# Test suite for shovel experience integration (Plan 2.9)
# Following TDD approach: Tests written FIRST, implementation comes after

# Reset to known state before each test
func before_each():
	# Reset Global strength stat to baseline
	Global.strength = 1
	Global.strength_exp = 0.0

	# Reset Level1Vars coal tracking
	Level1Vars.coal_delivered = 0
	Level1Vars.coal_dropped = 0

# =============================================================================
# TDD CYCLE 1: Verify Global Stat System Works
# =============================================================================

func test_global_add_stat_exp_exists():
	# Verify API exists before relying on it
	assert_true(Global.has_method("add_stat_exp"), "Global has add_stat_exp method")

func test_global_accepts_strength_stat():
	# Verify "strength" is valid stat name
	Global.add_stat_exp("strength", 1.0)
	assert_eq(Global.strength_exp, 1.0, "Strength XP increases")

func test_global_strength_levels_up():
	# Verify level-up mechanics work for strength
	var xp_for_level_2 = Global.get_xp_for_level(2)
	Global.add_stat_exp("strength", xp_for_level_2)

	assert_eq(Global.strength, 2, "Strength levels up at correct XP threshold")

# =============================================================================
# TDD CYCLE 2: Coal Delivery Integration
# =============================================================================

func test_coal_delivery_awards_strength_xp():
	# Create mock coal piece with delivery callback
	var coal = Node2D.new()
	coal.set_script(preload("res://level1/coal_piece.gd"))

	# Record initial XP
	var initial_xp = Global.strength_exp

	# Simulate delivery (coal_piece._on_entered_delivery_zone increments coal_delivered)
	Level1Vars.coal_delivered += 1
	Global.add_stat_exp("strength", 1.0)

	# Verify XP awarded
	assert_eq(Global.strength_exp, initial_xp + 1.0, "Coal delivery awards 1 XP")

	coal.free()

func test_multiple_deliveries_accumulate():
	# Deliver 10 coal pieces
	for i in range(10):
		Level1Vars.coal_delivered += 1
		Global.add_stat_exp("strength", 1.0)

	assert_eq(Global.strength_exp, 10.0, "Multiple deliveries accumulate XP")

func test_strength_levels_up_from_coal():
	# Calculate XP needed for level 2
	var xp_needed = Global.get_xp_for_level(2)

	# Deliver enough coal to level up (xp_needed coal pieces)
	for i in range(int(xp_needed)):
		Global.add_stat_exp("strength", 1.0)

	assert_eq(Global.strength, 2, "Enough coal deliveries trigger level-up")

# =============================================================================
# TDD CYCLE 3: Edge Cases
# =============================================================================

func test_multiple_level_ups_from_big_xp_dump():
	# Award massive XP (enough for multiple levels)
	var xp_for_level_5 = Global.get_xp_for_level(5)
	Global.add_stat_exp("strength", xp_for_level_5)

	assert_gte(Global.strength, 5, "Multiple level-ups process correctly")

func test_zero_xp_award_safe():
	# Verify 0 XP doesn't break anything
	var initial_xp = Global.strength_exp
	Global.add_stat_exp("strength", 0.0)

	assert_eq(Global.strength_exp, initial_xp, "Zero XP award is safe")

# =============================================================================
# TDD CYCLE 4: Save/Load Integration
# =============================================================================

func test_strength_xp_persists_in_save():
	# Award some XP
	Global.add_stat_exp("strength", 42.0)

	# Get save data
	var save_data = Global.get_save_data()

	# Verify strength_exp saved
	assert_true("strength_exp" in save_data.game, "Save data includes strength_exp")
	assert_eq(save_data.game.strength_exp, 42.0, "Correct XP value saved")

func test_strength_xp_loads_correctly():
	# Create mock save data
	var mock_save = {
		"game": {
			"strength": 3,
			"strength_exp": 150.0
		}
	}

	# Load it
	Global.load_save_data(mock_save)

	# Verify loaded correctly
	assert_eq(Global.strength, 3, "Strength level loads")
	assert_eq(Global.strength_exp, 150.0, "Strength XP loads")
```

**Run tests (should FAIL initially)**:
```bash
godot --headless --script res://tests/test_runner.gd
```

---

## Implementation: Integrate with Coal Delivery

After tests are written and failing (RED phase), implement minimal code to pass (GREEN phase).

### Modify furnace.gd

**File**: [level1/furnace.gd](../../game/v0.1/level1/furnace.gd)

**Location**: Line 269-271 (_on_coal_entered_delivery_zone callback)

**Current code**:
```gdscript
func _on_coal_entered_delivery_zone(body: Node2D):
	# Only coal can trigger this (collision_mask = 4)
	body._on_entered_delivery_zone()
```

**Modified code**:
```gdscript
func _on_coal_entered_delivery_zone(body: Node2D):
	# Only coal can trigger this (collision_mask = 4)
	body._on_entered_delivery_zone()

	# Award Strength XP for successful delivery (Plan 2.9)
	Global.add_stat_exp("strength", 1.0)
```

**That's it.** One line of code.

---

## Verification (GREEN phase)

### Run Tests
```bash
godot --headless --script res://tests/test_runner.gd
```

**Expected results**:
- All tests in test_shovel_experience.gd pass
- Global stat system handles level-ups automatically
- Notifications appear via existing stat setters

### Manual Testing

1. **Basic XP Award**:
   - Start furnace scene
   - Check initial strength_exp: `print(Global.strength_exp)`
   - Deliver 1 coal to furnace
   - Verify strength_exp increased by 1.0

2. **Level-Up Notification**:
   - Calculate XP needed: `var xp = Global.get_xp_for_level(2)`
   - Deliver that many coal pieces
   - Verify "You feel stronger" notification appears
   - Verify `Global.strength == 2`

3. **Save/Load Persistence**:
   - Award some Strength XP via coal delivery
   - Save game (Global handles this automatically)
   - Reload game
   - Verify strength and strength_exp persist

4. **Multiple Level-Ups**:
   - Use debug button to add 25 coal delivered (triggers multiple XP awards)
   - Verify multiple level-ups process without errors
   - Check Global.strength increased appropriately

---

## Design Rationale

### Decision 1: Use Global Stats Instead of Local Player Level

**Rejected approach** (from original plan):
- Separate `player_level` and `player_experience` in Level1Vars
- Custom XP curve (1.3x multiplier vs Global's exponential)
- Dual-track progression (local level + global Strength)

**Chosen approach**:
- Single source of truth: Global.strength_exp
- Reuse existing XP curve (exponential, same as all stats)
- No duplicate progression systems

**Rationale**:
- **Simpler**: 1 line of code vs 200+ lines
- **Consistent**: Same progression feel as other stats
- **Maintainable**: No duplicate save/load logic
- **YAGNI**: Don't build custom system until proven necessary
- **SOLID**: Single Responsibility (Global owns all stat progression)

### Decision 2: 1 XP Per Coal (No Multipliers Yet)

**No experience_gain_rate variable** (rejected from original plan):
- Would add unused variable to save data
- Premature optimization for hypothetical upgrade system
- Can add later when upgrade plan designed

**Current approach**:
- Flat 1.0 XP per coal delivered
- Simple, predictable, easy to balance
- Future upgrades can multiply this at call site if needed

### Decision 3: Strength Stat Represents Physical Labor

**Why Strength?**
- Coal shoveling is physical work
- Thematically consistent (muscles develop from repetitive labor)
- Could award other stats in future (Constitution for endurance, Dexterity for precision aim)

**Alternative considered**: Constitution
- Rejected: Con represents resilience/health, not work output
- Strength fits better for "powerful shoveling" narrative

---

## Future Enhancements

These are NOT implemented in this plan (YAGNI):

1. **XP Multipliers** (when upgrade system exists):
   - Could multiply XP at call site: `Global.add_stat_exp("strength", 1.0 * upgrade_multiplier)`
   - Don't add variables until upgrade plan defines them

2. **Multi-Stat Awards** (if desired):
   - Could also award Constitution: `Global.add_stat_exp("constitution", 0.5)`
   - Wait for design doc on stat distribution philosophy

3. **Variable XP by Coal Quality** (if coal types added):
   - Could check coal.quality: `Global.add_stat_exp("strength", coal.xp_value)`
   - Requires coal type system first (separate plan)

4. **Level-Up Bonuses** (stamina restore, temporary buffs):
   - Requires design of what happens on Strength level-up
   - Currently only notification ("You feel stronger")

---

## Files Modified

- [level1/furnace.gd](../../game/v0.1/level1/furnace.gd) - Add single line: `Global.add_stat_exp("strength", 1.0)` in delivery callback

## Files Created

- `tests/test_shovel_experience.gd` - TDD test suite (written FIRST)

---

## Implementation Checklist (TDD Order)

**RED Phase** (Write failing tests):
- [ ] Create tests/test_shovel_experience.gd
- [ ] Write TDD Cycle 1 tests (verify Global API)
- [ ] Write TDD Cycle 2 tests (coal delivery integration)
- [ ] Write TDD Cycle 3 tests (edge cases)
- [ ] Write TDD Cycle 4 tests (save/load)
- [ ] Run tests, verify all FAIL (RED state confirmed)

**GREEN Phase** (Make tests pass):
- [ ] Add `Global.add_stat_exp("strength", 1.0)` to furnace.gd delivery callback
- [ ] Run tests, verify all PASS (GREEN state achieved)

**REFACTOR Phase** (Improve without changing behavior):
- [ ] Review implementation for clarity
- [ ] Add code comments if needed
- [ ] Verify tests still pass after any refactoring

**VERIFY Phase** (Manual testing):
- [ ] Manual test: Deliver coal, verify XP awarded
- [ ] Manual test: Reach level 2, verify notification
- [ ] Manual test: Save/load preserves strength_exp
- [ ] Manual test: Multiple level-ups work correctly

---

## Notes

**Complexity Removed**:
- No custom XP formulas (use Global's)
- No custom level-up checks (Global handles it)
- No custom notifications (stat setters do it)
- No new save variables (Global already saves strength_exp)
- No progress tracking functions (Global.get_stat_level_progress exists)

**Lines of Code**:
- Original plan: ~200 lines of implementation
- This plan: 1 line of implementation + test suite

**Why This Is Better**:
- Follows DRY (Don't Repeat Yourself)
- Follows KISS (Keep It Simple)
- Follows YAGNI (You Aren't Gonna Need It)
- Follows SOLID (Single Responsibility - Global owns stats)
- Follows TDD (Tests written first)

---

**Last Updated**: 2025-12-24
**Maintainer**: Claude + User collaboration
**Plan Version**: 2.0 (Rewritten for TDD + simplified to use Global stat system)
