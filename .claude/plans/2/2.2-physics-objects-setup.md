# Physics Objects Setup (Shovelling Phase 1)

**Goal**: Create the physical environment for shovelling gameplay - coal pile, furnace opening with obstacles, and shovel surface.

**Success Criteria**:
- Coal pile visual and scoop detection area rendered in bottom-left
- Furnace opening with physical obstacles rendered on right side
- Shovel follows mouse as RigidBody2D with collision surface and tilt physics
- Left/Right click controls shovel tilt (balancing mechanic)
- Shared PhysicsMaterial resources created and applied
- All elements visible and positioned correctly

## Overview

This phase establishes the static physical environment for the shovelling mechanic. No coal spawning or tracking yet - just the physical objects that coal will interact with. The shovel follows the mouse with physics-based rotation that can be controlled via left/right click for balancing. The furnace has collision obstacles but no delivery detection.

**Dependencies**:
- Requires [2.x-scene-network.md](2.x-scene-network.md) for scene structure
- Modifies existing `level1/furnace.tscn` and `level1/furnace.gd`

---

## Implementation Tasks

### 1. Shared PhysicsMaterial Resources

Create reusable physics materials to avoid redundant instantiation.

**Files to create:**
- `res://level1/coal_physics_material.tres`
- `res://level1/shovel_physics_material.tres`

**coal_physics_material.tres:**
```
[gd_resource type="PhysicsMaterial" format=3]

[resource]
friction = 0.7
bounce = 0.15
```

**shovel_physics_material.tres:**
```
[gd_resource type="PhysicsMaterial" format=3]

[resource]
friction = 0.7
bounce = 0.1
```

### 2. Coal Pile Visual and Detection Area

Position a coal pile in the bottom-left of the playarea with an Area2D for scoop detection.

**In furnace.tscn:**
- Add Node2D named "CoalPile" under playarea
- Add Polygon2D child for visual (filled black/dark gray polygon)
- Add Area2D child named "CoalPileArea"
- Add CircleShape2D to Area2D (radius: 100px)

**In furnace.gd:**
```gdscript
@onready var coal_pile_area: Area2D = $AspectContainer/MainContainer/mainarea/PlayArea/CoalPile/CoalPileArea
@onready var playarea: Control = $AspectContainer/MainContainer/mainarea/PlayArea

var coal_pile_position: Vector2
var coal_pile_radius: float = 100.0

func _ready():
    ResponsiveLayout.apply_to_scene(self)  # REQUIRED
    connect_navigation()
    # Defer physics setup until after layout is applied
    await get_tree().process_frame
    setup_physics_objects()

func setup_physics_objects():
    # Get playarea size
    var playarea_size = playarea.size

    # Calculate coal pile position (bottom-left corner)
    coal_pile_position = Vector2(100, playarea_size.y - 100)

    # Position coal pile
    $AspectContainer/MainContainer/mainarea/PlayArea/CoalPile.position = coal_pile_position
```

**Visual design:**
- Shape: Irregular polygon resembling a mound
- Color: Dark gray or black (#2a2a2a)
- Size: ~100px radius
- Position: Bottom-left, approximately (100, viewport_height - 100)

### 3. Furnace Opening with Physical Obstacles

Create vertical line on right side with physical obstacles above/below the opening.

**In furnace.tscn:**
- Add Node2D named "FurnaceWall" under playarea
- Add Line2D child named "TopLine" for visual line (top segment)
- Add Line2D child named "BottomLine" for visual line (bottom segment)
- Add StaticBody2D named "TopObstacle"
- Add CollisionShape2D with RectangleShape2D (40px thick)
- Add StaticBody2D named "BottomObstacle"
- Add CollisionShape2D with RectangleShape2D (40px thick)

**In furnace.gd:**
```gdscript
@onready var furnace_wall: Node2D = $AspectContainer/MainContainer/mainarea/PlayArea/FurnaceWall

var furnace_line_x: float
var furnace_opening_top: float
var furnace_opening_bottom: float
var furnace_opening_height_percent: float = 0.20  # 20% of playarea height

func setup_physics_objects():
    # ... (previous coal pile setup)

    # Calculate furnace positions
    var furnace_opening_height = playarea_size.y * furnace_opening_height_percent
    furnace_line_x = playarea_size.x - 50
    furnace_opening_top = (playarea_size.y / 2) - (furnace_opening_height / 2)
    furnace_opening_bottom = furnace_opening_top + furnace_opening_height

    # Position furnace wall
    furnace_wall.position.x = furnace_line_x

    # Setup vertical line visual with gap (draw top and bottom segments)
    var top_line = furnace_wall.get_node("TopLine")
    top_line.points = PackedVector2Array([
        Vector2(0, 0),
        Vector2(0, furnace_opening_top)
    ])
    top_line.default_color = Color.BLACK
    top_line.width = 5.0

    var bottom_line = furnace_wall.get_node("BottomLine")
    bottom_line.points = PackedVector2Array([
        Vector2(0, furnace_opening_bottom),
        Vector2(0, playarea_size.y)
    ])
    bottom_line.default_color = Color.BLACK
    bottom_line.width = 5.0

    # Position top obstacle
    var top_obstacle = furnace_wall.get_node("TopObstacle/CollisionShape2D")
    var top_height = furnace_opening_top
    top_obstacle.position = Vector2(0, top_height / 2)
    top_obstacle.shape.size = Vector2(40, top_height)

    # Position bottom obstacle
    var bottom_obstacle = furnace_wall.get_node("BottomObstacle/CollisionShape2D")
    var bottom_height = playarea_size.y - furnace_opening_bottom
    bottom_obstacle.position = Vector2(0, furnace_opening_bottom + (bottom_height / 2))
    bottom_obstacle.shape.size = Vector2(40, bottom_height)
```

**Design values:**
- Furnace line X: playarea_width - 50px
- Opening height: 20% of playarea height (percentage-based for scaling)
- Opening center: playarea_height / 2
- Obstacle thickness: 40px (prevents tunneling)

### 4. Shovel Physical Surface

Create RigidBody2D that follows mouse position with physics-based tilt control.

**In furnace.tscn:**
- Add Node2D named "Shovel" under playarea
- Add RigidBody2D child
- Add 3 CollisionShape2D nodes with SegmentShape2D to form bowl:
  - "LeftWall": line from (-40, -5) to (-18, 8)
  - "BottomWall": line from (-18, 8) to (18, 8)
  - "RightWall": line from (18, 8) to (40, -5)
- Add Line2D child named "OutlineLine2D" for gray outline (10px thick, 80% gray)
- Add Line2D child named "Line2D" for black curve (6px thick)

**Create new file: res://level1/shovel.gd**
```gdscript
extends RigidBody2D

const SHOVEL_WIDTH: float = 80.0
const SHOVEL_PHYSICS_MAT = preload("res://level1/shovel_physics_material.tres")
const FOLLOW_SPEED: float = 3000.0  # How fast shovel moves toward mouse
const TILT_TORQUE: float = 108000.0  # Torque applied per second when holding
const MAX_ROTATION_DEGREES: float = 45.0  # Maximum tilt angle
const BOUNCE_BACK_TORQUE: float = 200.0  # Torque applied when hitting max tilt

var shovel_curve: PackedVector2Array
var line_2d: Line2D
var outline_line: Line2D
var scoop_cooldown_timer: float = 0.0
var playarea: Control

func _ready():
    # Get reference to playarea (parent's parent)
    playarea = get_parent().get_parent()

    # RigidBody2D physics setup
    lock_rotation = false  # Allow rotation for tilt mechanic
    mass = 20.0  # Heavy enough to resist coal pushing it around
    gravity_scale = 0.0  # No gravity
    linear_damp = 15.0  # High damping for responsive stop
    angular_damp = 2.0  # Dampen rotation over time

    # Collision layers
    collision_layer = 2
    collision_mask = 1 | 4  # World (layer 1) + coal (layer 3)

    # Define shovel visual curve (for aesthetics only)
    shovel_curve = PackedVector2Array([
        Vector2(-40, -5),   # Left edge, slightly raised
        Vector2(-20, 5),    # Left-center, deeper
        Vector2(0, 8),      # Center, deepest point
        Vector2(20, 5),     # Right-center, deeper
        Vector2(40, -5)     # Right edge, slightly raised
    ])

    # Setup outline (gray, thicker) - draws first (behind)
    outline_line = get_node("OutlineLine2D")
    outline_line.points = shovel_curve
    outline_line.default_color = Color(0.8, 0.8, 0.8)  # 80% gray
    outline_line.width = 10.0
    outline_line.z_index = 0

    # Setup main line (black, thinner) - draws second (in front)
    line_2d = get_node("Line2D")
    line_2d.points = shovel_curve
    line_2d.default_color = Color.BLACK
    line_2d.width = 6.0
    line_2d.z_index = 1

    # Apply shared physics material
    physics_material_override = SHOVEL_PHYSICS_MAT

func _physics_process(delta):
    # Get mouse position
    var mouse_pos = get_global_mouse_position()

    if playarea:
        var playarea_rect = playarea.get_global_rect()
        mouse_pos.x = clamp(mouse_pos.x, playarea_rect.position.x, playarea_rect.position.x + playarea_rect.size.x)
        mouse_pos.y = clamp(mouse_pos.y, playarea_rect.position.y, playarea_rect.position.y + playarea_rect.size.y)

    # Calculate direction to mouse
    var direction = mouse_pos - global_position

    # Set velocity toward mouse (CRITICAL: velocity-based, not direct position)
    linear_velocity = direction * FOLLOW_SPEED * delta

    # Clamp rotation to max angle
    var current_rotation_deg = rad_to_deg(rotation)
    if abs(current_rotation_deg) > MAX_ROTATION_DEGREES:
        # Clamp rotation
        rotation = deg_to_rad(clamp(current_rotation_deg, -MAX_ROTATION_DEGREES, MAX_ROTATION_DEGREES))
        # Apply bounce back torque in opposite direction
        var bounce_direction = -sign(current_rotation_deg)
        apply_torque_impulse(bounce_direction * BOUNCE_BACK_TORQUE)

    # Update cooldown timer
    if scoop_cooldown_timer > 0.0:
        scoop_cooldown_timer -= delta

func tilt_left(delta: float):
    # Apply counter-clockwise torque (negative in Godot)
    # Scale by delta for consistent speed regardless of framerate
    apply_torque_impulse(-TILT_TORQUE * delta)

func tilt_right(delta: float):
    # Apply clockwise torque (positive in Godot)
    # Scale by delta for consistent speed regardless of framerate
    apply_torque_impulse(TILT_TORQUE * delta)
```

**In furnace.tscn:**
- Attach shovel.gd script to RigidBody2D node

**In furnace.gd:**

Add `@onready var shovel_body` reference at the top:
```gdscript
@onready var shovel_body: RigidBody2D = $AspectContainer/MainContainer/mainarea/PlayArea/Shovel/RigidBody2D
```

Add mouse button tracking variables (after other variable declarations):
```gdscript
# Track which mouse button is held
var left_mouse_held: bool = false
var right_mouse_held: bool = false
```

Add input handling function:
```gdscript
func _input(event):
    if event is InputEventMouseButton:
        if event.button_index == MOUSE_BUTTON_LEFT:
            left_mouse_held = event.pressed
        elif event.button_index == MOUSE_BUTTON_RIGHT:
            right_mouse_held = event.pressed
```

Update _process() to apply tilt torque while buttons held:
```gdscript
func _process(delta):
    # Apply continuous tilt torque while mouse buttons are held
    if left_mouse_held:
        shovel_body.tilt_left(delta)
    if right_mouse_held:
        shovel_body.tilt_right(delta)
```

---

## Testing Checklist

### Visual Tests
- [ ] Coal pile renders in bottom-left corner
- [ ] Coal pile is visually distinct (dark gray/black mound shape)
- [ ] Furnace vertical line renders on right side in two segments (TopLine and BottomLine)
- [ ] Furnace opening gap is visible and centered vertically (20% of playarea height)
- [ ] Shovel has gray outline (10px, 80% gray) and black curve (6px) - clearly visible
- [ ] Shovel follows mouse smoothly with no lag
- [ ] Shovel is constrained to playarea bounds (doesn't go outside)

### Physics Tests
- [ ] Shovel is a RigidBody2D (check in scene tree)
- [ ] Shovel has 3 collision segments forming bowl shape (LeftWall, BottomWall, RightWall)
- [ ] Collision segments create concave bowl: angled sides, flat bottom
- [ ] Shovel has mass = 20.0, gravity_scale = 0.0, linear_damp = 15.0, angular_damp = 2.0
- [ ] Shovel rotation is NOT locked (lock_rotation = false)
- [ ] Furnace obstacles are StaticBody2D with collision shapes
- [ ] Obstacle thickness is 40px
- [ ] Shared PhysicsMaterial resources exist and are loaded
- [ ] Shovel has shovel_physics_material applied
- [ ] No errors in console when running scene

### Tilt Mechanic Tests
- [ ] Holding left mouse button applies continuous counter-clockwise torque (shovel tilts left)
- [ ] Holding right mouse button applies continuous clockwise torque (shovel tilts right)
- [ ] Releasing mouse button stops applying torque (shovel rotation dampens naturally)
- [ ] Shovel rotation is clamped to +/- 45 degrees
- [ ] Shovel bounces back when hitting max tilt (BOUNCE_BACK_TORQUE applied)
- [ ] Shovel rotation dampens over time (angular_damp = 2.0 working)
- [ ] Tilt torque is strong enough to rotate quickly (TILT_TORQUE = 108000.0)

### Position Tests
- [ ] Coal pile position updates based on playarea size
- [ ] Furnace line X position is playarea_width - 50
- [ ] Furnace opening is centered vertically and scales with playarea (20% height)
- [ ] Shovel follows mouse but stays within playarea bounds

---

## Files Modified

- `level1/furnace.gd` - Added coal pile and furnace setup, shovel input handling
- `level1/furnace.tscn` - Added CoalPile, FurnaceWall, Shovel nodes

## Files Created

- `level1/coal_physics_material.tres` - Shared coal physics material
- `level1/shovel_physics_material.tres` - Shared shovel physics material
- `level1/shovel.gd` - Shovel behavior script

---

## Common Issues & Prevention

### Resource UID Warnings
When creating .tscn files with ext_resource references, always include UIDs:
```
# WRONG - missing UID
[ext_resource type="PackedScene" path="res://level1/scene_template.tscn" id="1_furnace_template"]

# CORRECT - includes UID
[ext_resource type="PackedScene" uid="uid://drfp4vl2w1wvr" path="res://level1/scene_template.tscn" id="1_furnace_template"]
```

**How to get UIDs:**
- Open the referenced scene in Godot editor
- Check the .tscn file header for its UID
- Copy the UID to your ext_resource line

**Why this matters:** Godot will show warnings about falling back to text-based paths without UIDs, though it will still work.

### GDScript Type Conversions
When using `deg_to_rad()` with clamped values, the result is already a float:
```gdscript
# This is fine - clamp returns float when limits are floats
rotation = deg_to_rad(clamp(current_rotation_deg, -MAX_ROTATION_DEGREES, MAX_ROTATION_DEGREES))
```

If you see narrowing conversion warnings, ensure your constants are floats:
```gdscript
# CORRECT
const MAX_ROTATION_DEGREES: float = 45.0  # Note the .0

# WRONG (causes int->float narrowing)
const MAX_ROTATION_DEGREES = 45
```

---

## Notes

**Why RigidBody2D for shovel?**
- Allows physics-based rotation while position follows mouse
- Friction with coal RigidBody2D works properly (AnimatableBody2D friction is unreliable)
- Enables natural tilting mechanic with torque and angular damping
- High mass (50.0) prevents coal from pushing it around
- Position is directly set each frame, but rotation is physics-based

**Why 3-segment line collision (bowl shape)?**
- Creates concave bowl shape using 3 line segments (left wall, bottom, right wall)
- RigidBody2D collision polygons must be convex, so single polygon can't create bowl
- Multiple SegmentShape2D allows concave shape that contains coal better
- Angled side walls prevent coal from rolling off easily
- Bottom width (36 units) provides stable resting surface
- Visual curve remains aesthetic, collision provides functional containment

**CRITICAL: Why velocity-based movement instead of direct position setting?**
- **Direct position setting breaks physics collision**: Setting `global_position = mouse_pos` every frame teleports the body
- Teleporting causes the physics engine to skip collision resolution
- Coal falls through shovel because collision happens, then immediately gets overridden by position reset
- **Velocity-based movement preserves physics**: `linear_velocity = direction * FOLLOW_SPEED * delta`
- Physics engine properly detects and resolves collisions when using velocity
- Coal lands on shovel and interacts via friction/physics materials correctly
- This is the ONLY way to have both mouse-following AND proper collision

**Tuning values:**
- FOLLOW_SPEED (3000.0): How fast shovel moves toward mouse - lower = slower, higher = more responsive
- linear_damp (15.0): How fast shovel stops - higher = more responsive, lower = floatier
- mass (20.0): Shovel weight - heavy enough to resist coal pushing it around
- TILT_TORQUE (108000.0): Rotation speed when holding mouse buttons - lower = slower rotation, higher = faster
- angular_damp (2.0): Rotation dampening - higher = stops rotating faster, lower = spins longer
- MAX_ROTATION_DEGREES (45.0): Maximum tilt angle - lower = less tilt allowed, higher = more tilt
- BOUNCE_BACK_TORQUE (200.0): Resistance when hitting max tilt - higher = harder bounce, lower = softer

**Tilt Mechanic Design**
- Hold-based input (not click-based) for smooth, continuous rotation control
- Left mouse = counter-clockwise torque, Right mouse = clockwise torque
- Input tracked in furnace.gd (_input sets left_mouse_held/right_mouse_held flags)
- Torque applied continuously in _process() while flags are true, scaled by delta
- Rotation clamped in shovel.gd _physics_process() to enforce ±45° limit with bounce-back
- Very high torque (108000.0) ensures rotation is responsive despite heavy mass (20.0)
- Creates skill-based gameplay: tilt too much = coal slides off, tilt just right = coal stays on

**Why 40px obstacle thickness?**
- Max expected velocity: 2000 px/sec
- Physics tick: 60Hz (16.67ms)
- Max distance per frame: 2000 / 60 = 33.33px
- Add 20% margin: 33.33 * 1.2 = 40px
- Prevents tunneling (coal phasing through obstacles)

**Why await get_tree().process_frame before setup?**
- ResponsiveLayout.apply_to_scene() needs one frame to calculate PlayArea size
- Without await, playarea.size returns zero, causing objects to be positioned incorrectly
- Deferring setup ensures all layout calculations are complete

**Why percentage-based furnace opening?**
- Absolute pixel values (200px) don't scale properly across resolutions
- Using 20% of playarea height ensures consistent proportions
- Gap remains appropriately sized on all screen sizes

**Why constrain shovel to playarea?**
- Prevents shovel from moving into menu/UI areas
- Keeps gameplay contained within the designated play space
- Uses get_global_rect() and clamp() for smooth boundary enforcement

**Why z_index 0 and 1 instead of -1 and 0?**
- Negative z_index values don't layer correctly in this context
- Using z_index 0 for outline and z_index 1 for main line ensures proper ordering
- Higher z_index draws on top, so black line (z_index 1) appears over gray outline (z_index 0)

**Why 80% gray instead of white/darker grays?**
- White outline was too visually striking and distracting
- 20% gray was too dark and didn't provide enough contrast
- 80% gray (Color(0.8, 0.8, 0.8)) provides clear visibility against black background
- Light gray creates good contrast without being overwhelming

**Next Phase**: Phase 2.2.2 will create coal pieces and implement the scooping mechanism.
