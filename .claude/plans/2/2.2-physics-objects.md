# Physics Objects

**Goal**: Create the physical environment for shovelling gameplay - coal pile, furnace opening with obstacles, and shovel surface.

**Success Criteria**:
- Coal pile visual and scoop detection area rendered in bottom-left
- Furnace opening with physical obstacles rendered on right side
- Shovel follows mouse as RigidBody2D with collision surface and tilt physics
- Left/Right click controls shovel tilt (balancing mechanic)
- PhysicsMaterials created programmatically using Level1Vars values
- All physics values reference Level1Vars for runtime upgradability
- All elements visible and positioned correctly

## Overview

This phase establishes the static physical environment for the shovelling mechanic. No coal spawning or tracking yet - just the physical objects that coal will interact with. The shovel follows the mouse with physics-based rotation that can be controlled via left/right click for balancing. The furnace has collision obstacles but no delivery detection.

**Dependencies**:
- Requires [2.x-scene-network.md](2.x-scene-network.md) for scene structure
- Requires [1.x-level-1-variables-autoload.md](../1/1.x-level-1-variables-autoload.md) for physics variables
- Modifies existing `level1/furnace.tscn` and `level1/furnace.gd`

---

## Implementation Tasks

### 1. Coal Pile Visual and Detection Area

Position a coal pile in the bottom-left of the playarea with an Area2D for scoop detection.

**In furnace.tscn:**
- Add Node2D named "CoalPile" under playarea
- Add Polygon2D child for visual (filled black/dark gray polygon)
- Add Area2D child named "CoalPileArea"
- Add CircleShape2D to Area2D (radius: 100px)

**In furnace.gd:**
```gdscript
@onready var coal_pile_area: Area2D = $AspectContainer/MainContainer/mainarea/PlayArea/CoalPile/CoalPileArea
@onready var playarea: Control = $AspectContainer/MainContainer/mainarea/PlayArea

var coal_pile_position: Vector2
var coal_pile_radius: float = 100.0

func _ready():
    ResponsiveLayout.apply_to_scene(self)  # REQUIRED
    connect_navigation()
    # Defer physics setup until after layout is applied
    await get_tree().process_frame
    setup_physics_objects()

func setup_physics_objects():
    # Get playarea size
    var playarea_size = playarea.size

    # Calculate coal pile position (bottom-left corner)
    coal_pile_position = Vector2(100, playarea_size.y - 100)

    # Position coal pile
    $AspectContainer/MainContainer/mainarea/PlayArea/CoalPile.position = coal_pile_position
```

**Visual design:**
- Shape: Irregular polygon resembling a mound
- Color: Dark gray or black (#2a2a2a)
- Size: ~100px radius
- Position: Bottom-left, approximately (100, viewport_height - 100)

### 2. Furnace Opening with Physical Obstacles

Create vertical line on right side with physical obstacles above/below the opening.

**In furnace.tscn:**
- Add Node2D named "FurnaceWall" under playarea
- Add Line2D child named "TopLine" for visual line (top segment)
- Add Line2D child named "BottomLine" for visual line (bottom segment)
- Add StaticBody2D named "TopObstacle"
- Add CollisionShape2D with RectangleShape2D (15px thick)
- Add StaticBody2D named "BottomObstacle"
- Add CollisionShape2D with RectangleShape2D (15px thick)

**In furnace.gd:**
```gdscript
@onready var furnace_wall: Node2D = $AspectContainer/MainContainer/mainarea/PlayArea/FurnaceWall

var furnace_line_x: float
var furnace_opening_top: float
var furnace_opening_bottom: float

func setup_physics_objects():
    # ... (previous coal pile setup)

    # Calculate furnace positions (use Level1Vars for upgradable opening size)
    var furnace_opening_height = playarea_size.y * Level1Vars.furnace_opening_height_percent
    furnace_line_x = playarea_size.x - 50
    furnace_opening_top = (playarea_size.y / 2) - (furnace_opening_height / 2)
    furnace_opening_bottom = furnace_opening_top + furnace_opening_height

    # Position furnace wall
    furnace_wall.position.x = furnace_line_x

    # Setup vertical line visual with gap (draw top and bottom segments)
    var top_line = furnace_wall.get_node("TopLine")
    top_line.points = PackedVector2Array([
        Vector2(0, 0),
        Vector2(0, furnace_opening_top)
    ])
    top_line.default_color = Color.BLACK
    top_line.width = 15.0

    var bottom_line = furnace_wall.get_node("BottomLine")
    bottom_line.points = PackedVector2Array([
        Vector2(0, furnace_opening_bottom),
        Vector2(0, playarea_size.y)
    ])
    bottom_line.default_color = Color.BLACK
    bottom_line.width = 15.0

    # Position top obstacle
    var top_obstacle = furnace_wall.get_node("TopObstacle/CollisionShape2D")
    var top_height = furnace_opening_top
    top_obstacle.position = Vector2(0, top_height / 2)
    top_obstacle.shape.size = Vector2(15, top_height)

    # Position bottom obstacle
    var bottom_obstacle = furnace_wall.get_node("BottomObstacle/CollisionShape2D")
    var bottom_height = playarea_size.y - furnace_opening_bottom
    bottom_obstacle.position = Vector2(0, furnace_opening_bottom + (bottom_height / 2))
    bottom_obstacle.shape.size = Vector2(15, bottom_height)
```

**Design values:**
- Furnace line X: playarea_width - 50px
- Opening height: Level1Vars.furnace_opening_height_percent (default 0.20 = 20% of playarea height)
- Opening center: playarea_height / 2
- Obstacle thickness: 15px (matches visual line width)

### 3. Shovel Physical Surface

Create RigidBody2D that follows mouse position with physics-based tilt control.

**In furnace.tscn:**
- Add Node2D named "Shovel" under playarea
- Add RigidBody2D child
- Add 3 CollisionShape2D nodes with SegmentShape2D to form bowl:
  - "LeftWall": line from (-40, -6) to (-18, 7)
  - "BottomWall": line from (-18, 7) to (18, 7)
  - "RightWall": line from (18, 7) to (40, -6)
- Add Line2D child named "OutlineLine2D" for gray outline (10px thick, 80% gray)
- Add Line2D child named "Line2D" for black curve (6px thick)

**Create new file: res://level1/shovel.gd**
```gdscript
extends RigidBody2D

const SHOVEL_WIDTH: float = 80.0

var shovel_curve: PackedVector2Array
var line_2d: Line2D
var outline_line: Line2D
var scoop_cooldown_timer: float = 0.0
var playarea: Control

func _ready():
    # Get reference to playarea (parent's parent)
    playarea = get_parent().get_parent()

    # RigidBody2D physics setup (use Level1Vars for upgradable values)
    lock_rotation = false  # Allow rotation for tilt mechanic
    mass = Level1Vars.shovel_mass
    gravity_scale = 0.0  # No gravity
    linear_damp = Level1Vars.shovel_linear_damp
    angular_damp = Level1Vars.shovel_angular_damp

    # Collision layers
    collision_layer = 2
    collision_mask = 1 | 4  # World (layer 1) + coal (layer 3)

    # Define shovel visual curve (for aesthetics only)
    # Pivot point is at y=0, which is halfway up the slanted sides
    shovel_curve = PackedVector2Array([
        Vector2(-40, -6),   # Left edge, slightly raised
        Vector2(-20, 4),    # Left-center, deeper
        Vector2(0, 7),      # Center, deepest point
        Vector2(20, 4),     # Right-center, deeper
        Vector2(40, -6)     # Right edge, slightly raised
    ])

    # Setup outline (gray, thicker) - draws first (behind)
    outline_line = get_node("OutlineLine2D")
    outline_line.points = shovel_curve
    outline_line.default_color = Color(0.8, 0.8, 0.8)  # 80% gray
    outline_line.width = 10.0
    outline_line.z_index = 0

    # Setup main line (black, thinner) - draws second (in front)
    line_2d = get_node("Line2D")
    line_2d.points = shovel_curve
    line_2d.default_color = Color.BLACK
    line_2d.width = 6.0
    line_2d.z_index = 1

    # Create physics material programmatically (upgradable at runtime)
    var physics_mat = PhysicsMaterial.new()
    physics_mat.friction = Level1Vars.shovel_friction
    physics_mat.bounce = Level1Vars.shovel_bounce
    physics_material_override = physics_mat

func _physics_process(delta):
    # Get mouse position
    var mouse_pos = get_global_mouse_position()

    if playarea:
        var playarea_rect = playarea.get_global_rect()
        mouse_pos.x = clamp(mouse_pos.x, playarea_rect.position.x, playarea_rect.position.x + playarea_rect.size.x)
        mouse_pos.y = clamp(mouse_pos.y, playarea_rect.position.y, playarea_rect.position.y + playarea_rect.size.y)

    # Calculate direction to mouse
    var direction = mouse_pos - global_position

    # Set velocity toward mouse (CRITICAL: velocity-based, not direct position)
    linear_velocity = direction * Level1Vars.shovel_follow_speed

    # Clamp rotation to max angle (use Level1Vars for upgradable limit)
    var current_rotation_deg = rad_to_deg(rotation)
    if abs(current_rotation_deg) > Level1Vars.shovel_max_rotation_degrees:
        # Clamp rotation
        rotation = deg_to_rad(clamp(current_rotation_deg, -Level1Vars.shovel_max_rotation_degrees, Level1Vars.shovel_max_rotation_degrees))
        # Apply bounce back torque in opposite direction
        var bounce_direction = -sign(current_rotation_deg)
        apply_torque_impulse(bounce_direction * Level1Vars.shovel_bounce_back_torque)

    # Update cooldown timer
    if scoop_cooldown_timer > 0.0:
        scoop_cooldown_timer -= delta

func tilt_left(delta: float):
    # Apply counter-clockwise torque (negative in Godot)
    # Scale by delta for consistent speed regardless of framerate
    apply_torque_impulse(-Level1Vars.shovel_tilt_torque * delta)

func tilt_right(delta: float):
    # Apply clockwise torque (positive in Godot)
    # Scale by delta for consistent speed regardless of framerate
    apply_torque_impulse(Level1Vars.shovel_tilt_torque * delta)
```

**In furnace.tscn:**
- Attach shovel.gd script to RigidBody2D node

**In furnace.gd:**

Add `@onready var shovel_body` reference at the top:
```gdscript
@onready var shovel_body: RigidBody2D = $AspectContainer/MainContainer/mainarea/PlayArea/Shovel/RigidBody2D
```

Add mouse button tracking variables (after other variable declarations):
```gdscript
# Track which mouse button is held
var left_mouse_held: bool = false
var right_mouse_held: bool = false
```

Add input handling function:
```gdscript
func _input(event):
    if event is InputEventMouseButton:
        if event.button_index == MOUSE_BUTTON_LEFT:
            left_mouse_held = event.pressed
        elif event.button_index == MOUSE_BUTTON_RIGHT:
            right_mouse_held = event.pressed
```

Update _process() to apply tilt torque while buttons held:
```gdscript
func _process(delta):
    # Apply continuous tilt torque while mouse buttons are held
    if left_mouse_held:
        shovel_body.tilt_left(delta)
    if right_mouse_held:
        shovel_body.tilt_right(delta)
```

---

## Testing Checklist

### Visual Tests
- [ ] Coal pile renders in bottom-left corner
- [ ] Coal pile is visually distinct (dark gray/black mound shape)
- [ ] Furnace vertical line renders on right side in two segments (TopLine and BottomLine)
- [ ] Furnace opening gap is visible and centered vertically (20% of playarea height)
- [ ] Shovel has gray outline (10px, 80% gray) and black curve (6px) - clearly visible
- [ ] Shovel follows mouse smoothly with no lag
- [ ] Shovel is constrained to playarea bounds (doesn't go outside)

### Physics Tests
- [ ] Shovel is a RigidBody2D (check in scene tree)
- [ ] Shovel has 3 collision segments forming bowl shape (LeftWall, BottomWall, RightWall)
- [ ] Collision segments create concave bowl: angled sides, flat bottom
- [ ] Shovel properties set from Level1Vars (mass, linear_damp, angular_damp)
- [ ] Default values: mass = 100.0, gravity_scale = 0.0, linear_damp = 15.0, angular_damp = 2.0
- [ ] Shovel rotation is NOT locked (lock_rotation = false)
- [ ] Furnace obstacles are StaticBody2D with collision shapes
- [ ] Obstacle thickness is 15px (matches visual line width)
- [ ] Shovel creates PhysicsMaterial programmatically in _ready()
- [ ] Shovel physics material uses Level1Vars.shovel_friction and Level1Vars.shovel_bounce
- [ ] No errors in console when running scene

### Tilt Mechanic Tests
- [ ] Holding left mouse button applies continuous counter-clockwise torque (shovel tilts left)
- [ ] Holding right mouse button applies continuous clockwise torque (shovel tilts right)
- [ ] Releasing mouse button stops applying torque (shovel rotation dampens naturally)
- [ ] Shovel rotation is clamped to +/- Level1Vars.shovel_max_rotation_degrees (default 45)
- [ ] Shovel bounces back when hitting max tilt (Level1Vars.shovel_bounce_back_torque applied)
- [ ] Shovel rotation dampens over time (Level1Vars.shovel_angular_damp working)
- [ ] Tilt torque is strong enough to rotate quickly (Level1Vars.shovel_tilt_torque default 108000.0)

### Position Tests
- [ ] Coal pile position updates based on playarea size
- [ ] Furnace line X position is playarea_width - 50
- [ ] Furnace opening is centered vertically and scales with playarea (Level1Vars.furnace_opening_height_percent)
- [ ] Default furnace opening height is 20% of playarea height
- [ ] Shovel follows mouse but stays within playarea bounds

---

## Files Modified

- `level1/furnace.gd` - Added coal pile and furnace setup, shovel input handling
- `level1/furnace.tscn` - Added CoalPile, FurnaceWall, Shovel nodes

## Files Created

- `level1/shovel.gd` - Shovel behavior script with Level1Vars integration

---

## Common Issues & Prevention

### Accessing Level1Vars Before Autoload Ready
If you get "null instance" errors when accessing Level1Vars:
```gdscript
# WRONG - accessing in _init() before autoloads are ready
func _init():
    var speed = Level1Vars.shovel_follow_speed  # ERROR: Level1Vars may not be ready

# CORRECT - access in _ready() after autoloads are initialized
func _ready():
    var speed = Level1Vars.shovel_follow_speed  # Works correctly
```

**Why this matters:** Autoloads are initialized after scene _init() but before _ready()

### GDScript Type Conversions
When using `deg_to_rad()` with clamped values, the result is already a float:
```gdscript
# This is fine - clamp returns float when limits are floats
rotation = deg_to_rad(clamp(current_rotation_deg, -Level1Vars.shovel_max_rotation_degrees, Level1Vars.shovel_max_rotation_degrees))
```

If you see narrowing conversion warnings, ensure Level1Vars variables are declared as floats:
```gdscript
# CORRECT in level_1_vars.gd
var shovel_max_rotation_degrees: float = 45.0  # Note the .0

# WRONG (causes int->float narrowing)
var shovel_max_rotation_degrees = 45
```

---

## Notes

**Why RigidBody2D for shovel?**
- Allows physics-based rotation while velocity follows mouse
- Friction with coal RigidBody2D works properly (AnimatableBody2D friction is unreliable)
- Enables natural tilting mechanic with torque and angular damping
- High mass (100.0) prevents coal from pushing it around
- Velocity-based movement preserves physics collision while rotation is physics-based

**Why 3-segment line collision (bowl shape)?**
- Creates concave bowl shape using 3 line segments (left wall, bottom, right wall)
- RigidBody2D collision polygons must be convex, so single polygon can't create bowl
- Multiple SegmentShape2D allows concave shape that contains coal better
- Angled side walls prevent coal from rolling off easily
- Bottom width (36 units) provides stable resting surface
- Visual curve remains aesthetic, collision provides functional containment

**Why pivot point at y=0 (halfway up slanted sides)?**
- Original pivot at bottom made shovel top-heavy and unstable
- Moving rotation center up to y=0 creates better balance point
- All geometry shifted down 1 unit to reposition relative to new pivot
- Rotation feels more natural around middle of slanted edges
- Reduces wobble and improves handling during gameplay

**CRITICAL: Why velocity-based movement instead of direct position setting?**
- **Direct position setting breaks physics collision**: Setting `global_position = mouse_pos` every frame teleports the body
- Teleporting causes the physics engine to skip collision resolution
- Coal falls through shovel because collision happens, then immediately gets overridden by position reset
- **Velocity-based movement preserves physics**: `linear_velocity = direction * FOLLOW_SPEED`
- DO NOT multiply by delta - linear_velocity is already in pixels/second, physics engine handles delta internally
- Physics engine properly detects and resolves collisions when using velocity
- Coal lands on shovel and interacts via friction/physics materials correctly
- This is the ONLY way to have both mouse-following AND proper collision

**Tuning values (stored in Level1Vars for runtime upgrades):**
- shovel_follow_speed (10.0): Velocity multiplier for mouse tracking - higher = more responsive/faster
- shovel_linear_damp (15.0): How fast shovel stops - higher = more responsive, lower = floatier
- shovel_mass (100.0): Shovel weight - heavy enough to resist coal pushing it around
- shovel_tilt_torque (108000.0): Rotation speed when holding mouse buttons - lower = slower rotation, higher = faster
- shovel_angular_damp (2.0): Rotation dampening - higher = stops rotating faster, lower = spins longer
- shovel_max_rotation_degrees (45.0): Maximum tilt angle - lower = less tilt allowed, higher = more tilt
- shovel_bounce_back_torque (200.0): Resistance when hitting max tilt - higher = harder bounce, lower = softer
- shovel_friction (0.7): How coal grips shovel - higher = coal sticks better
- shovel_bounce (0.1): Coal bounce off shovel - lower = less bouncy
- coal_friction (0.7): How coal grips surfaces - affects coal-to-coal and coal-to-obstacle interaction
- coal_bounce (0.15): Coal bounciness - affects how coal bounces off obstacles and shovel
- coal_radius (5.0): Coal piece size in pixels - smaller = easier to balance multiple pieces, larger = easier to see
- furnace_opening_height_percent (0.20): Target size as percentage of playarea height - lower = harder

**Tilt Mechanic Design**
- Hold-based input (not click-based) for smooth, continuous rotation control
- Left mouse = counter-clockwise torque, Right mouse = clockwise torque
- Input tracked in furnace.gd (_input sets left_mouse_held/right_mouse_held flags)
- Torque applied continuously in _process() while flags are true, scaled by delta
- Rotation clamped in shovel.gd _physics_process() to enforce ±45° limit with bounce-back
- Very high torque (108000.0) ensures rotation is responsive despite heavy mass (100.0)
- Creates skill-based gameplay: tilt too much = coal slides off, tilt just right = coal stays on

**Why 15px obstacle thickness?**
- Matches visual line width for consistency (no invisible collision zones)
- Creates predictable collision behavior - what you see is what you get
- Still prevents tunneling for expected coal velocities (coal pieces are small and slow relative to 15px)
- Reduces invisible collision frustration where coal bounces off empty air

**Why await get_tree().process_frame before setup?**
- ResponsiveLayout.apply_to_scene() needs one frame to calculate PlayArea size
- Without await, playarea.size returns zero, causing objects to be positioned incorrectly
- Without await, playarea.get_global_rect() returns pre-layout values (often negative positions)
- Deferring setup ensures all layout calculations are complete
- **CRITICAL**: Any child script (like shovel.gd) that needs playarea dimensions or position MUST also await before accessing them

**Why percentage-based furnace opening?**
- Absolute pixel values (200px) don't scale properly across resolutions
- Using Level1Vars.furnace_opening_height_percent (default 20%) ensures consistent proportions
- Gap remains appropriately sized on all screen sizes
- Stored in Level1Vars allows runtime upgrades (player can purchase larger opening)

**Why constrain shovel to playarea?**
- Prevents shovel from moving into menu/UI areas
- Keeps gameplay contained within the designated play space
- Uses get_global_rect() and clamp() for smooth boundary enforcement

**Why z_index 0 and 1 instead of -1 and 0?**
- Negative z_index values don't layer correctly in this context
- Using z_index 0 for outline and z_index 1 for main line ensures proper ordering
- Higher z_index draws on top, so black line (z_index 1) appears over gray outline (z_index 0)

**Why 80% gray instead of white/darker grays?**
- White outline was too visually striking and distracting
- 20% gray was too dark and didn't provide enough contrast
- 80% gray (Color(0.8, 0.8, 0.8)) provides clear visibility against black background
- Light gray creates good contrast without being overwhelming

**Why programmatic PhysicsMaterial creation instead of .tres files?**
- .tres files have hardcoded values that cannot be modified at runtime
- Programmatic creation (PhysicsMaterial.new()) allows reading from Level1Vars
- This enables player upgrades to improve friction/bounce values during gameplay
- Three lines of code vs separate .tres files - simpler and more flexible
- No boilerplate, easier to maintain, values clearly visible in code

**Next Phase**: Phase 2.2.2 will create coal pieces and implement the scooping mechanism.
