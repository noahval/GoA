# Offline Earnings

## Overview

This plan provides the **core offline earnings infrastructure** - timestamp verification and duration caps. It does NOT define job-specific earnings rates. Those belong to individual job plans (e.g., dishwash plan defines its own offline rate and progression).

**Core Goal**: Track offline duration, enforce caps, and trigger earnings calculation via JobBoardManager.

---

## Dependencies

- **2.x-job-board.md**: Provides `JobBoardManager` which handles job assignment and delegates to job-specific earning functions
- **1.x-nakama-server.md**: Provides server timestamp verification to prevent clock manipulation

**Note**: This plan provides the groundwork (OfflineEarningsManager singleton) that 2.x-job-board.md builds upon. Job Board calls into job-specific plans which implement their own progression systems.

---

## Core Mechanics

### Offline Cap

**Fixed Duration**: 2 hours (7200 seconds)

- No upgrades in this plan (future plan will handle overtime upgrades)
- Simple, flat cap applied to all offline sessions
- Cap enforced at calculation time, not storage time

### Server Timestamp Verification

Following the Nakama server plan (1.17), use server time instead of local device time to prevent manipulation.

**On Game Close/Save**:
```gdscript
# In NakamaClient.save_game() - already updates timestamp
Level1Vars.last_played_timestamp = Time.get_unix_time_from_system()
```

**On Game Load**:
```gdscript
# Use server time for verification
var server_time = await NakamaClient.get_server_time()
var elapsed_seconds = server_time - Level1Vars.last_played_timestamp
var capped_seconds = min(elapsed_seconds, 7200)  # 2 hour cap
```

**Note**: Server time fetching is implemented in Nakama plan. This plan just uses the API.

### Earnings Calculation

**This plan only handles**:
1. Getting elapsed time (capped)
2. Calling `JobBoardManager.process_offline_session()`
3. Displaying the welcome-back notification

**JobBoardManager (from 2.x-job-board.md) handles**:
- Which job is assigned
- Delegating to job-specific earning calculations
- Currency type determination
- Actual earnings math (via job-specific functions)

```gdscript
# Simplified flow - all job logic delegated to JobBoardManager
var elapsed_seconds = min(server_time - last_played_timestamp, OFFLINE_CAP)
var result = JobBoardManager.process_offline_session(elapsed_seconds)
# result contains: {earnings: int, currency: String, job_name: String}
```

### Notification on Return

When player returns after offline period:

```
Welcome back! You were away for 1.5 hours.

Your idle work (Dishwashing):
- Earned: 54 holes

Tip: Wash more mugs to improve your idle rate!
```

If no idle job assigned:
```
Welcome back! You were away for 1.5 hours.

You didn't have an idle job assigned.
Visit the Job Board to set one up!
```

If exceeded cap:
```
Welcome back! You were away for 3.2 hours (capped at 2 hours).

Your idle work (Dishwashing):
- Earned: 72 holes

You hit your offline cap! (Future: Upgrade overtime limit)
```

---

## Implementation Steps

### Step 1: Add Server Time API to NakamaClient

**File**: `nakama_client.gd`

```gdscript
# Fetch current server time (Unix timestamp)
func get_server_time() -> int:
    if not is_authenticated:
        DebugLogger.error("Cannot get server time: Not authenticated")
        return Time.get_unix_time_from_system()  # Fallback to local time

    # Use Nakama's built-in server time RPC
    var result = await client.rpc_async(session, "get_server_time", "{}")

    if result.is_exception():
        DebugLogger.error("Server time fetch failed: " + result.get_exception().message)
        return Time.get_unix_time_from_system()  # Fallback

    var payload = JSON.parse_string(result.payload)
    return int(payload.get("server_time", Time.get_unix_time_from_system()))
```

**Note**: Nakama server already provides server time. This is just the client wrapper.

### Step 2: Offline Earnings Manager

**File**: `offline_earnings_manager.gd` (singleton autoload)

**Responsibilities**:
- Fetch server time
- Calculate elapsed duration (with cap)
- Update last_played_timestamp
- Call JobBoardManager for earnings (all job logic lives there)
- Show welcome-back notification

```gdscript
extends Node

const OFFLINE_CAP_SECONDS = 7200  # 2 hours

func process_offline_earnings():
    var server_time = await NakamaClient.get_server_time()

    if Level1Vars.last_played_timestamp == 0:
        Level1Vars.last_played_timestamp = server_time
        return

    var elapsed_seconds = server_time - Level1Vars.last_played_timestamp
    var capped_seconds = min(elapsed_seconds, OFFLINE_CAP_SECONDS)
    Level1Vars.last_played_timestamp = server_time

    # Delegate all job logic to JobBoardManager
    var result = JobBoardManager.process_offline_session(capped_seconds)
    _show_notification(elapsed_seconds, capped_seconds, result)

func _show_notification(elapsed: int, capped: int, result: Dictionary):
    var hours = elapsed / 3600.0
    var exceeded = elapsed > OFFLINE_CAP_SECONDS

    var message = "Welcome back! You were away for %.1f hours" % hours
    if exceeded:
        message += " (capped at %.1f hours)" % (capped / 3600.0)
    message += ".\n\n"

    if result.is_empty():
        message += "You didn't have an idle job assigned.\n"
        message += "Visit the Job Board to set one up!"
    else:
        message += "Your idle work (%s):\n" % result.job_name
        message += "- Earned: %d %s\n\n" % [result.earnings, result.currency]
        if exceeded:
            message += "You hit your offline cap!"
        else:
            message += "Tip: Play actively to improve your idle rate!"

    Global.show_stat_notification(message)
```

### Step 3: Integration with Game Load

**File**: `level1/loading_screen.gd` (or wherever game load happens)

```gdscript
func _ready():
    # Load save data first
    await NakamaClient.load_game()

    # Process offline earnings (uses server time)
    await OfflineEarningsManager.process_offline_earnings()

    # ... rest of loading logic
```

### Step 4: Register Autoload

**File**: `project.godot`

```
[autoload]
OfflineEarningsManager="*res://offline_earnings_manager.gd"
```

---

## Files Created

- `offline_earnings_manager.gd` - Singleton for offline earnings calculation

## Files Modified

- `nakama_client.gd` - Add `get_server_time()` method
- `level1/loading_screen.gd` - Call offline earnings on game load
- `project.godot` - Register OfflineEarningsManager autoload

---

## Testing Checklist

### Manual Tests

- [ ] Close game for 30 minutes with dishwashing assigned, verify earnings on return
- [ ] Close game for 3 hours, verify capped at 2 hours worth of earnings
- [ ] Close game with no idle job assigned, verify no earnings notification
- [ ] Verify notification shows correct elapsed time
- [ ] Verify notification shows correct earnings amount
- [ ] Verify exceeded cap message appears when over 2 hours
- [ ] Test with invalid/missing job assignment (edge case)

### Server Time Verification

- [ ] Verify server time is used (not local device time)
- [ ] Test with device clock set forward (should use server time)
- [ ] Test with device clock set backward (should use server time)
- [ ] Verify fallback to local time if server unreachable

---

## Success Criteria

- [ ] OfflineEarningsManager singleton created and registered
- [ ] Server time fetched via NakamaClient (not local clock)
- [ ] Elapsed time capped at 2 hours
- [ ] `JobBoardManager.process_offline_session()` called with capped seconds
- [ ] Notification displays elapsed time and cap info
- [ ] Notification shows earnings result from JobBoardManager (or no-job message)
- [ ] Fallback to local time if server unreachable

---

## Future Enhancements

**Not included in this plan:**

- **Overtime Upgrades**: Separate plan will handle extending 2-hour cap
- **Multiple Workers**: Hiring workers to idle multiple jobs simultaneously
- **Efficiency Upgrades**: Generic efficiency bonuses (separate from per-job mastery)

---

## Notes

### Design Decisions

**Why 2-hour flat cap?**
- Simple baseline before upgrades unlock
- Reasonable for short breaks/sleep
- Easy to understand and communicate
- Future plan handles overtime progression

**Why server time verification?**
- Prevents local clock manipulation
- Maintains fair progression
- Already implemented in Nakama plan (1.17)
- Graceful fallback to local time if server unreachable

**Why no minimum offline time?**
- Removed based on user feedback
- Any offline time counts (even 1 minute)
- Simpler logic, better UX

**Why no job-specific logic here?**
- Each job defines its own idle rate and progression
- Dishwashing plan handles dishwash-specific idle rate (via mugs_washed)
- Keeps this plan focused on cap/timestamp logic

### Separation of Concerns

| This Plan (2.17 Offline Earnings) | Job Board Plan (2.x-job-board.md) | Job Plans (e.g., 2.19.8 Dishwash) |
|-----------------------------------|-----------------------------------|-----------------------------------|
| Server timestamp verification | Job assignment (`current_idle_job`) | Job-specific progression systems |
| Duration cap (2 hours) | Routing to job-specific functions | Idle earning rate calculations |
| OfflineEarningsManager singleton | Job unlocking/discovery | Currency type per job |
| Welcome-back notification UI | Navigation to job scenes | Active play → idle rate improvement |
| Fallback to local time | | |

**Call Flow**: Game Load → OfflineEarningsManager → JobBoardManager → Job-specific function → Currency awarded

---

**Last Updated**: 2026-01-15
