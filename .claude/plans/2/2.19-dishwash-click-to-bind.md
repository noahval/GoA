# Dishwash: Click-to-Bind System

**Goal**: Implement click-to-pick-up and click-to-place mug interaction

**Success Criteria**: Player can click dirty stack to bind mug to cursor, move it around, and click rack to place it

**Builds on**: [2.18-dishwash-scene-setup.md](2.18-dishwash-scene-setup.md) (scene structure, nodes, positioning)

## Overview

Adds click handling to the scene structure from 2.18. Clicking the dirty stack binds a mug to the cursor, the mug follows mouse position, and clicking the rack unbinds it. No state validation yet - any mug can be placed on the rack.

### Key Design Principles

- Click dirty stack once to bind (not drag-and-hold)
- Mug follows cursor position automatically in _process()
- Click rack to unbind (no error checking yet)
- Prevent binding multiple mugs simultaneously

---

## Implementation Tasks

### 1. Add Script Variables

Add to `dishwash_minigame.gd`:

```gdscript
# Mug binding state
var mug_bound_to_cursor: bool = false

# Node references (scene structure from 2.18)
@onready var bound_mug = $BoundMug
@onready var dirty_stack = $DirtyStack
@onready var drying_rack = $DryingRack
@onready var error_notification = $ErrorNotification

# Texture preloads
const MUG_DIRTY_TEXTURE = preload("res://level1/icons/mug-dirty.png")
```

### 2. Connect Area2D Signals

Add to `_ready()` after `setup_element_positions()`:

```gdscript
# Click detection signals (Area2D nodes from 2.18)
dirty_stack.input_event.connect(_on_dirty_stack_clicked)
drying_rack.input_event.connect(_on_rack_clicked)
```

### 3. Add Process Loop

Add `_process()` function:

```gdscript
func _process(_delta):
	if not visible:
		return

	if mug_bound_to_cursor:
		bound_mug.global_position = get_global_mouse_position()
```

### 4. Add Click Handlers

```gdscript
func _on_dirty_stack_clicked(_viewport, event, _shape_idx):
	if event is InputEventMouseButton and event.pressed and event.button_index == MOUSE_BUTTON_LEFT:
		if not mug_bound_to_cursor:
			bind_mug_to_cursor()
		else:
			show_error_notification("Finish current mug first!")

func _on_rack_clicked(_viewport, event, _shape_idx):
	if event is InputEventMouseButton and event.pressed and event.button_index == MOUSE_BUTTON_LEFT:
		if mug_bound_to_cursor:
			unbind_mug()  # No validation yet - always succeeds
```

### 5. Add Bind/Unbind Functions

```gdscript
func bind_mug_to_cursor():
	mug_bound_to_cursor = true
	bound_mug.visible = true
	bound_mug.texture = MUG_DIRTY_TEXTURE
	bound_mug.scale = Vector2(0.3, 0.3)  # Slightly larger than stack mugs (0.25)
	bound_mug.global_position = get_global_mouse_position()

func unbind_mug():
	mug_bound_to_cursor = false
	bound_mug.visible = false

func show_error_notification(message: String):
	error_notification.text = message
	error_notification.visible = true
	await get_tree().create_timer(1.0).timeout
	error_notification.visible = false
```

### 6. Update stop_washing()

Modify existing `stop_washing()` to clean up bound mug:

```gdscript
func stop_washing():
	# Clean up if mug is currently bound
	if mug_bound_to_cursor:
		unbind_mug()

	visible = false
	wash_mugs_button.visible = true
	stop_washing_button.visible = false
```

---

## Testing Strategy

### Manual Test Criteria

- [ ] Clicking dirty stack binds mug to cursor
- [ ] Mug appears at mouse position with dirty texture
- [ ] Mug follows cursor smoothly as mouse moves
- [ ] Bound mug is slightly larger than stack mugs (0.3 vs 0.25 scale)
- [ ] Clicking rack while mug bound unbinds mug (mug disappears)
- [ ] Can repeat cycle: click stack -> move -> click rack
- [ ] Clicking stack while mug already bound shows "Finish current mug first!" error
- [ ] Error notification appears for 1 second then disappears
- [ ] Clicking "Stop washing" while mug bound cleans up correctly
- [ ] Mug renders above all other elements (z_index 100 from 2.18)

---

## Files to Modify

- `c:\Goa\game\v0.1\level1\dishwash_minigame.gd` - Add click handling logic

**Note**: Scene structure (BoundMug, Area2D nodes, collision shapes) already created in 2.18.

---

## Notes & Decisions

**Decision: Click once to bind, not drag-and-hold**
- Rationale: Simpler input model, no accidental drops from mouse button release

**Decision: No state validation on rack placement yet**
- Rationale: State machine comes in 2.20
- This plan focuses only on binding/unbinding mechanic

**Decision: Error notification only for double-bind**
- Rationale: "Finish current mug first!" is the only error case without state validation
- Other errors ("Clean it first!", "Dry it first!") added in 2.22 when state exists

**Decision: global_position for cursor tracking**
- Rationale: Mouse position is in viewport coordinates
- global_position ensures mug follows regardless of parent transforms

---

**Last Updated**: 2026-01-14
