# 1.19 Nakama Server Integration Plan

## Overview
Build a clean, minimal Nakama client from scratch for cloud save functionality in the GoA rewrite. This replaces the v1 implementation with a simpler, more maintainable architecture.

## Purpose
Create a simple cloud backend connection that:
- Authenticates players (device ID, username/password, Google OAuth)
- Saves/loads game state to cloud storage
- Handles offline gracefully (no server = offline mode)
- Provides a framework for adding save data fields as development progresses

## Server Infrastructure
- **Server**: Nakama 3.x (will be migrated to new URL before implementation)
- **Plugin**: `addons/com.heroiclabs.nakama/` (Godot plugin)
- **Database**: PostgreSQL
- **Protocol**: HTTPS (port 443)
- **Note**: Server configuration (URL, key) will be finalized during implementation

---

## Part 1: Core Client Architecture

### 1.1 Create nakama_client.gd Autoload
Clean, minimal autoload script with only essential features.

**File**: `nakama_client.gd`

**Core Components**:
```gdscript
extends Node

# Nakama objects
var client: NakamaClient
var session: NakamaSession

# Server config (values TBD during implementation)
const SERVER_KEY = ""  # Set during implementation
const SERVER_HOST = ""  # Set during implementation
const SERVER_PORT = 443
const SERVER_SCHEME = "https"

# Auth state
var is_authenticated = false
var user_id = ""
var username = ""

# Signals
signal authentication_succeeded(session_data)
signal authentication_failed(error_message)
```

**Key Principles**:
- Keep it simple - only what's necessary
- No socket connection (not needed for single-player)
- No deprecated functions
- Clean error handling

### 1.2 Initialize Client
Basic client setup on ready:
```gdscript
func _ready():
	_initialize_client()

func _initialize_client():
	client = Nakama.create_client(
		SERVER_KEY,
		SERVER_HOST,
		SERVER_PORT,
		SERVER_SCHEME
	)
```

---

## Part 2: Authentication Methods

### 2.1 Device ID Authentication
Simplest auth - automatic, no user input required.

**Purpose**: Default auth method for players who skip login.

**Implementation**:
```gdscript
func authenticate_device() -> bool:
	var device_id = OS.get_unique_id()
	var auth_result = await client.authenticate_device_async(
		device_id,
		null,
		true,  # Create account if doesn't exist
		{}
	)

	if auth_result.is_exception():
		var error = auth_result.get_exception().message
		authentication_failed.emit(error)
		return false

	session = auth_result as NakamaSession
	_set_auth_state(session)
	authentication_succeeded.emit(_get_session_data())
	return true
```

### 2.2 Username/Password Authentication
For players who want persistent accounts.

**Purpose**: Manual account creation and login.

**Implementation**:
```gdscript
func authenticate_email(username_input: String, password: String, create_account: bool) -> bool:
	# Use custom auth with hashed password for unique ID
	var custom_id = username_input + ":" + password.sha256_text()

	var auth_result = await client.authenticate_custom_async(
		custom_id,
		username_input,
		create_account
	)

	if auth_result.is_exception():
		var error = auth_result.get_exception().message
		authentication_failed.emit(error)
		return false

	session = auth_result as NakamaSession
	_set_auth_state(session)
	authentication_succeeded.emit(_get_session_data())
	return true
```

### 2.3 Google OAuth (Web Builds Only)
For web players using Google accounts.

**Purpose**: SSO for web builds.

**Implementation**:
```gdscript
func authenticate_google(google_token: String) -> bool:
	var auth_result = await client.authenticate_google_async(
		google_token,
		null,
		true,  # Create account if doesn't exist
		{}
	)

	if auth_result.is_exception():
		var error = auth_result.get_exception().message
		authentication_failed.emit(error)
		return false

	session = auth_result as NakamaSession
	_set_auth_state(session)
	authentication_succeeded.emit(_get_session_data())
	return true
```

### 2.4 Helper Functions
```gdscript
func _set_auth_state(nakama_session: NakamaSession):
	is_authenticated = true
	user_id = nakama_session.user_id
	username = nakama_session.username

func _get_session_data() -> Dictionary:
	return {
		"user_id": user_id,
		"username": username,
		"session": session
	}
```

---

## Part 3: Cloud Storage Framework

### 3.1 Generic Storage API
Low-level read/write for any data.

**Write Storage**:
```gdscript
func write_storage(collection: String, key: String, value: Dictionary):
	if not is_authenticated:
		return null

	var write_object = NakamaWriteStorageObject.new(
		collection,
		key,
		2,  # Read permission: owner only
		1,  # Write permission: owner only
		JSON.stringify(value),
		""
	)

	var result = await client.write_storage_objects_async(session, [write_object])

	if result.is_exception():
		return null

	return result
```

**Read Storage**:
```gdscript
func read_storage(collection: String, key: String):
	if not is_authenticated:
		return null

	var storage_id = NakamaStorageObjectId.new(collection, key, user_id)
	var result = await client.read_storage_objects_async(session, [storage_id])

	if result.is_exception():
		return null

	if result.objects.size() > 0:
		return JSON.parse_string(result.objects[0].value)

	return null
```

### 3.2 Game Save/Load Functions
High-level functions for full game state.

**Save Game**:
```gdscript
func save_game() -> bool:
	if not is_authenticated:
		return false

	var save_data = {
		"version": "2.0",  # Game version for save compatibility
		"timestamp": Time.get_unix_time_from_system(),
		"global": _get_global_data(),
		"level1_vars": _get_level1_vars_data()
	}

	var result = await write_storage("player_data", "game_save", save_data)
	return result != null
```

**Load Game**:
```gdscript
func load_game() -> bool:
	if not is_authenticated:
		return false

	var save_data = await read_storage("player_data", "game_save")

	if not save_data:
		return false

	if not save_data.has("global") or not save_data.has("level1_vars"):
		return false

	_set_global_data(save_data.global)
	_set_level1_vars_data(save_data.level1_vars)

	return true
```

### 3.3 User Settings Save/Load
User preferences (UI scale, volume, etc.) saved separately from game progress.

**Purpose**: Settings persist across save file wipes and new games.

**Save Settings**:
```gdscript
func save_settings() -> bool:
	if not is_authenticated:
		return false

	var settings_data = {
		"version": "2.0",
		"timestamp": Time.get_unix_time_from_system(),
		"settings": _get_settings_data()
	}

	var result = await write_storage("player_data", "user_settings", settings_data)
	return result != null
```

**Load Settings**:
```gdscript
func load_settings() -> bool:
	if not is_authenticated:
		return false

	var settings_data = await read_storage("player_data", "user_settings")

	if not settings_data:
		return false

	if settings_data.has("settings"):
		_set_settings_data(settings_data.settings)
		return true

	return false
```

---

## Part 4: Save Data Framework

### 4.1 Global Data Serialization
**Framework for adding Global.gd variables to cloud saves**.

**Get Global Data**:
```gdscript
func _get_global_data() -> Dictionary:
	return {
		# Stats
		"strength": Global.strength,
		"constitution": Global.constitution,
		"dexterity": Global.dexterity,
		"wisdom": Global.wisdom,
		"intelligence": Global.intelligence,
		"charisma": Global.charisma,

		# Experience
		"strength_exp": Global.strength_exp,
		"constitution_exp": Global.constitution_exp,
		"dexterity_exp": Global.dexterity_exp,
		"wisdom_exp": Global.wisdom_exp,
		"intelligence_exp": Global.intelligence_exp,
		"charisma_exp": Global.charisma_exp,

		# ADD MORE GLOBAL VARIABLES HERE AS NEEDED
	}
```

**Set Global Data**:
```gdscript
func _set_global_data(data: Dictionary) -> void:
	# Stats
	Global.strength = data.get("strength", 1.0)
	Global.constitution = data.get("constitution", 1.0)
	Global.dexterity = data.get("dexterity", 1.0)
	Global.wisdom = data.get("wisdom", 1.0)
	Global.intelligence = data.get("intelligence", 1.0)
	Global.charisma = data.get("charisma", 1.0)

	# Experience
	Global.strength_exp = data.get("strength_exp", 0.0)
	Global.constitution_exp = data.get("constitution_exp", 0.0)
	Global.dexterity_exp = data.get("dexterity_exp", 0.0)
	Global.wisdom_exp = data.get("wisdom_exp", 0.0)
	Global.intelligence_exp = data.get("intelligence_exp", 0.0)
	Global.charisma_exp = data.get("charisma_exp", 0.0)

	# ADD MORE GLOBAL VARIABLES HERE AS NEEDED
```

### 4.2 Level1Vars Data Serialization
**Framework for adding Level1Vars.gd variables to cloud saves**.

**Get Level1Vars Data**:
```gdscript
func _get_level1_vars_data() -> Dictionary:
	return {
		# Currency
		"currency": Level1Vars.currency,
		"lifetime_currency": Level1Vars.lifetime_currency,

		# Resources
		"coal": Level1Vars.coal,

		# ADD MORE LEVEL1VARS VARIABLES HERE AS NEEDED
	}
```

**Set Level1Vars Data**:
```gdscript
func _set_level1_vars_data(data: Dictionary) -> void:
	# Currency
	Level1Vars.currency = data.get("currency", {"copper": 0.0, "silver": 0.0, "gold": 0.0, "platinum": 0.0})
	Level1Vars.lifetime_currency = data.get("lifetime_currency", {"copper": 0.0, "silver": 0.0, "gold": 0.0, "platinum": 0.0})

	# Resources
	Level1Vars.coal = data.get("coal", 0.0)

	# ADD MORE LEVEL1VARS VARIABLES HERE AS NEEDED
```

**Note**: As development progresses, add new variables to these functions. Use `.get()` with sensible defaults for backward compatibility.

### 4.3 User Settings Serialization
**Framework for user preferences that persist across save wipes**.

**Get Settings Data**:
```gdscript
func _get_settings_data() -> Dictionary:
	return {
		# UI Settings
		"ui_scale": Global.ui_scale,  # Or wherever this is stored

		# Audio Settings
		"master_volume": AudioServer.get_bus_volume_db(0),  # Example
		"music_volume": 0.0,  # TBD where this is stored
		"sfx_volume": 0.0,    # TBD where this is stored

		# ADD MORE SETTINGS HERE AS NEEDED
		# Examples:
		# - Graphics quality
		# - Keybindings
		# - Accessibility options
		# - Language preference
	}
```

**Set Settings Data**:
```gdscript
func _set_settings_data(data: Dictionary) -> void:
	# UI Settings
	if data.has("ui_scale"):
		Global.ui_scale = data.get("ui_scale", 1.0)
		# Trigger UI scale update if needed

	# Audio Settings
	if data.has("master_volume"):
		AudioServer.set_bus_volume_db(0, data.get("master_volume", 0.0))

	# ADD MORE SETTINGS HERE AS NEEDED
```

**Note**: Settings are separate from game saves - they persist even when starting a new game or wiping saves.

---

## Part 5: Error Handling

### 5.1 Offline Graceful Degradation
If authentication fails (no server/no internet):
- Emit `authentication_failed` signal
- Game continues in offline mode
- Local saves only
- No crashes

### 5.2 Invalid Credentials
If login fails (wrong password/user doesn't exist):
- Return `false` from auth function
- Emit `authentication_failed` signal with error message
- Auth screen can show error to player

### 5.3 Unauthenticated Storage Access
If trying to save/load without auth:
- Return `null` or `false`
- Log error (don't crash)
- Caller handles gracefully

---

## Implementation Steps

### Step 1: Create nakama_client.gd
- [ ] Create file with basic structure
- [ ] Add to project.godot as autoload
- [ ] Implement `_initialize_client()`
- [ ] Set placeholder server config (will update later)

### Step 2: Implement Authentication
- [ ] Add device ID auth function
- [ ] Add username/password auth function
- [ ] Add Google OAuth function (web only)
- [ ] Add helper functions for auth state
- [ ] Implement signals

### Step 3: Implement Storage API
- [ ] Add generic `write_storage()` function
- [ ] Add generic `read_storage()` function
- [ ] Add `save_game()` function
- [ ] Add `load_game()` function
- [ ] Add `save_settings()` function
- [ ] Add `load_settings()` function

### Step 4: Create Save Data Framework
- [ ] Implement `_get_global_data()` with basic stats
- [ ] Implement `_set_global_data()` with basic stats
- [ ] Implement `_get_level1_vars_data()` with currency/coal
- [ ] Implement `_set_level1_vars_data()` with currency/coal
- [ ] Implement `_get_settings_data()` with UI scale and audio
- [ ] Implement `_set_settings_data()` with UI scale and audio
- [ ] Add comments indicating where to add more variables

### Step 5: Error Handling
- [ ] Test offline behavior (no auth = offline mode)
- [ ] Test invalid credentials (returns false, no crash)
- [ ] Test unauthenticated storage access (returns null, no crash)

---

## Integration Notes

### Auth Screen Integration
- Auth screen (1.21-auth-screen.md) will call these functions
- Auth screen appears BEFORE loading screen
- While player authenticates, start preloading game assets
- Offline mode = skip auth, use device ID silently (or no auth at all)

### Save System Integration
- Cloud saves work alongside local saves
- Cloud saves are NOT required
- Players can choose to skip cloud saves entirely

### Settings Persistence
- User settings (UI scale, volume, etc.) save to separate collection
- Settings persist across save wipes and new games
- Load settings on auth, save settings when changed

---

## Dependencies

**Before This Plan**:
- [x] Global.gd with stats system (1.3)
- [x] Level1Vars autoload (1.4)
- [x] Currency system (1.5-1.7)

**After This Plan**:
- [ ] Auth Screen (1.21) - Uses these auth functions
- [ ] Save System Cloud (1.20) - Uses save/load functions

---

## Files Created

- `nakama_client.gd` - Cloud backend client (autoload)

**Files Modified**:
- `project.godot` - Add NakamaClient autoload

---

## Success Criteria

- [ ] NakamaClient autoload exists and initializes
- [ ] Device ID auth creates accounts
- [ ] Username/password auth creates/logs into accounts
- [ ] Google OAuth works on web builds
- [ ] `save_game()` writes game state to cloud storage
- [ ] `load_game()` reads game state from cloud storage
- [ ] `save_settings()` writes user preferences to cloud storage
- [ ] `load_settings()` reads user preferences from cloud storage
- [ ] Settings persist across save wipes and new games
- [ ] Offline mode doesn't crash (auth fails gracefully)
- [ ] Framework allows easy addition of new save variables
- [ ] Clean, readable code with no v1 spaghetti

---

## Notes

- **Clean rebuild**: Don't copy v1 code, rebuild from scratch
- **Simple and minimal**: Only essential features, no bloat
- **Framework approach**: Easy to add variables as development progresses
- **No testing now**: Server URL will change before implementation
- **Wipe old saves**: Fresh start when this is implemented
- **Offline-first**: Cloud saves are optional, not required
- **Settings vs Saves**: User settings (UI scale, volume) are separate from game progress and persist across save wipes
