# 1.19 Nakama Server Integration Plan

## Overview
Build a clean, minimal Nakama client from scratch for cloud save functionality in the GoA rewrite. This is the AUTHORITATIVE SOURCE for all Nakama implementation details. Other plans (1.20, 1.21) reference this plan but do not duplicate implementation details.

## Purpose
Create a simple cloud backend connection that:
- Authenticates players (device ID, username/password, Google OAuth)
- Saves/loads game state to cloud storage
- Saves/loads user settings separately from game state
- Handles account migration (device ID to username/Google)
- Resolves save conflicts when migrating accounts

## Server Infrastructure
- **Server**: Nakama 3.x (will be migrated to new URL before implementation)
- **Plugin**: `addons/com.heroiclabs.nakama/` (Godot plugin)
- **Database**: PostgreSQL
- **Protocol**: HTTPS (port 443)
- **Note**: Server configuration (URL, key) will be finalized during implementation

---

## Part 1: Core Client Architecture

### 1.1 Create nakama_client.gd Autoload
Clean, minimal autoload script with only essential features.

**File**: `nakama_client.gd`

**Core Components**:
```gdscript
extends Node

# Nakama objects
var client: NakamaClient
var session: NakamaSession

# Server config (values TBD during implementation)
const SERVER_KEY = ""  # Set during implementation
const SERVER_HOST = ""  # Set during implementation
const SERVER_PORT = 443
const SERVER_SCHEME = "https"

# Auth state
var is_authenticated = false
var user_id = ""
var username = ""

# Signals
signal authentication_succeeded(session_data)
signal authentication_failed(error_message)
signal save_conflict_detected(device_save, account_save)
signal migration_completed(success: bool)
```

**Key Principles**:
- Keep it simple - only what's necessary
- No socket connection (not needed for single-player)
- No deprecated functions
- Clean error handling
- All saves are cloud-based (NO local save fallback)

### 1.2 Initialize Client
Basic client setup on ready:
```gdscript
func _ready():
	_initialize_client()

func _initialize_client():
	client = Nakama.create_client(
		SERVER_KEY,
		SERVER_HOST,
		SERVER_PORT,
		SERVER_SCHEME
	)
```

---

## Part 2: Authentication Methods

All three authentication methods create cloud-based Nakama accounts. There are NO local saves or offline fallback.

### 2.1 Device ID Authentication
Cloud-based authentication using device ID - no username/password required.

**Purpose**: Low-friction authentication that still provides cloud saves.

**Implementation**:
```gdscript
func authenticate_device() -> bool:
	var device_id = OS.get_unique_id()
	var auth_result = await client.authenticate_device_async(
		device_id,
		null,
		true,  # Create account if doesn't exist
		{}
	)

	if auth_result.is_exception():
		var error = auth_result.get_exception().message
		authentication_failed.emit(error)
		return false

	session = auth_result as NakamaSession
	_set_auth_state(session)
	authentication_succeeded.emit(_get_session_data())
	return true
```

**Note**: Device ID creates a CLOUD account linked to this device. It's not "offline mode" - it's cloud-based authentication without username/password.

### 2.2 Username/Password Authentication
For players who want portable accounts accessible from any device.

**Purpose**: Manual account creation and login.

**Implementation**:
```gdscript
func authenticate_email(username_input: String, password: String, create_account: bool) -> bool:
	# Use custom auth with hashed password for unique ID
	var custom_id = username_input + ":" + password.sha256_text()

	var auth_result = await client.authenticate_custom_async(
		custom_id,
		username_input,
		create_account
	)

	if auth_result.is_exception():
		var error = auth_result.get_exception().message
		authentication_failed.emit(error)
		return false

	session = auth_result as NakamaSession
	_set_auth_state(session)
	authentication_succeeded.emit(_get_session_data())
	return true
```

### 2.3 Google OAuth (Web Builds Only)
For web players using Google accounts.

**Purpose**: SSO for web builds.

**Implementation**:
```gdscript
func authenticate_google(google_token: String) -> bool:
	var auth_result = await client.authenticate_google_async(
		google_token,
		null,
		true,  # Create account if doesn't exist
		{}
	)

	if auth_result.is_exception():
		var error = auth_result.get_exception().message
		authentication_failed.emit(error)
		return false

	session = auth_result as NakamaSession
	_set_auth_state(session)
	authentication_succeeded.emit(_get_session_data())
	return true
```

### 2.4 Helper Functions
```gdscript
func _set_auth_state(nakama_session: NakamaSession):
	is_authenticated = true
	user_id = nakama_session.user_id
	username = nakama_session.username

func _get_session_data() -> Dictionary:
	return {
		"user_id": user_id,
		"username": username,
		"session": session
	}
```

---

## Part 3: Cloud Storage API

### 3.1 Generic Storage Functions
Low-level read/write for any data.

**Write Storage**:
```gdscript
func write_storage(collection: String, key: String, value: Dictionary):
	if not is_authenticated:
		DebugLogger.error("Cannot write storage: Not authenticated")
		return null

	var write_object = NakamaWriteStorageObject.new(
		collection,
		key,
		2,  # Read permission: owner only
		1,  # Write permission: owner only
		JSON.stringify(value),
		""
	)

	var result = await client.write_storage_objects_async(session, [write_object])

	if result.is_exception():
		DebugLogger.error("Storage write failed: " + result.get_exception().message)
		return null

	return result
```

**Read Storage**:
```gdscript
func read_storage(collection: String, key: String):
	if not is_authenticated:
		DebugLogger.error("Cannot read storage: Not authenticated")
		return null

	var storage_id = NakamaStorageObjectId.new(collection, key, user_id)
	var result = await client.read_storage_objects_async(session, [storage_id])

	if result.is_exception():
		DebugLogger.error("Storage read failed: " + result.get_exception().message)
		return null

	if result.objects.size() > 0:
		return JSON.parse_string(result.objects[0].value)

	return null
```

### 3.2 Game Save/Load Functions
High-level functions for full game state.

**Save Game**:
```gdscript
func save_game() -> bool:
	if not is_authenticated:
		DebugLogger.error("Cannot save: Not authenticated")
		return false

	# Update timestamp before saving
	Level1Vars.last_played_timestamp = Time.get_unix_time_from_system()

	var save_data = {
		"version": "2.0",
		"timestamp": Time.get_unix_time_from_system(),
		"global": _get_global_data(),
		"level1_vars": _get_level1_vars_data()
	}

	var result = await write_storage("player_data", "game_save", save_data)
	if result:
		DebugLogger.info("Game saved to cloud")
		return true

	DebugLogger.error("Game save failed")
	return false
```

**Load Game**:
```gdscript
func load_game() -> bool:
	if not is_authenticated:
		DebugLogger.error("Cannot load: Not authenticated")
		return false

	var save_data = await read_storage("player_data", "game_save")

	if not save_data:
		DebugLogger.info("No cloud save found")
		return false

	if not save_data.has("global") or not save_data.has("level1_vars"):
		DebugLogger.error("Invalid cloud save structure")
		return false

	_set_global_data(save_data.global)
	_set_level1_vars_data(save_data.level1_vars)

	DebugLogger.info("Game loaded from cloud")
	return true
```

### 3.3 User Settings Save/Load
User preferences (UI scale, volume, etc.) saved separately from game progress.

**Purpose**: Settings persist across save file wipes and new games.

**Save Settings**:
```gdscript
func save_settings() -> bool:
	if not is_authenticated:
		DebugLogger.error("Cannot save settings: Not authenticated")
		return false

	var settings_data = {
		"version": "2.0",
		"timestamp": Time.get_unix_time_from_system(),
		"settings": _get_settings_data()
	}

	var result = await write_storage("player_data", "user_settings", settings_data)
	if result:
		DebugLogger.info("Settings saved to cloud")
		return true

	DebugLogger.error("Settings save failed")
	return false
```

**Load Settings**:
```gdscript
func load_settings() -> bool:
	if not is_authenticated:
		DebugLogger.error("Cannot load settings: Not authenticated")
		return false

	var settings_data = await read_storage("player_data", "user_settings")

	if not settings_data:
		DebugLogger.info("No cloud settings found")
		return false

	if settings_data.has("settings"):
		_set_settings_data(settings_data.settings)
		DebugLogger.info("Settings loaded from cloud")
		return true

	return false
```

---

## Part 4: Save Data Serialization

### 4.1 Global Data Serialization
Framework for adding Global.gd variables to cloud saves.

**Get Global Data**:
```gdscript
func _get_global_data() -> Dictionary:
	return {
		# Stats
		"strength": Global.strength,
		"constitution": Global.constitution,
		"dexterity": Global.dexterity,
		"wisdom": Global.wisdom,
		"intelligence": Global.intelligence,
		"charisma": Global.charisma,

		# Experience
		"strength_exp": Global.strength_exp,
		"constitution_exp": Global.constitution_exp,
		"dexterity_exp": Global.dexterity_exp,
		"wisdom_exp": Global.wisdom_exp,
		"intelligence_exp": Global.intelligence_exp,
		"charisma_exp": Global.charisma_exp,

		# Play time tracking (for migration conflict resolution)
		"total_play_length": Global.total_play_length,
		"last_played_timestamp": Time.get_unix_time_from_system(),

		# ADD MORE GLOBAL VARIABLES HERE AS NEEDED
	}
```

**Set Global Data**:
```gdscript
func _set_global_data(data: Dictionary) -> void:
	# Stats
	Global.strength = data.get("strength", 1.0)
	Global.constitution = data.get("constitution", 1.0)
	Global.dexterity = data.get("dexterity", 1.0)
	Global.wisdom = data.get("wisdom", 1.0)
	Global.intelligence = data.get("intelligence", 1.0)
	Global.charisma = data.get("charisma", 1.0)

	# Experience
	Global.strength_exp = data.get("strength_exp", 0.0)
	Global.constitution_exp = data.get("constitution_exp", 0.0)
	Global.dexterity_exp = data.get("dexterity_exp", 0.0)
	Global.wisdom_exp = data.get("wisdom_exp", 0.0)
	Global.intelligence_exp = data.get("intelligence_exp", 0.0)
	Global.charisma_exp = data.get("charisma_exp", 0.0)

	# Play time tracking
	Global.total_play_length = data.get("total_play_length", 0.0)

	# ADD MORE GLOBAL VARIABLES HERE AS NEEDED
```

**Note**: `total_play_length` variable needs to be added to Global.gd (see plan 1.3-global-autoload.md).

### 4.2 Level1Vars Data Serialization
Framework for adding Level1Vars.gd variables to cloud saves.

**Get Level1Vars Data**:
```gdscript
func _get_level1_vars_data() -> Dictionary:
	return {
		# Currency (multi-tier system)
		"currency": Level1Vars.currency,
		"lifetime_currency": Level1Vars.lifetime_currency,

		# Resources
		"coal": Level1Vars.coal,

		# Upgrades (will be added as development progresses)
		"shovel_lvl": Level1Vars.shovel_lvl if Level1Vars.has("shovel_lvl") else 0,
		"plow_lvl": Level1Vars.plow_lvl if Level1Vars.has("plow_lvl") else 0,

		# Timestamps
		"last_played_timestamp": Level1Vars.last_played_timestamp,

		# ADD MORE LEVEL1VARS VARIABLES HERE AS NEEDED
	}
```

**Set Level1Vars Data**:
```gdscript
func _set_level1_vars_data(data: Dictionary) -> void:
	# Currency (multi-tier system with defaults)
	Level1Vars.currency = data.get("currency", {"copper": 0.0, "silver": 0.0, "gold": 0.0, "platinum": 0.0})
	Level1Vars.lifetime_currency = data.get("lifetime_currency", {"copper": 0.0, "silver": 0.0, "gold": 0.0, "platinum": 0.0})

	# Resources
	Level1Vars.coal = data.get("coal", 0.0)

	# Upgrades
	if Level1Vars.has("shovel_lvl"):
		Level1Vars.shovel_lvl = data.get("shovel_lvl", 0)
	if Level1Vars.has("plow_lvl"):
		Level1Vars.plow_lvl = data.get("plow_lvl", 0)

	# Timestamps
	Level1Vars.last_played_timestamp = data.get("last_played_timestamp", Time.get_unix_time_from_system())

	# ADD MORE LEVEL1VARS VARIABLES HERE AS NEEDED
```

### 4.3 User Settings Serialization
Framework for user preferences that persist across save wipes.

**Get Settings Data**:
```gdscript
func _get_settings_data() -> Dictionary:
	return {
		# UI Settings
		"ui_scale": Global.ui_scale if Global.has("ui_scale") else 1.0,

		# Audio Settings (TBD where these are stored)
		"master_volume": AudioServer.get_bus_volume_db(0),
		"music_volume": 0.0,  # TBD
		"sfx_volume": 0.0,    # TBD

		# ADD MORE SETTINGS HERE AS NEEDED
		# Examples:
		# - Graphics quality
		# - Keybindings
		# - Accessibility options
		# - Language preference
	}
```

**Set Settings Data**:
```gdscript
func _set_settings_data(data: Dictionary) -> void:
	# UI Settings
	if data.has("ui_scale") and Global.has("ui_scale"):
		Global.ui_scale = data.get("ui_scale", 1.0)
		# Trigger UI scale update if needed

	# Audio Settings
	if data.has("master_volume"):
		AudioServer.set_bus_volume_db(0, data.get("master_volume", 0.0))

	# ADD MORE SETTINGS HERE AS NEEDED
```

---

## Part 5: Account Migration System

When a player switches from device ID authentication to username/password or Google authentication, their progress needs to migrate to the new account.

### 5.1 Check for Migration
Determines if migration is needed and if there are conflicts.

```gdscript
func check_for_migration_needed(old_user_id: String, new_user_id: String) -> Dictionary:
	# Read saves from both accounts
	var old_save = await _read_storage_for_user(old_user_id, "player_data", "game_save")
	var new_save = await _read_storage_for_user(new_user_id, "player_data", "game_save")

	var has_old_save = old_save != null
	var has_new_save = new_save != null

	return {
		"needs_migration": has_old_save,
		"has_conflict": has_old_save and has_new_save,
		"old_save": old_save if has_old_save else {},
		"new_save": new_save if has_new_save else {}
	}

func _read_storage_for_user(target_user_id: String, collection: String, key: String):
	# Helper to read storage for a specific user ID
	var storage_id = NakamaStorageObjectId.new(collection, key, target_user_id)
	var result = await client.read_storage_objects_async(session, [storage_id])

	if result.is_exception():
		return null

	if result.objects.size() > 0:
		return JSON.parse_string(result.objects[0].value)

	return null
```

### 5.2 Migrate Save Between Accounts
Copies save data from device ID account to username/Google account.

```gdscript
func migrate_save_to_account(from_user_id: String, to_user_id: String) -> bool:
	# Read save from old account
	var old_save = await _read_storage_for_user(from_user_id, "player_data", "game_save")

	if not old_save:
		DebugLogger.error("No save found on old account")
		return false

	# Write save to new account (overwrites if exists)
	var result = await write_storage("player_data", "game_save", old_save)

	if result:
		DebugLogger.info("Save migrated successfully")
		migration_completed.emit(true)
		return true
	else:
		DebugLogger.error("Save migration failed")
		migration_completed.emit(false)
		return false
```

### 5.3 Get Save Summary for Conflict Resolution
Extracts key information from save data to display in conflict resolution UI.

```gdscript
func get_save_summary(save_data: Dictionary) -> Dictionary:
	if not save_data.has("global") or not save_data.has("level1_vars"):
		return {}

	var global_data = save_data.global
	var level1_data = save_data.level1_vars

	# Convert total_play_length from seconds to hours
	var play_hours = global_data.get("total_play_length", 0.0) / 3600.0

	return {
		"last_played": save_data.get("timestamp", 0),
		"total_play_hours": play_hours,
		"stats": {
			"strength": global_data.get("strength", 1),
			"constitution": global_data.get("constitution", 1),
			"dexterity": global_data.get("dexterity", 1),
			"wisdom": global_data.get("wisdom", 1),
			"intelligence": global_data.get("intelligence", 1),
			"charisma": global_data.get("charisma", 1)
		},
		"currency": level1_data.get("currency", {"copper": 0, "silver": 0, "gold": 0, "platinum": 0})
	}
```

### 5.4 Emit Conflict Signal
When migration conflict detected, emit signal for UI to handle.

```gdscript
func emit_save_conflict(device_save: Dictionary, account_save: Dictionary):
	# Get summaries for UI display
	var device_summary = get_save_summary(device_save)
	var account_summary = get_save_summary(account_save)

	save_conflict_detected.emit(device_summary, account_summary)
```

---

## Part 6: Error Handling

### 6.1 Authentication Failures
If authentication fails (server unreachable, invalid credentials):
- Emit `authentication_failed` signal with error message
- Return `false` from auth function
- Caller (auth screen) can show error to player and allow retry

**No offline fallback** - all three auth methods require server connection.

### 6.2 Unauthenticated Storage Access
If trying to save/load without authentication:
- Log error via DebugLogger
- Return `null` or `false`
- Don't crash - let caller handle gracefully

### 6.3 Save/Load Failures
If storage operations fail:
- Log error via DebugLogger
- Return `null` or `false`
- Caller can retry or show error to player

---

## Implementation Checklist

### Phase 1: Core Client
- [ ] Create `nakama_client.gd` file
- [ ] Add to project.godot as autoload
- [ ] Implement `_initialize_client()`
- [ ] Set placeholder server config (update later)

### Phase 2: Authentication
- [ ] Implement device ID authentication
- [ ] Implement username/password authentication
- [ ] Implement Google OAuth authentication (web only)
- [ ] Add helper functions for auth state
- [ ] Implement authentication signals

### Phase 3: Storage API
- [ ] Implement generic `write_storage()`
- [ ] Implement generic `read_storage()`
- [ ] Implement `save_game()`
- [ ] Implement `load_game()`
- [ ] Implement `save_settings()`
- [ ] Implement `load_settings()`

### Phase 4: Serialization
- [ ] Implement `_get_global_data()` with stats and total_play_length
- [ ] Implement `_set_global_data()` with stats and total_play_length
- [ ] Implement `_get_level1_vars_data()` with currency/coal/upgrades
- [ ] Implement `_set_level1_vars_data()` with currency/coal/upgrades
- [ ] Implement `_get_settings_data()` with UI/audio settings
- [ ] Implement `_set_settings_data()` with UI/audio settings
- [ ] Add comments indicating where to add more variables

### Phase 5: Migration System
- [ ] Implement `check_for_migration_needed()`
- [ ] Implement `_read_storage_for_user()` helper
- [ ] Implement `migrate_save_to_account()`
- [ ] Implement `get_save_summary()` for conflict UI
- [ ] Implement `emit_save_conflict()` signal
- [ ] Add migration signals

### Phase 6: Error Handling
- [ ] Test authentication failure (no server)
- [ ] Test invalid credentials
- [ ] Test unauthenticated storage access
- [ ] Test save/load failures

### Phase 7: Integration with Global.gd
- [ ] Add `total_play_length` variable to Global.gd (see plan 1.3)
- [ ] Track total play time in seconds (increment in _process)
- [ ] Ensure all serialized variables exist in Global.gd

---

## Integration Notes

### Auth Screen Integration (Plan 1.21)
- Auth screen calls these authentication functions
- Auth screen handles migration UI and conflict resolution
- Auth screen loads game/settings after successful auth

### Save System Integration (Plan 1.20)
- Save system determines WHEN to call `save_game()`
- This plan provides the IMPLEMENTATION of `save_game()`
- Save triggers: purchases, stat gains, scene changes, periodic, exit

### Settings Persistence
- User settings save to separate collection `"user_settings"`
- Settings persist across save wipes and new games
- Load settings on auth, save settings when changed

---

## Dependencies

**Before This Plan**:
- [x] Global.gd with stats system (plan 1.3) - needs `total_play_length` added
- [x] Level1Vars autoload (plan 1.4)
- [x] Currency system (plans 1.5-1.7)

**After This Plan**:
- [ ] Auth Screen (plan 1.21) - Uses authentication functions
- [ ] Save System Cloud (plan 1.20) - Determines save triggers

---

## Files Created

- `nakama_client.gd` - Cloud backend client (autoload)

**Files Modified**:
- `project.godot` - Add NakamaClient autoload
- `global.gd` - Add `total_play_length` variable (coordinate with plan 1.3)

---

## Success Criteria

- [ ] NakamaClient autoload exists and initializes
- [ ] Device ID auth creates cloud accounts
- [ ] Username/password auth creates/logs into cloud accounts
- [ ] Google OAuth works on web builds
- [ ] `save_game()` writes game state to cloud storage
- [ ] `load_game()` reads game state from cloud storage
- [ ] `save_settings()` writes user preferences to cloud storage
- [ ] `load_settings()` reads user preferences from cloud storage
- [ ] Settings persist across save wipes and new games
- [ ] `check_for_migration_needed()` detects account migration scenarios
- [ ] `migrate_save_to_account()` copies saves between accounts
- [ ] `get_save_summary()` provides data for conflict resolution UI
- [ ] Migration signals emit correctly
- [ ] Authentication failures handled gracefully (no crashes)
- [ ] Framework allows easy addition of new save variables
- [ ] Clean, readable code with no v1 spaghetti
- [ ] All saves are cloud-based (no local save system)

---

## Notes

### Clean Rebuild Philosophy
- Don't copy v1 code, rebuild from scratch
- Simple and minimal: Only essential features, no bloat
- Framework approach: Easy to add variables as development progresses

### Cloud-Only Architecture
- NO local saves or offline fallback
- Device ID authentication creates cloud account (not "offline mode")
- All three auth methods require server connection
- All saves stored on Nakama server

### Account Types
- **Device ID**: Cloud account linked to this device (convenient, no login)
- **Username/Password**: Cloud account accessible from any device (portable)
- **Google OAuth**: Cloud account via Google SSO (web builds)

### Migration System
- Happens automatically when switching from device ID to username/Google
- No conflict: Ask user to upload device ID progress
- Conflict: Show both saves with timestamps/play time, let user choose
- Requires `total_play_length` tracking in Global.gd (coordinate with plan 1.3)

### Settings vs Saves
- Game saves: Player progression (stats, currency, upgrades)
- User settings: Preferences (UI scale, volume, graphics)
- Stored separately so settings persist across save wipes

### Future Server Migration
- Server URL will change before implementation
- Fresh start when implemented (wipe old saves)
- Test thoroughly after server migration

---

**Last Updated**: 2025-12-02
**Plan Created By**: Claude
**Status**: Authoritative source for Nakama implementation - plans 1.20 and 1.21 reference this
