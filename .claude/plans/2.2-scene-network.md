# Scene Network

**Goal**: Establish centralized scene registry and navigation map for all Level 1 scenes (copper, silver, and gold eras)

**Success Criteria**:
- Scene network dictionary with paths, connections, and unlock conditions
- Validator integrated with Global scene management (1.9)
- Helper functions for navigation checks and scene queries
- Easy to extend as new scenes are added
- Unit tests for network validation logic
- Documentation of all Level 1 scenes

**Prerequisites**:
- Phase 1.9: Scene Management (validation framework exists)
- Phase 2.1: Core Loop (initial scenes established)

---

## Overview

**IMPORTANT: Complete Rewrite Context**
This plan establishes the **complete navigation map for Level 1**, covering all three eras: copper, silver, and gold. The scene network is designed to grow incrementally - start with copper scenes, add silver scenes as those features are planned, and extend with gold scenes later. All scenes are centralized in one file for easy modification.

The scene network provides a **centralized registry** of all Level 1 scenes with their connections and unlock conditions. This integrates with the generic validation framework from Phase 1.9 to control navigation throughout the game. As new features are planned, their scenes are added to this network.

### Key Design Principles

- **Single Source of Truth**: All Level 1 scenes and connections in one file
- **Incremental Growth**: Add scenes as features are planned, start with copper
- **Centralized Modification**: Change connections/unlocks in one place
- **Era-Agnostic Structure**: Same data structure for copper, silver, and gold
- **Extensible**: Easy to add new scenes without refactoring
- **Self-Documenting**: Network structure is the documentation

---

## Architecture Overview

### Data Flow

```
Player clicks navigation button
  -> Request scene change via Global.change_scene()
  -> Global runs validators (including scene network validator)
  -> Network checks: Is destination in network? Is it unlocked? Is it connected?
  -> If valid: Scene changes
  -> If invalid: Show message, block transition
```

### Component Separation

- **Phase 1.9 (Scene Management)**: Generic validation framework
- **This Phase (2.2)**: Level 1 specific scene network and rules
- **Feature Plans**: Individual scenes and their content

### File Structure

```
level1/
  scene_network.gd         # This plan - all Level 1 navigation
  furnace.gd/tscn         # Individual scene files
  bar.gd/tscn
  shop.gd/tscn
  ... (other scenes)
```

---

## Implementation Tasks

### 1. Scene Network Data Structure

**File Location**: `res://level1/scene_network.gd`

**Core dictionary**:
```gdscript
extends Node

# Complete navigation map for Level 1 (all eras)
const SCENE_NETWORK = {
	# === COPPER ERA SCENES ===

	"furnace": {
		"path": "res://level1/furnace.tscn",
		"name": "Furnace",
		"era": "copper",
		"connections": ["bar", "shop", "dream"],
		"unlock_condition": null  # Always available (starting scene)
	},

	"bar": {
		"path": "res://level1/bar.tscn",
		"name": "The Bar",
		"era": "copper",
		"connections": ["furnace", "coppersmith_carriage", "dorm", "secret_passage"],
		"unlock_condition": null  # Hub - always available
	},

	"shop": {
		"path": "res://level1/shop.tscn",
		"name": "Shop",
		"era": "copper",
		"connections": ["furnace"],  # Auto-returns to furnace on break timer
		"unlock_condition": null  # Always available during breaks
	},

	"dream": {
		"path": "res://level1/dream.tscn",
		"name": "Dream",
		"era": "copper",
		"connections": ["furnace"],  # Auto-returns when stamina full
		"unlock_condition": null  # Triggered by stamina depletion
	},

	"coppersmith_carriage": {
		"path": "res://level1/coppersmith_carriage.tscn",
		"name": "Coppersmith's Carriage",
		"era": "copper",
		"connections": ["bar", "atm", "overseers_office"],
		"unlock_condition": null  # Hub - always available
	},

	"atm": {
		"path": "res://level1/atm.tscn",
		"name": "ATM",
		"era": "copper",
		"connections": ["coppersmith_carriage"],
		"unlock_condition": null  # Always available from carriage
	},

	"dorm": {
		"path": "res://level1/dorm.tscn",
		"name": "Dormitory",
		"era": "copper",
		"connections": ["bar"],
		"unlock_condition": "donated_equipment_once"  # First prestige unlocks
	},

	"secret_passage": {
		"path": "res://level1/secret_passage_entrance.tscn",
		"name": "Secret Passage",
		"era": "copper",
		"connections": ["bar", "secret_passage_puzzle"],
		"unlock_condition": "found_secret_door"  # Discovery mechanic
	},

	"secret_passage_puzzle": {
		"path": "res://level1/secret_passage_puzzle.tscn",
		"name": "Secret Passage Puzzle",
		"era": "copper",
		"connections": ["secret_passage"],
		"unlock_condition": "found_secret_door"  # Same as entrance
	},

	"overseers_office": {
		"path": "res://level1/overseers_office.tscn",
		"name": "Overseer's Office",
		"era": "copper",
		"connections": ["coppersmith_carriage"],
		"unlock_condition": null  # Available from carriage
	},

	# === SILVER ERA SCENES ===
	# (Add as silver features are planned)

	# === GOLD ERA SCENES ===
	# (Add as gold features are planned)
}
```

**Structure Fields**:
- `path`: Absolute path to .tscn file
- `name`: Display name for notifications
- `era`: Which era (copper, silver, gold) - for organization/filtering
- `connections`: Array of scene IDs this scene can navigate to
- `unlock_condition`: String key or null (unlocked from start)

**Implementation Details**:
- Dictionary keys are scene IDs (short names like "furnace", "bar")
- `connections` uses IDs, not paths
- `unlock_condition` is checked via Level1Vars or special checks
- `era` field is metadata (not used for validation currently)

---

### 2. Helper Functions

**Navigation checks**:
```gdscript
# Check if player can navigate to a scene
func can_navigate_to(scene_id: String) -> bool:
	# Scene not in network? Allow (might be from another level/system)
	if not scene_id in SCENE_NETWORK:
		return true

	var scene = SCENE_NETWORK[scene_id]

	# Check unlock condition
	if scene.unlock_condition != null:
		if not _is_unlocked(scene.unlock_condition):
			return false

	# Check if connected from current scene
	var current_id = _path_to_id(Global.get_current_scene_path())

	# If not in network or no current scene, allow (for initial load)
	if current_id.is_empty() or not current_id in SCENE_NETWORK:
		return true

	var current_scene = SCENE_NETWORK[current_id]
	var connections = current_scene.get("connections", [])

	# Must be in connections list
	if not scene_id in connections:
		return false

	return true

# Check if a scene is unlocked
func _is_unlocked(condition: String) -> bool:
	match condition:
		"donated_equipment_once":
			return Level1Vars.prestige_count > 0
		"found_secret_door":
			return Level1Vars.door_discovered
		# Add more unlock conditions as features are added
		_:
			push_warning("Unknown unlock condition: " + condition)
			return false

# Convert scene path to ID
func _path_to_id(path: String) -> String:
	for scene_id in SCENE_NETWORK:
		if SCENE_NETWORK[scene_id].path == path:
			return scene_id
	return ""

# Convert scene ID to path
func get_scene_path(scene_id: String) -> String:
	if scene_id in SCENE_NETWORK:
		return SCENE_NETWORK[scene_id].path
	return ""
```

**Query functions**:
```gdscript
# Get all scenes from a specific era
func get_scenes_by_era(era: String) -> Array:
	var scenes = []
	for scene_id in SCENE_NETWORK:
		if SCENE_NETWORK[scene_id].era == era:
			scenes.append(scene_id)
	return scenes

# Get all unlocked scenes
func get_unlocked_scenes() -> Array:
	var unlocked = []
	for scene_id in SCENE_NETWORK:
		var scene = SCENE_NETWORK[scene_id]
		if scene.unlock_condition == null or _is_unlocked(scene.unlock_condition):
			unlocked.append(scene_id)
	return unlocked

# Get scenes connected from current scene
func get_available_destinations() -> Array:
	var current_id = _path_to_id(Global.get_current_scene_path())
	if current_id.is_empty() or not current_id in SCENE_NETWORK:
		return []

	var current_scene = SCENE_NETWORK[current_id]
	var connections = current_scene.get("connections", [])

	# Filter to only unlocked destinations
	var available = []
	for dest_id in connections:
		if can_navigate_to(dest_id):
			available.append(dest_id)

	return available
```

---

### 3. Global Validator Integration

**Register validator on autoload**:
```gdscript
func _ready():
	# Autoload: Register scene network validator
	Global.register_scene_validator(_validate_scene_network)

# Validator function
func _validate_scene_network(scene_path: String) -> bool:
	var scene_id = _path_to_id(scene_path)

	# Not in network? Allow (might be special scene, debug, etc.)
	if scene_id.is_empty():
		return true

	# Check if can navigate
	if not can_navigate_to(scene_id):
		var scene = SCENE_NETWORK[scene_id]
		var scene_name = scene.get("name", scene_id)

		# Determine why blocked and show appropriate message
		if scene.unlock_condition != null and not _is_unlocked(scene.unlock_condition):
			Global.show_stat_notification(scene_name + " is locked")
		else:
			Global.show_stat_notification("You can't reach " + scene_name + " from here")

		return false

	return true
```

**Implementation Details**:
- Validator runs on every scene change (via Global.change_scene)
- Allows scenes not in network (for flexibility)
- Shows user-friendly messages when blocked
- Returns bool: true = allow, false = block

---

### 4. Autoload Registration

**In** `project.godot`:
```ini
[autoload]

# ... existing autoloads ...
SceneNetwork="*res://level1/scene_network.gd"
```

**Why autoload?**
- Available from anywhere via `SceneNetwork.can_navigate_to()`
- Registers validator automatically on game start
- Singleton pattern for centralized network

---

## Code Examples

### Adding a New Scene to Network

```gdscript
# In SCENE_NETWORK dictionary
"new_scene": {
	"path": "res://level1/new_scene.tscn",
	"name": "New Area",
	"era": "silver",  # or "copper", "gold"
	"connections": ["bar", "other_scene"],  # Where can you go from here?
	"unlock_condition": "unlocked_silver_era"  # or null if always available
}

# Add unlock condition check if needed
func _is_unlocked(condition: String) -> bool:
	match condition:
		# ... existing conditions ...
		"unlocked_silver_era":
			return Level1Vars.current_era == "silver"  # Example
		_:
			push_warning("Unknown unlock condition: " + condition)
			return false
```

### Navigating to a Scene

```gdscript
# From any scene script
func _on_bar_button_pressed():
	# Option 1: Direct path
	Global.change_scene("res://level1/bar.tscn")

	# Option 2: Via scene ID (requires SceneNetwork helper)
	var path = SceneNetwork.get_scene_path("bar")
	Global.change_scene(path)
```

### Checking Available Destinations

```gdscript
# For dynamic navigation UI
func _update_navigation_buttons():
	var available = SceneNetwork.get_available_destinations()

	for scene_id in available:
		var scene = SceneNetwork.SCENE_NETWORK[scene_id]
		var button_text = "To: " + scene.name
		# Create/show button with button_text
```

---

## Testing Strategy

### Unit Tests

Create `tests/test_scene_network.gd`:

```gdscript
extends GutTest

func before_each():
	Level1Vars.door_discovered = false
	Level1Vars.prestige_count = 0

# Test: Scene exists in network
func test_scene_in_network():
	assert_true("furnace" in SceneNetwork.SCENE_NETWORK, "Furnace in network")
	assert_true("bar" in SceneNetwork.SCENE_NETWORK, "Bar in network")

# Test: Path to ID conversion
func test_path_to_id():
	var id = SceneNetwork._path_to_id("res://level1/furnace.tscn")
	assert_eq(id, "furnace", "Path converts to ID")

# Test: ID to path conversion
func test_id_to_path():
	var path = SceneNetwork.get_scene_path("bar")
	assert_eq(path, "res://level1/bar.tscn", "ID converts to path")

# Test: Unlock condition check
func test_unlock_condition():
	# Secret passage locked by default
	assert_false(SceneNetwork._is_unlocked("found_secret_door"), "Secret door locked")

	# Unlock it
	Level1Vars.door_discovered = true
	assert_true(SceneNetwork._is_unlocked("found_secret_door"), "Secret door unlocked")

# Test: Navigation allowed from connected scene
func test_navigation_connected():
	# Note: Requires mocking current scene
	# This is more of an integration test
	pass

# Test: Navigation blocked from unconnected scene
func test_navigation_unconnected():
	# Secret passage not connected to furnace
	# Would need to mock current scene as furnace
	pass

# Test: Get scenes by era
func test_get_scenes_by_era():
	var copper_scenes = SceneNetwork.get_scenes_by_era("copper")
	assert_true(copper_scenes.size() > 0, "Has copper scenes")
	assert_true("furnace" in copper_scenes, "Furnace is copper era")

# Test: Get unlocked scenes
func test_get_unlocked_scenes():
	var unlocked = SceneNetwork.get_unlocked_scenes()
	assert_true("furnace" in unlocked, "Furnace always unlocked")
	assert_false("secret_passage" in unlocked, "Secret passage locked by default")

	Level1Vars.door_discovered = true
	unlocked = SceneNetwork.get_unlocked_scenes()
	assert_true("secret_passage" in unlocked, "Secret passage unlocked after discovery")
```

**Run tests:**
```bash
godot --headless --script res://addons/gut/gut_cmdln.gd -gtest=tests/test_scene_network.gd
```

### Integration Tests

| Scenario | Setup | Action | Expected Result |
|----------|-------|--------|-----------------|
| Navigate to connected unlocked scene | In bar | Change to furnace | Transition succeeds |
| Navigate to locked scene | Secret door not found | Try to go to secret passage | Blocked, shows "is locked" |
| Navigate to unconnected scene | In furnace | Try to go to dorm directly | Blocked, shows "can't reach" |
| Unlock then navigate | Find secret door | Navigate to secret passage | Allowed |
| Era filtering | Query copper scenes | Call get_scenes_by_era("copper") | Returns all copper scenes |

### Manual Test Criteria

- [ ] Start game in furnace, navigate to bar (should work)
- [ ] From bar, navigate to all connected scenes (furnace, carriage, dorm if unlocked)
- [ ] Try to navigate to secret passage without discovering door (should block)
- [ ] Discover secret door, then navigate to secret passage (should work)
- [ ] Verify navigation messages are clear ("X is locked", "Can't reach X")
- [ ] Add a new scene to network, verify it integrates properly
- [ ] Check console for warnings about unknown unlock conditions

---

## Files to Create

- `res://level1/scene_network.gd` - Scene network autoload with all Level 1 scenes

## Files to Modify

- `project.godot` - Add SceneNetwork autoload
- `tests/test_scene_network.gd` - Unit tests for network logic

---

## Design Values (Reference)

### Unlock Conditions

**Current unlock conditions** (add more as features are added):
- `null` - Always unlocked (starting scenes, hubs)
- `"found_secret_door"` - Requires `Level1Vars.door_discovered == true`
- `"donated_equipment_once"` - Requires `Level1Vars.prestige_count > 0`

**To add new unlock:**
1. Choose descriptive string key (e.g., `"completed_copper_era"`)
2. Add case to `_is_unlocked()` function
3. Add condition to relevant scene(s) in SCENE_NETWORK

### Scene Organization

**Eras**:
- **Copper**: Initial gameplay loop, coal shoveling, basic progression
- **Silver**: Shift work system, overseer interactions
- **Gold**: Furnace ownership, worker management

**Hubs** (high connection count):
- `bar` - Main hub, connects to multiple areas
- `coppersmith_carriage` - Secondary hub, connects to services

**Special Scenes**:
- `dream` - Auto-triggered on stamina depletion, auto-returns
- `shop` - Break timer based, auto-returns to furnace
- `secret_passage` - Discovery-based unlock

---

## Dependencies & Integration

### Depends On:
- Phase 1.9 (Scene Management) - Validation framework
- Phase 2.1 (Core Loop) - Initial scenes exist
- Level1Vars - Unlock condition variables

### Used By:
- All Level 1 scenes - Navigation between scenes
- Future UI features - Dynamic navigation buttons
- Feature plans - Add new scenes to network

### Provides APIs For:

**Navigation**:
```gdscript
SceneNetwork.can_navigate_to(scene_id) -> bool
SceneNetwork.get_scene_path(scene_id) -> String
```

**Queries**:
```gdscript
SceneNetwork.get_scenes_by_era(era) -> Array
SceneNetwork.get_unlocked_scenes() -> Array
SceneNetwork.get_available_destinations() -> Array
```

**Validation**:
```gdscript
# Automatically registered with Global.scene_validators
```

## Notes & Decisions

**Decision 1**: Single network for all Level 1 eras
- **Rationale**: Three eras (copper, silver, gold) are all part of Level 1
- **Benefit**: One file to manage, clear progression through eras
- **Alternative**: Separate networks per era (rejected - adds complexity)

**Decision 2**: Dictionary-based structure
- **Rationale**: Simple, readable, easy to modify
- **Benefit**: All scenes visible in one place, no complex classes
- **Alternative**: Graph classes (rejected - overkill for this scale)

**Decision 3**: Scene IDs as dictionary keys
- **Rationale**: Short names easier to type than full paths
- **Benefit**: `can_navigate_to("bar")` vs `can_navigate_to("res://level1/bar.tscn")`
- **Helper**: `get_scene_path()` converts ID to path when needed

**Decision 4**: Connections are explicit, not bidirectional
- **Rationale**: Some scenes auto-return (shop -> furnace) without back button
- **Benefit**: Full control over navigation flow
- **Note**: If A connects to B, B does NOT automatically connect to A

**Decision 5**: Unlock conditions as string keys
- **Rationale**: Flexible, easy to add new conditions
- **Benefit**: No enum management, just add case to `_is_unlocked()`
- **Trade-off**: No compile-time checking (but warnings on unknown conditions)

**Decision 6**: Incremental additions expected
- **Rationale**: Not all scenes designed yet
- **Benefit**: Add scenes as features are planned (low friction)
- **Process**: Each feature plan adds its scenes to this network

**Decision 7**: Era field is metadata, not validation
- **Rationale**: Used for organization/filtering, not unlock logic
- **Benefit**: Can query copper scenes separately if needed
- **Future**: Could add era-based unlocks if game design requires

---

## Adding New Scenes (Quick Reference)

When planning a new feature that adds a scene:

1. **Add to SCENE_NETWORK**:
```gdscript
"new_scene_id": {
	"path": "res://level1/new_scene.tscn",
	"name": "Display Name",
	"era": "copper",  # or "silver", "gold"
	"connections": ["scene1", "scene2"],  # Where can player go from here?
	"unlock_condition": null  # or "condition_key"
}
```

2. **Add unlock condition if needed**:
```gdscript
# In _is_unlocked() function
"condition_key":
	return Level1Vars.some_flag == true
```

3. **Add to existing connections**:
```gdscript
# Find scenes that should connect TO this new scene
# Add "new_scene_id" to their "connections" arrays
```

4. **Test**:
- Navigate to/from new scene
- Verify unlock logic if applicable
- Check messages shown when blocked

**That's it!** The validator and helpers work automatically.

---

## Implementation Checklist

Before marking Phase 2.2 complete:

- [ ] `level1/scene_network.gd` created
- [ ] SCENE_NETWORK dictionary populated with initial copper scenes
- [ ] `can_navigate_to()` function implemented
- [ ] `_is_unlocked()` function implemented with all current unlock conditions
- [ ] `_path_to_id()` helper function implemented
- [ ] `get_scene_path()` helper function implemented
- [ ] `get_scenes_by_era()` query function implemented
- [ ] `get_unlocked_scenes()` query function implemented
- [ ] `get_available_destinations()` query function implemented
- [ ] Validator function `_validate_scene_network()` implemented
- [ ] Validator registered with Global on _ready()
- [ ] SceneNetwork autoload registered in project.godot
- [ ] Unit tests written and passing (8+ tests)
- [ ] Integration tests completed
- [ ] Manual tests verified (navigate between scenes)
- [ ] Documentation updated (this plan serves as docs)
- [ ] Process for adding new scenes documented

---

**Last Updated**: 2025-11-30
**Maintainer**: Claude + User collaboration
**Plan Version**: 1.0 (Level 1 scene network - incremental growth expected)
