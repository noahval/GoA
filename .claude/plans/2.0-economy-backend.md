# 2. Base System: Economy & Currencies

**Status**: Ready for Implementation
**Created**: 2025-01-27
**Priority**: Foundation (implement before Copper Era)

---

## Overview

Backend economy system for GoA's 4-tier currency with unified purse capacity, market volatility, and era-based progression. This plan covers BACKEND ONLY - ATM UI will be a separate plan.

**Three Eras, Four Currencies:**
- **Copper Era**: Player works as laborer, earns copper pieces
- **Silver Era**: Merchant/overseer tier (transition requires ~1000c exchange + bribes + certification - separate plan)
- **Gold Era**: Furnace owner, worker management
- **Platinum**: Overflow currency when gold > 1000 coins, escape goal for Level 1 completion

**Key Principles:**
- Unified purse capacity (all currencies share one cap)
- Discovery-driven (hidden formulas, observable patterns)
- ~1000:1 conversion ratios with ±20% market flux
- Transparent exchange costs (player sees "100 copper → 0.92 silver")

---

## 1. Currency Data Model

### Existing Structure (level1/level_1_vars.gd)

```gdscript
var currency = {
    "copper": 0.0,
    "silver": 0.0,
    "gold": 0.0,
    "platinum": 0.0
}

var lifetime_currency = {
    "copper": 0.0,
    "silver": 0.0,
    "gold": 0.0,
    "platinum": 0.0
}
```

### New Variables Needed

```gdscript
# Era progression tracking
var current_era: String = "copper"  # "copper", "silver", "gold"

# Purse/capacity system
var purse_level: int = 0  # Index into PURSE_TIERS array
const PURSE_TIERS = [
    # Copper-priced tiers (0-6)
    {"name": "Torn Pocket", "cap": 150, "cost_copper": 0},
    {"name": "Small Pouch", "cap": 300, "cost_copper": 135},
    {"name": "Leather Purse", "cap": 500, "cost_copper": 285},
    {"name": "Sturdy Purse", "cap": 700, "cost_copper": 650},
    {"name": "Money Belt", "cap": 900, "cost_copper": 850},
    {"name": "Secure Pouch", "cap": 1100, "cost_copper": 1050},
    {"name": "Lockbox", "cap": 1400, "cost_copper": 1350},

    # Silver-priced tiers (7-10)
    {"name": "Iron Strongbox", "cap": 2000, "cost_silver": 2.0},
    {"name": "Merchant's Safe", "cap": 3000, "cost_silver": 4.5},
    {"name": "Reinforced Vault", "cap": 5000, "cost_silver": 8.0},
    {"name": "Noble's Treasury", "cap": 10000, "cost_silver": 15.0}
]

# Exchange tracking (for discovery/statistics)
var lifetime_exchanges = {
    "copper_to_silver": 0,
    "silver_to_copper": 0,
    "silver_to_gold": 0,
    "gold_to_silver": 0,
    "gold_to_platinum": 0,
    "platinum_to_gold": 0,
    "total_fees_paid_copper": 0.0
}
```

---

## 2. Unified Capacity System

### Core Mechanic

**Single cap applies to TOTAL COIN COUNT across all currencies.**

**Example:** Purse cap = 1000 coins
- Can hold: 1000 copper, OR
- Can hold: 500 copper + 500 silver, OR
- Can hold: 300 copper + 300 silver + 400 gold

**Rationale:**
- **User requirement**: "A coin is a coin, whether copper, silver, gold, or platinum"
- Thematically consistent: Physical purse size, not value-based vault
- Simpler mental model: 1000 capacity = 1000 coins of any mix
- Strategic depth: Hold many cheap coins vs few valuable coins?

### Implementation (currency_manager.gd)

```gdscript
func get_total_coin_count() -> int:
    # Count total number of coins (not value)
    var total = 0
    total += int(Level1Vars.currency.copper)
    total += int(Level1Vars.currency.silver)
    total += int(Level1Vars.currency.gold)
    total += int(Level1Vars.currency.platinum)
    return total

func get_current_capacity() -> int:
    return Level1Vars.PURSE_TIERS[Level1Vars.purse_level]["cap"]

func get_capacity_info() -> Dictionary:
    var coin_count = get_total_coin_count()
    var cap = get_current_capacity()
    var percent = (float(coin_count) / float(cap)) * 100.0

    var warning_level = 0
    if percent >= 100.0:
        warning_level = 3  # Full
    elif percent >= 90.0:
        warning_level = 2  # 90%+ warning
    elif percent >= 80.0:
        warning_level = 1  # 80%+ caution

    return {
        "current_coins": coin_count,
        "max_capacity": cap,
        "percent_full": percent,
        "warning_level": warning_level,
        "space_remaining": cap - coin_count
    }

func add_currency(currency_type: int, amount: float, reason: String = "earned") -> float:
    var capacity_info = get_capacity_info()
    var adding_coins = int(amount)  # Coin count, not value

    if capacity_info.current_coins + adding_coins > capacity_info.max_capacity:
        # Calculate how many coins can actually fit
        var space = capacity_info.space_remaining

        if space > 0:
            # Partial add
            _add_currency_internal(currency_type, float(space))
            Global.show_stat_notification("Purse full: %d coins spill!" % (adding_coins - space))
            return float(space)
        else:
            # No space at all
            Global.show_stat_notification("Purse completely full: upgrade needed!")
            return 0.0
    else:
        # Full amount fits
        _add_currency_internal(currency_type, amount)

        # Check for warnings
        var new_info = get_capacity_info()
        if new_info.warning_level == 2 and capacity_info.warning_level < 2:
            Global.show_stat_notification("Purse nearly full: consider exchange or upgrade")

        return amount
```

### Purse Upgrade System

```gdscript
# In level_1_vars.gd
func can_afford_purse_upgrade() -> bool:
    if purse_level >= PURSE_TIERS.size() - 1:
        return false  # Already max tier

    var next_tier = PURSE_TIERS[purse_level + 1]

    if "cost_copper" in next_tier:
        return currency.copper >= next_tier.cost_copper
    elif "cost_silver" in next_tier:
        return currency.silver >= next_tier.cost_silver
    else:
        return false

func get_purse_upgrade_cost() -> Dictionary:
    if purse_level >= PURSE_TIERS.size() - 1:
        return {"can_upgrade": false}

    var next_tier = PURSE_TIERS[purse_level + 1]

    if "cost_copper" in next_tier:
        return {
            "can_upgrade": true,
            "currency_type": "copper",
            "cost": next_tier.cost_copper,
            "new_cap": next_tier.cap,
            "name": next_tier.name
        }
    elif "cost_silver" in next_tier:
        return {
            "can_upgrade": true,
            "currency_type": "silver",
            "cost": next_tier.cost_silver,
            "new_cap": next_tier.cap,
            "name": next_tier.name
        }

    return {"can_upgrade": false}

func purchase_purse_upgrade() -> bool:
    var cost_info = get_purse_upgrade_cost()
    if not cost_info.can_upgrade:
        return false

    # Deduct cost
    if cost_info.currency_type == "copper":
        if currency.copper >= cost_info.cost:
            currency.copper -= cost_info.cost
        else:
            return false
    elif cost_info.currency_type == "silver":
        if currency.silver >= cost_info.cost:
            currency.silver -= cost_info.cost
        else:
            return false

    # Apply upgrade
    purse_level += 1
    Global.show_stat_notification("Purse upgraded: %s (capacity %d)" %
                                 [cost_info.name, cost_info.new_cap])
    save_game()
    return true
```

---

## 3. Market Volatility System

### Backend State (currency_manager.gd)

**Already exists** but needs minor updates:

```gdscript
# Market volatility (±30% max deviation, bell curve)
var market_volatility: Dictionary = {
    CurrencyType.COPPER: 0.0,   # Fluctuates vs silver (laborers)
    CurrencyType.SILVER: 0.0,   # Fluctuates vs gold (merchants)
    CurrencyType.GOLD: 0.0      # Fluctuates vs platinum (nobles)
    # Platinum has no volatility (stable anchor)
}

var conversion_rate_modifiers = {
    CurrencyType.COPPER: 1.0,
    CurrencyType.SILVER: 1.0,
    CurrencyType.GOLD: 1.0,
    CurrencyType.PLATINUM: 1.0  # Always 1.0 (stable)
}

var market_update_timer: float = 0.0
var next_market_update_interval: float = 900.0  # 15 minutes default

func _process(delta):
    market_update_timer += delta
    if market_update_timer >= next_market_update_interval:
        market_update_timer = 0.0
        update_market_rates()

func update_market_rates():
    # Set next update interval (15-30 minutes)
    next_market_update_interval = randf_range(900.0, 1800.0)

    # Update rates with bell curve (Copper, Silver, Gold only)
    for currency_type in [CurrencyType.COPPER, CurrencyType.SILVER, CurrencyType.GOLD]:
        var deviation = randfn(0.0, 0.1)  # Normal distribution, std dev 0.1
        deviation = clamp(deviation, -0.3, 0.3)  # ±30% max (±20% user spec is within this)
        market_volatility[currency_type] = deviation
        conversion_rate_modifiers[currency_type] = 1.0 + deviation

        # Show notification for extremes (±20-30% range)
        var notification = get_extreme_market_notification(currency_type)
        if notification != "":
            Global.show_stat_notification(notification)

    DebugLogger.log_info("MarketUpdate", "Rates: C=%.2f, S=%.2f, G=%.2f, P=1.00" % [
        conversion_rate_modifiers[CurrencyType.COPPER],
        conversion_rate_modifiers[CurrencyType.SILVER],
        conversion_rate_modifiers[CurrencyType.GOLD]
    ])
```

### Market Display API (for ATM UI)

```gdscript
func get_market_rates_display() -> Array:
    # Returns inverted format for intuitive display: "1 silver = 950 copper"
    var rates = []

    # Copper to Silver
    var copper_mod = conversion_rate_modifiers[CurrencyType.COPPER]
    var silver_mod = conversion_rate_modifiers[CurrencyType.SILVER]
    var copper_per_silver = (1000.0 * copper_mod) / silver_mod
    rates.append({
        "from": "silver",
        "to": "copper",
        "display": "1 silver = %d copper" % int(copper_per_silver)
    })

    # Silver to Gold
    var gold_mod = conversion_rate_modifiers[CurrencyType.GOLD]
    var silver_per_gold = (1000.0 * silver_mod) / gold_mod
    rates.append({
        "from": "gold",
        "to": "silver",
        "display": "1 gold = %d silver" % int(silver_per_gold)
    })

    # Gold to Platinum
    var gold_per_platinum = 1000.0 / gold_mod  # Platinum always 1.0
    rates.append({
        "from": "platinum",
        "to": "gold",
        "display": "1 platinum = %d gold" % int(gold_per_platinum)
    })

    return rates
```

### Discovery-Driven Design

**Players NEVER see:**
- Exact deviation values (±0.15, ±0.23, etc.)
- Bell curve formula (randfn, std dev 0.1)
- Update intervals (15-30 minutes)

**Players DO observe:**
- "1 silver = 950 copper" vs "1 silver = 1050 copper" (market fluctuates)
- "Yesterday got better rate, today worse" (timing matters)
- Extreme notifications hint at patterns: "Furnace accident: labor shortage drives copper rates"

---

## 4. Exchange System

### Transaction Fees (already implemented)

```gdscript
func calculate_transaction_fee(amount: float, from_type: int) -> float:
    var copper_value = amount * CONVERSION_RATES[from_type]
    var base_fee_percent = 0.08  # 8% base
    var scaling_factor = log(copper_value + 1) / 100000.0
    var fee_percent = base_fee_percent - (scaling_factor * 0.07)
    fee_percent = clamp(fee_percent, 0.01, 0.08)  # 1% to 8% range

    # Optional: Charisma reduces fees
    if Global.charisma > 1:
        var charisma_reduction = (Global.charisma - 1) * 0.02
        fee_percent *= (1.0 - charisma_reduction)
        fee_percent = max(fee_percent, 0.01)  # Minimum 1% fee

    return amount * fee_percent
```

### Exchange Preview (for ATM UI)

```gdscript
func preview_exchange(from_type: int, to_type: int, amount: float) -> Dictionary:
    # Calculate WITHOUT executing (for UI preview)

    if amount <= 0:
        return {"valid": false, "error": "invalid_amount"}

    var player_amount = _get_player_currency(from_type)
    if player_amount < amount:
        return {"valid": false, "error": "insufficient_funds"}

    # Calculate fee
    var fee = calculate_transaction_fee(amount, from_type)
    var net_amount = amount - fee

    # Calculate received (with market volatility)
    var from_rate = CONVERSION_RATES[from_type]
    var to_rate = CONVERSION_RATES[to_type]
    var to_modifier = conversion_rate_modifiers[to_type]

    var received = (net_amount * from_rate) / (to_rate * to_modifier)

    return {
        "valid": true,
        "amount": amount,
        "fee": fee,
        "net_after_fee": net_amount,
        "received": received,
        "from_type": from_type,
        "to_type": to_type,
        "market_modifier": to_modifier
    }

func exchange_currency_with_fee(from_type: int, to_type: int, amount: float) -> Dictionary:
    var preview = preview_exchange(from_type, to_type, amount)

    if not preview.valid:
        return {"success": false, "error": preview.error}

    # Execute exchange
    var deducted = _deduct_currency(from_type, amount)
    if not deducted:
        return {"success": false, "error": "deduction_failed"}

    var added = add_currency(to_type, preview.received, "exchange")

    # Track exchange
    var exchange_key = "%s_to_%s" % [
        CURRENCY_NAMES[from_type].to_lower(),
        CURRENCY_NAMES[to_type].to_lower()
    ]
    if exchange_key in Level1Vars.lifetime_exchanges:
        Level1Vars.lifetime_exchanges[exchange_key] += 1

    var fee_copper_value = preview.fee * CONVERSION_RATES[from_type]
    Level1Vars.lifetime_exchanges.total_fees_paid_copper += fee_copper_value

    # Award charisma XP based on fee paid
    Global.add_stat_exp("charisma", fee_copper_value)

    return {
        "success": true,
        "fee": preview.fee,
        "received": added,  # Actual amount added (may be less due to capacity)
        "market_rate": preview.market_modifier
    }
```

---

## 5. Currency Unlock System

### Currency Unlocks vs Era Transitions

**IMPORTANT**: These are separate systems:
- **Currency unlocks**: Backend tracks which currencies exist (can be used in exchanges)
- **Conversion visibility**: ATM UI shows/hides conversion options based on coin thresholds (see ATM UI plan)
- **Era transitions**: Gameplay progression (handled in era-specific plans, not here)

### Unlock Triggers (Backend Only)

**Copper:** Always unlocked (starting currency)

**Silver:** Unlocked by gameplay progression (TBD in copper era plans)
- When unlocked, silver currency becomes available for use
- ATM conversion visibility separate (700 coin threshold - see ATM UI plan)

**Gold:** Unlocked by gameplay progression (TBD in silver era plans)
- When unlocked, gold currency becomes available for use
- ATM conversion visibility separate (700 coin threshold - see ATM UI plan)

**Platinum:** Unlocked by gameplay progression (TBD in gold era plans)
- Escape goal for Level 1 completion
- ATM conversion visibility separate (700 coin threshold - see ATM UI plan)

### Implementation

```gdscript
# In currency_manager.gd
var unlocked_currencies = {
    CurrencyType.COPPER: true,   # Always available
    CurrencyType.SILVER: false,  # Unlocked by gameplay (era plans)
    CurrencyType.GOLD: false,    # Unlocked by gameplay (era plans)
    CurrencyType.PLATINUM: false # Unlocked by gameplay (era plans)
}

func unlock_currency(currency_type: int):
    if not unlocked_currencies[currency_type]:
        unlocked_currencies[currency_type] = true
        var name = CURRENCY_NAMES_PLURAL[currency_type]
        Global.show_stat_notification("%s now available" % name)
        DebugLogger.log_milestone("%s unlocked" % name)

func is_currency_unlocked(currency_type: int) -> bool:
    return unlocked_currencies.get(currency_type, false)
```

**Note**: Era-specific plans will call `CurrencyManager.unlock_currency()` at appropriate times. This backend just provides the unlock mechanism.

---

## 6. Era Tracking

### Era Progression

```gdscript
# In level_1_vars.gd
var current_era: String = "copper"  # "copper", "silver", "gold"

func transition_to_era(new_era: String):
    if new_era == current_era:
        return  # Already in this era

    var valid_transitions = {
        "copper": ["silver"],
        "silver": ["copper", "gold"],  # Can drop back to copper if doing poorly
        "gold": []  # No transitions from gold (endgame)
    }

    if new_era in valid_transitions[current_era]:
        var old_era = current_era
        current_era = new_era
        Global.show_stat_notification("Era transition: %s -> %s" % [old_era, new_era])
        DebugLogger.log_milestone("Era changed: %s" % new_era)
        save_game()
    else:
        push_error("Invalid era transition: %s -> %s" % [current_era, new_era])
```

**Note:** Actual era transition logic (bribes, certification, etc.) will be in separate plans.

---

## 7. Save/Load Integration

### Variables to Persist

```gdscript
# In level_1_vars.gd save_game()
save_data["currency"] = currency
save_data["lifetime_currency"] = lifetime_currency
save_data["current_era"] = current_era
save_data["purse_level"] = purse_level
save_data["lifetime_exchanges"] = lifetime_exchanges

# In level_1_vars.gd load_game()
currency = save_data.get("currency", {"copper": 0.0, "silver": 0.0, "gold": 0.0, "platinum": 0.0})
lifetime_currency = save_data.get("lifetime_currency", {"copper": 0.0, "silver": 0.0, "gold": 0.0, "platinum": 0.0})
current_era = save_data.get("current_era", "copper")
purse_level = save_data.get("purse_level", 0)
lifetime_exchanges = save_data.get("lifetime_exchanges", {
    "copper_to_silver": 0, "silver_to_copper": 0,
    "silver_to_gold": 0, "gold_to_silver": 0,
    "gold_to_platinum": 0, "platinum_to_gold": 0,
    "total_fees_paid_copper": 0.0
})
```

### Variables NOT Persisted

```gdscript
# In currency_manager.gd _ready()
# Market volatility resets each session (prevents save-scumming)
func _ready():
    update_market_rates()  # Generate fresh rates on load
```

---

## 8. API Design

### CurrencyManager Public API

```gdscript
# Currency operations
add_currency(type: int, amount: float, reason: String = "earned") -> float
can_afford(cost) -> bool  # Accepts float (copper) or dict {"copper": X, "silver": Y}
deduct_currency(cost) -> bool

# Exchange operations
preview_exchange(from_type: int, to_type: int, amount: float) -> Dictionary
exchange_currency_with_fee(from_type: int, to_type: int, amount: float) -> Dictionary

# Market information
get_market_rates_display() -> Array
get_current_market_modifier(currency_type: int) -> float

# Capacity information
get_total_copper_value() -> float
get_current_capacity() -> int
get_capacity_info() -> Dictionary

# Unlock status
is_currency_unlocked(currency_type: int) -> bool
```

### Level1Vars Public API

```gdscript
# Purse management
can_afford_purse_upgrade() -> bool
get_purse_upgrade_cost() -> Dictionary
purchase_purse_upgrade() -> bool

# Era management
transition_to_era(new_era: String) -> void
```

---

## 9. Integration with Existing Systems

### Uses Global APIs

```gdscript
Global.add_stat_exp("charisma", xp_amount)  # Exchange fees grant charisma XP
Global.show_stat_notification(message)  # All feedback to player
```

### Uses DebugLogger

```gdscript
DebugLogger.log_resource_change("currency", "copper", old, new, reason)
DebugLogger.log_milestone("Silver currency unlocked")
DebugLogger.log_info("MarketUpdate", "Rates: C=%.2f S=%.2f G=%.2f")
```

### Future System Hooks

- **ATM UI Plan:** Calls market display, preview, exchange, capacity APIs
- **Purse Upgrade UI:** Calls purse cost, purchase APIs
- **Copper Era End Plan:** Handles silver era transition (bribes, certification)
- **Worker Payment (Gold Era):** Uses deduct_currency(), market modifiers affect morale
- **Shop System:** Uses can_afford(), deduct_currency() with multi-currency costs

---

## 10. Implementation Checklist

### Phase 1: Data Structures (3-4h)
- [ ] Add purse_level, PURSE_TIERS to level_1_vars.gd
- [ ] Add current_era, lifetime_exchanges to level_1_vars.gd
- [ ] Update save/load functions
- [ ] Test save/load persistence

### Phase 2: Capacity System (4-5h)
- [ ] Implement get_total_coin_count() (count coins, not value)
- [ ] Implement get_capacity_info() (coin-based)
- [ ] Update add_currency() with capacity enforcement (coin count)
- [ ] Implement purse upgrade functions
- [ ] Add capacity warning notifications
- [ ] Test capacity limits with mixed currencies (1000 cap = 1000 coins total)

### Phase 3: Market & Exchange (3-4h)
- [ ] Verify market volatility system works
- [ ] Implement get_market_rates_display()
- [ ] Implement preview_exchange()
- [ ] Update exchange_currency_with_fee() with tracking
- [ ] Test exchange calculations with volatility

### Phase 4: Unlocks & Era (2-3h)
- [ ] Implement unlock_currency() function
- [ ] Implement is_currency_unlocked() check
- [ ] Implement transition_to_era()
- [ ] Add era transition validation
- [ ] Test unlock mechanism (actual triggers in era plans)

### Phase 5: Testing (3-4h)
- [ ] Write unit tests (test_currency_economy.gd)
- [ ] Test capacity enforcement edge cases
- [ ] Test market volatility bounds
- [ ] Test exchange fee scaling
- [ ] Manual playthrough testing

**Total Estimate:** 15-20 hours

---

## 11. Critical Files

### Files to Modify

**currency_manager.gd** (~200 lines added/modified)
- Capacity checking functions (coin count, not value)
- Market display API
- Exchange preview function
- Currency unlock mechanism (unlock_currency function)
- Enhanced exchange tracking

**level1/level_1_vars.gd** (~150 lines added/modified)
- Purse tier constants
- Era tracking variables
- Lifetime exchange tracking
- Purse upgrade functions
- Era transition function
- Save/load updates

**tests/test_currency_economy.gd** (~400 lines new)
- Capacity enforcement tests (coin count based)
- Multi-currency capacity tests (verify 1000 cap = 1000 coins of any mix)
- Exchange preview accuracy tests
- Market volatility bounds tests
- Fee scaling tests
- Currency unlock mechanism tests
- Era transition tests
- Save/load persistence tests

---

## 12. Notes for ATM UI Plan

The ATM UI plan (separate) should handle:

1. **Currency Exchange UI:**
   - Dropdown menus for from/to currency selection
   - Amount input field
   - Preview display showing "X copper → Y silver (broker takes Z copper)"
   - Exchange button

2. **Conversion Visibility Rules:**
   - Copper → Silver conversion hidden until player has 700+ copper in inventory
   - Silver → Gold conversion hidden until player has 700+ silver in inventory
   - Gold → Platinum visible when platinum unlocked

3. **Market Rates Display:**
   - Shows current rates from get_market_rates_display()
   - Updates when market changes
   - Inverted format: "1 silver = 950 copper"

4. **Purse Upgrade UI:**
   - Shows current purse tier and capacity
   - Displays next upgrade cost and new capacity
   - Purchase button (calls Level1Vars.purchase_purse_upgrade())
   - Visual capacity bar

5. **Capacity Display:**
   - Total value bar showing fill percentage
   - Warning colors (green < 80%, yellow 80-90%, red 90%+)
   - Numerical display: "850 / 1400 copper value"

---

## Design Rationale

### Why Coin Count Capacity (not Value)?

- **User requirement:** "A coin is a coin, whether copper, silver, gold, or platinum"
- **Thematic:** Physical purse size, not value-based vault
- **Simpler:** 1000 capacity = 1000 coins (any mix), easy mental model
- **Strategic depth:** Hold many cheap coins vs few valuable coins?
- **Natural gate:** Forces purse upgrades and currency exchanges to progress

### Why Discovery-Based?

- **Engagement:** Players learn through observation, not tutorials
- **Replayability:** Different market conditions each playthrough
- **Satisfaction:** Discovering optimal exchange timing feels rewarding
- **Grimdark theme:** Oppressive system where workers must learn through experience

### Why Transparent Exchange Costs?

- **User requirement:** "Player should generally know the cost/payout when converting"
- **Reduces frustration:** Hidden exchange rates feel unfair
- **Discovery still exists:** Formulas hidden, but results observable
- **Learning curve:** Players see "100c → 0.92s" and infer ~8% fee over time

### Why Progressive Purse Pricing?

- **Era alignment:** Copper-priced purses in copper era, silver-priced in silver era
- **Natural progression:** Don't need to convert currency just to buy purses
- **Capacity gates content:** Can't progress to silver era without higher capacity

---

**Status:** Ready for implementation
**Next Steps:** Implement backend, then create separate ATM UI plan

