# Base Systems - Project Architecture

## Overview
This plan outlines the folder structure, autoload strategy, and architectural patterns for GoA - designed for a clean, scalable multi-level idle game with era-based progression.

## Design Principles
1. **Clean Root** - Minimal files in project root
2. **Organized by Scope** - Global, level, and era-specific folders
3. **No Migration** - Fresh rebuild from scratch
4. **Scalable** - Easy to add new levels and eras
5. **Clear Separation** - Global persistence vs. level-specific vs. era-specific

---

## Folder Structure

```
GoA/
├── project.godot                    # Godot project file
├── icon.svg                         # Project icon
│
├── global/                          # PERSISTENT SYSTEMS (survive all scene changes)
│   ├── global-stats.gd              # Autoload: int, con, str, dex, exp system
│   ├── global-scene-manager.gd      # Autoload: scene transitions, era changes
│   ├── global-notifications.gd      # Autoload: stat notifications, messages
│   ├── global-timer.gd              # Autoload: game-wide tick system
│   └── ui/                          # UI that persists across ALL scenes
│       ├── persistent-hud.tscn      # Always-visible HUD (stats display, etc.)
│       └── notification-popup.tscn  # Notification system UI
│
├── save-system/                     # SAVE/LOAD (cross-level persistence)
│   ├── save-manager.gd              # Autoload: handles save/load operations
│   ├── save-data.gd                 # Data structure for save files
│   └── saves/                       # Actual save files directory
│       └── .gitkeep
│
├── themes/                          # VISUAL THEMES
│   ├── default-theme.tres           # Base theme for entire game
│   ├── copper-theme.tres            # Optional: copper era styling
│   └── silver-theme.tres            # Optional: silver era styling
│
├── levels/                          # LEVEL ORGANIZATION
│   ├── level-1/                     # First level
│   │   ├── level-1-vars.gd          # Autoload: level-specific config & data
│   │   ├── level-1-main.tscn        # Entry point for level 1
│   │   ├── level-1-main.gd          # Level controller script
│   │   │
│   │   ├── eras/                    # Era-based gameplay stages
│   │   │   ├── copper/
│   │   │   │   ├── copper-era.tscn      # Main copper era scene
│   │   │   │   ├── copper-era.gd        # Copper gameplay logic
│   │   │   │   ├── copper-shop.tscn     # Shop (copper-specific)
│   │   │   │   ├── copper-shop.gd
│   │   │   │   ├── copper-workers.gd    # Worker mechanics
│   │   │   │   └── ui/
│   │   │   │       ├── copper-ui.tscn   # Era-specific UI
│   │   │   │       └── copper-buttons.tscn
│   │   │   │
│   │   │   ├── silver/
│   │   │   │   ├── silver-era.tscn
│   │   │   │   ├── silver-era.gd
│   │   │   │   ├── silver-mechanics.gd  # Different gameplay than copper
│   │   │   │   └── ui/
│   │   │   │       └── silver-ui.tscn
│   │   │   │
│   │   │   └── gold/
│   │   │       ├── gold-era.tscn
│   │   │       ├── gold-era.gd
│   │   │       └── ui/
│   │   │
│   │   └── shared/                  # Shared between eras in level 1
│   │       ├── level-1-currency.gd  # Currency system (persists in level)
│   │       ├── level-1-resources.gd # Resources that carry between eras
│   │       └── common-ui/           # UI reused across eras
│   │
│   ├── level-2/                     # Future level
│   │   ├── level-2-vars.gd
│   │   ├── level-2-main.tscn
│   │   └── eras/
│   │       └── ...
│   │
│   └── level-3/                     # Future level
│       └── ...
│
└── .claude/                         # Claude development files
    ├── plans/
    ├── docs/
    ├── hooks/
    └── skills/
```

---

## Autoload (Singleton) Strategy

**What Gets Autoloaded:**
Autoloads are scripts that load once and persist forever. They're accessible from anywhere.

### Global Autoloads (Always Active)
```
GlobalStats          -> global/global-stats.gd
SceneManager         -> global/global-scene-manager.gd
Notifications        -> global/global-notifications.gd
GameTimer            -> global/global-timer.gd
SaveManager          -> save-system/save-manager.gd
```

### Level-Specific Autoloads (Conditional)
```
Level1Vars           -> levels/level-1/level-1-vars.gd
Level2Vars           -> levels/level-2/level-2-vars.gd
```
**Note:** Level vars are autoloaded but only contain data relevant to their level. When switching levels, you access the appropriate one (Level1Vars vs Level2Vars).

### NOT Autoloaded
- Era-specific scripts (copper-era.gd, silver-era.gd) - these are scene-specific
- Shop scripts - instantiated when needed
- UI components - loaded with their scenes

---

## Data Persistence Model

### Global Data (Never Resets)
- **Stats:** int, con, str, dex + their experience
- **Unlocks:** permanent achievements, meta-progression
- **Settings:** audio, graphics preferences

### Level Data (Resets Between Levels)
- **Currency:** gold, resources specific to that level
- **Progress:** current era (copper/silver/gold)
- **Level-specific unlocks:** workers, upgrades

### Era Data (Resets on Era Change)
- **Temporary buffs:** era-specific bonuses
- **Active workers:** current workers in this era
- **UI state:** which panels are open

---

## Scene Hierarchy

```
Main Entry Point
└── level-1-main.tscn
    ├── PersistentHUD (from global/ui/)
    ├── EraContainer (holds current era scene)
    │   └── [copper-era.tscn OR silver-era.tscn OR gold-era.tscn]
    └── NotificationLayer (from global/ui/)
```

**How It Works:**
1. Game starts at `level-1-main.tscn`
2. Level controller loads the appropriate era scene into EraContainer
3. When player drops from silver to copper, controller swaps the era scene
4. PersistentHUD and notifications stay visible during era changes

---

## Era Transition System

### Triggering Era Changes
```gdscript
# In level-1-main.gd
func check_era_status():
    var current_gold = Level1Vars.currency

    if current_gold >= SILVER_THRESHOLD and current_era == "copper":
        transition_to_era("silver")
    elif current_gold < COPPER_THRESHOLD and current_era == "silver":
        transition_to_era("copper")  # Player failed, drops back

func transition_to_era(era_name: String):
    # Unload current era scene
    # Save era-specific state if needed
    # Load new era scene into EraContainer
    # Initialize new era with persistent data
```

### What Persists During Era Transitions
- Global stats (int, con, str, dex)
- Currency (level-1 gold)
- Level progress
- Persistent UI

### What Resets During Era Transitions
- Era-specific workers
- Temporary buffs
- UI panel states

---

## File Naming Conventions

### Scripts
- Lowercase with hyphens: `copper-shop.gd`, `global-stats.gd`
- Match scene names: `copper-era.tscn` + `copper-era.gd`

### Scenes
- Lowercase with hyphens: `level-1-main.tscn`, `silver-era.tscn`
- Descriptive: `persistent-hud.tscn`, not `hud.tscn`

### Folders
- Lowercase with hyphens: `save-system/`, `global/`
- Plural for collections: `eras/`, `levels/`, `themes/`

### Resources
- Lowercase with hyphens: `default-theme.tres`, `copper-theme.tres`

### Plans & Docs
- Numbered with hyphens: `1.1-base-systems-architecture.md`
- Semantic versioning: `1.x` for planning, `2.x` for systems, etc.

---

## What Goes Where - Quick Reference

### Put in `global/` if:
- Used across ALL levels
- Survives scene changes
- Manages core game state (stats, notifications)

### Put in `levels/level-X/` if:
- Specific to one level
- Resets when level changes
- Level configuration data

### Put in `levels/level-X/eras/era-name/` if:
- Specific to one era within a level
- Different mechanics per era
- Era-specific UI

### Put in `levels/level-X/shared/` if:
- Used by multiple eras in the same level
- Persists between era changes within the level
- Common UI or utilities for this level

### Put in `save-system/` if:
- Related to saving/loading game state
- Serialization logic
- Save file management

### Put in `themes/` if:
- Visual styling
- Fonts, colors, UI appearance
- Reusable theme resources

---

## Migration Notes

**This is a scratch rebuild - no file migration needed.**

When implementing:
1. Start with global systems (stats, scene manager)
2. Build level-1-main structure
3. Implement copper era (simplest)
4. Add era transition logic
5. Implement silver/gold eras
6. Add save/load system

---

## Additional Architectural Considerations

### 1. Event Bus Pattern
Consider adding `global/event-bus.gd` for decoupled communication:
- Era transitions emit signals
- Stats changes broadcast events
- UI listens without tight coupling

### 2. Resource Management
Create `levels/level-1/shared/resources/` for:
- Shared textures
- Shared audio
- Shared data files (JSON configs)

### 3. Debug Tools
Consider `global/debug/` folder for:
- Debug overlay
- Cheat codes
- Performance monitoring

### 4. Modular UI Components
Consider `global/ui/components/` for:
- Reusable buttons
- Common panels
- Shared widgets

### 5. State Machine for Eras
Each era could use a state machine pattern:
- ENTERING (transition in)
- ACTIVE (normal gameplay)
- EXITING (transition out)

---

## Questions to Resolve

[ANSWER THESE BEFORE IMPLEMENTATION]

1. **Loading Screen**: Should there be a loading screen between era transitions?
   - [ ] Answer:

2. **Era Unlock Logic**: What determines when silver/gold unlock initially?
   - [ ] Answer:

3. **Multiple Level Entry**: How does player select which level to play?
   - [ ] Answer:

4. **Save Slots**: Single save or multiple save slots?
   - [ ] Answer:

5. **Era-Specific Resources**: Do textures/audio live with each era, or shared folder?
   - [ ] Answer:

6. **Event Bus**: Should we implement a global event bus for decoupled communication?
   - [ ] Answer:

7. **Debug Tools**: Should we create a debug folder with development tools?
   - [ ] Answer:

---

## Implementation Priority

1. **Phase 1 - Foundation**
   - Create folder structure
   - Set up global autoloads
   - Build level-1-main entry point

2. **Phase 2 - Copper Era**
   - Implement copper-era scene
   - Port existing shop to new structure
   - Test era as standalone

3. **Phase 3 - Era System**
   - Build era transition logic
   - Implement fallback (silver to copper)
   - Test era switching

4. **Phase 4 - Additional Eras**
   - Implement silver era mechanics
   - Implement gold era mechanics
   - Polish transitions

5. **Phase 5 - Persistence**
   - Build save-system
   - Test save/load across eras
   - Test save/load across levels

---

## Success Criteria

- [ ] Root folder contains only essential Godot files
- [ ] Global systems accessible from anywhere
- [ ] Era transitions work smoothly (silver -> copper fallback)
- [ ] Currency persists between eras
- [ ] Stats persist everywhere
- [ ] Clear separation of global/level/era code
- [ ] Easy to add new levels following the pattern
- [ ] Consistent naming conventions throughout
