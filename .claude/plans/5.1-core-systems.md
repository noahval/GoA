# Phase 5.1: Core Systems

**Part of:** Phase 5 - Own Furnace and Worker Management
**Status:** Planning
**Created:** 2025-11-25 (Split from phase-5-own-furnace.md)
**Dependencies:** Phases 1-4 (basic furnace mechanics, shop system, stats)

**Currency System Note:** All costs in this document use the multi-currency system:
- 1 Silver = 1000 Copper
- 1 Gold = 1000 Silver
- 1 Platinum = 1000 Gold

Phase 5 begins at ~20 hours of gameplay, when players spend 1 gold to buy their own furnace.

## Overview

Phase 5 represents a major shift in gameplay from being a worker in the Blackbore Furnace to becoming the owner and manager of your own furnace operation. This transition eliminates the overseer-based coin conversion system and introduces a new economy based on steam production, train operations, and meeting fluctuating demand.

### Core Gameplay Loop
1. **Generate Heat** - Shovel coal manually or via workers
2. **Produce Steam** - Heat converts to steam over time
3. **Meet Demand** - Steam demand fluctuates based on train conditions
4. **Earn Revenue** - Get paid based on how well you meet demand
5. **Manage Workers** - Hire and upgrade workers to optimize production

## Key Design Principles

- **Charisma as obscure stat** - No explicit UI, but affects worker efficiency subtly
- **Leadership over labor** - Player manages and leads rather than shovels
- **No visual assets needed** (text-based UI following existing patterns)
- **New scene creation** - owned_furnace.tscn replaces furnace.tscn after purchase
- **Dynamic demand system** - Creates pressure and opportunity
- **Progressive worker management** - Starts simple, scales in complexity

---

## New Metrics & Systems

### 1. Furnace Heat

**Purpose:** Intermediate resource between coal shoveling and steam production

**Properties:**
- Type: Float, can accumulate
- Generation sources:
  - Manual shoveling: +1 heat per shovel (affected by strength bonuses)
  - Workers: Generate heat automatically based on worker level/count
  - Coal burning: Could implement coal auto-consumption for bonus heat
- Decay: Heat slowly dissipates over time (requires constant shoveling/workers)
- Display: Visual meter showing current heat level

**Formula:**
```gdscript
heat_per_shovel = 1.0
heat_decay_rate = 0.5  # per second
current_heat = clamp(current_heat - (heat_decay_rate * delta), 0, max_heat)
```

**Max Heat (Based on Real Materials):**
Max heat is determined by furnace construction material, wall thickness, and refractory lining:
```gdscript
max_heat = base_temp_limit * thickness_multiplier * lining_multiplier
```

See "Furnace Material & Construction System" section below for detailed progression.

### 2. Steam Production

**Purpose:** Primary output resource that fulfills demand, measured in pounds per hour (lb/h)

**Properties:**
- Type: Float, measured in lb/h (pounds per hour)
- Production rate: Based on current heat level
- **No initial storage** - steam converts directly to gold payment
- Storage: Purchasable upgrade (unlocks about 3H into own furnace phase, starts at 5 gold)
- Display: Production rate gauge in lb/h

**Formula:**
```gdscript
# Steam production in pounds per hour (lb/h)
steam_production_rate_lbh = (current_heat / 10.0) * steam_efficiency
steam_efficiency = 1.0 + (furnace_upgrade_lvl * 0.2)

# Starting production: 10 lb/h
base_production = 10.0  # lb/h at base heat and efficiency

# Storage only available after purchase
has_storage_system = false  # Initially no storage
max_storage_lbs = 0.0  # Set when storage purchased (e.g., 500 lb for Tier 1)
```

### 3. Steam Demand (Dynamic System) ⭐

**Purpose:** Creates dynamic gameplay with fluctuating requirements, measured in decimals of gold coin per lb/h

**Demand States:**
- **Very Low Demand**: Range 0.0x - 0.45x (avg ~0.225x) - Train idling, coasting downhill, rare low revenue/storage opportunity
  - Oscillation period: 40-60s (slow, lazy drift)
- **Low Demand**: Range 0.45x - 0.75x (avg ~0.6x) - Light load, slow operation, reduced payment
  - Oscillation period: 30-40s (relaxed variation)
- **Medium Demand**: Range 0.75x - 1.35x (avg ~1.05x) - Steady operation on flat terrain, baseline payment
  - Oscillation period: 25-30s (standard rhythm)
- **High Demand**: Range 1.35x - 2.65x (avg ~2.0x) - Climbing grade, accelerating, bonus revenue opportunity
  - Oscillation period: 15-25s (urgent fluctuation)
- **Critical Demand**: Range 2.65x - 3.75x (avg ~3.2x) - Steep hill, emergency conditions, maximum revenue/stress event
  - Oscillation period: 10-20s (frantic, emergency pace)

**Note:** Multipliers smoothly interpolate within each state's range using sine wave oscillation with state-dependent periods. When state changes, multiplier starts at a random point within the new state's range for unpredictable transitions.

**Properties:**
- Type: Float, represents steam demand rate in lb/h (pounds per hour)
- Base demand: Starting around 10-15 lb/h at medium state
- Demand scales with train progression and upgrades
- Transition: Changes every 1-5 minutes (triangular distribution, avg ~2.5 min)
- Payment: Steam production × demand multiplier → Gold coins

**Environmental Factors:**
```gdscript
# Demand reasons (displayed to player)
DEMAND_REASONS = {
    "very_low": [
        "Coasting downhill: gravity assist",
        "Long downgrade through valley",
        "Descending eastern slope: minimal power",
        "Momentum carrying train through lowlands",
        "Deep night, all train districts sleeping",
        "Holiday, minimal train systems active",
        "Lower districts powered down for conservation",
        "Peasant quarters population reduced, less demand",
        "Gentle downhill run through foothills",
        "Slight descent, brakes engaged",
        "Cruising through lowland plains",
        "Tail wind assisting movement",
        "Rolling through river valley",
        "Night shift, residential districts dormant",
        "Mild weather, reduced heating demands",
        "Backup furnaces handling train base load",
        "Worker districts on rationing schedule",
        "Lower deck amenities disabled"
    ],
    "low": [
        "Light downgrade into basin",
        "Steady cruise on flat prairie",
        "Easy rolling through farmlands",
        "Gentle curves, maintaining speed",
        "Approaching downhill section",
        "Following river downstream",
        "Off-peak hours, light train demand",
        "Temperate weather, reduced steam demand",
        "Other furnaces covering most train needs",
        "Peasant district scheduled blackout period",
        "Third class quarters on reduced power allocation"
    ],
    "normal": [
        "Steady run on flat terrain",
        "Cruising across plains",
        "Maintaining speed through open country",
        "Regular travel pace",
        "Standard train operations",
        "Balanced residential and commercial load",
        "lower level amenities powered on"
    ],
    "high": [
        "Climbing toward High Peak",
        "Ascending the eastern slope",
        "Pulling uphill through switchbacks",
        "Fighting headwinds across plateau",
        "Accelerating from reduced speed",
        "Sharp curves requiring power",
        "Pushing through mountain pass",
        "Morning rush: all elevators running",
        "Factory district at full production",
        "Cold snap, residential heating surge",
        "Nobility ball: upper district lighting maxed",
        "Elite quarter demanding perfect climate control"
    ],
    "critical": [
        "Emergency! Climbing Devil's Backbone!",
        "Steep grade: maximum power needed!",
        "Triple switchback up Iron Mountain!",
        "Fighting blizzard headwinds uphill!",
        "Emergency acceleration required!",
        "Extreme grade with heavy load!",
        "All other furnaces failed!",
        "Catastrophic pressure drop: full steam NOW!",
        "Noble override: lower districts cut off!",
        "Aristocrat emergency: maximum power demanded!"
    ]
}
```

**Demand Fluctuation Logic:**
```gdscript
# Range definitions for each demand state
const DEMAND_RANGES = {
    "very_low": {"min": 0.0, "max": 0.45},      # Avg ~0.225x (replaces "zero")
    "low": {"min": 0.45, "max": 0.75},          # Avg ~0.6x
    "medium": {"min": 0.75, "max": 1.35},       # Avg ~1.05x
    "high": {"min": 1.35, "max": 2.65},         # Avg ~2.0x
    "critical": {"min": 2.65, "max": 3.75}      # Avg ~3.2x
}

# State variables
var demand_state: String = "medium"
var demand_multiplier: float = 1.05
var target_range_min: float = 0.75
var target_range_max: float = 1.35
var interpolation_time: float = 0.0
var interpolation_speed: float = 0.3  # Controls oscillation period (~27s)
var demand_timer: float = 150.0

func _process(delta):
    # Smooth sine wave interpolation within current range
    interpolation_time += delta * interpolation_speed
    var normalized = (sin(interpolation_time) + 1.0) / 2.0
    demand_multiplier = lerp(target_range_min, target_range_max, normalized)

    # Check for state change (timer-based)
    demand_timer -= delta
    if demand_timer <= 0:
        change_demand_state()
        # Triangular distribution: 1-5 minutes, weighted toward 2.5 minutes
        var rand1 = randf_range(60.0, 180.0)  # 1-3 minutes
        var rand2 = randf_range(60.0, 300.0)  # 1-5 minutes
        demand_timer = (rand1 + rand2) / 2.0  # Averages ~2.5 minutes

func change_demand_state():
    # Weighted random selection (5 states - "zero" removed)
    var roll = randf()
    if roll < 0.20:  # 20% very_low (+10% from removed "zero")
        set_demand_state("very_low")
    elif roll < 0.35:  # 15% low
        set_demand_state("low")
    elif roll < 0.70:  # 35% medium
        set_demand_state("medium")
    elif roll < 0.85:  # 15% high
        set_demand_state("high")
    else:  # 15% critical
        set_demand_state("critical")

func set_demand_state(state: String):
    demand_state = state
    target_range_min = DEMAND_RANGES[state]["min"]
    target_range_max = DEMAND_RANGES[state]["max"]

    # Reset to middle of new range for smooth transitions
    demand_multiplier = (target_range_min + target_range_max) / 2.0
    interpolation_time = 0.0

    # Show notification with random reason
    var reason = DEMAND_REASONS[state][randi() % DEMAND_REASONS[state].size()]
    show_demand_notification(state, reason)
```

**Demand Fulfillment:**
```gdscript
var current_demand = base_demand * demand_multiplier
var steam_consumed = min(current_steam, current_demand * delta)
var fulfillment_rate = steam_consumed / (current_demand * delta)

# Performance tracking
if fulfillment_rate >= 1.0:
    performance = "excellent"  # Meeting or exceeding demand
elif fulfillment_rate >= 0.8:
    performance = "good"  # Mostly meeting demand
elif fulfillment_rate >= 0.5:
    performance = "poor"  # Struggling to keep up
else:
    performance = "failing"  # Severely underproducing
```

### 4. Steam Storage System ⭐ (PURCHASABLE UPGRADE - Not Available Initially)

**Purpose:** **Optional upgrade** to capture excess steam during low/zero demand periods for use during high demand spikes

**Important:** Players start with **NO storage** - steam converts directly to Gold payment. Storage must be purchased as an upgrade.

**Unlock Requirements:**
- Capacity Tier 1 purchase unlocks the entire storage system (with 50% base efficiency)

**NEW: Two Independent Upgrade Paths**

The storage system now offers two separate upgrade progressions:
- **Capacity Upgrades:** Increase storage tank size (5 tiers)
- **Efficiency Upgrades:** Reduce storage loss (5 tiers)

Both paths are sequential within themselves but independent of each other. Players can prioritize capacity, efficiency, or balance both based on strategy and budget.

---

#### A. Storage Capacity Upgrades (5 Tiers)

**Capacity Tier 1: Steam Accumulator Tank** *(First Purchase Unlocks Storage)*
- **Cost:** 5 gold
- **Capacity:** 300 lb storage
- **Base Efficiency:** 50% (requires efficiency upgrades to improve)
- **Technology:** Simple insulated pressure vessel
- **Historical:** 1800s technology, used on traction engines and early locomotives
- **Description:** "A basic pressure vessel that stores excess steam when demand is low"
- **Unlocks:** has_storage_system = true, storage_capacity_tier = 1, storage_efficiency_tier = 0

**Capacity Tier 2: Compressed Steam Reservoir**
- **Cost:** 20 gold
- **Requires:** Capacity Tier 1
- **Capacity:** 800 lb total (+500 lb)
- **Technology:** High-pressure compression system
- **Description:** "Stores steam at higher pressure for increased capacity"

**Capacity Tier 3: Multi-Chamber Storage System**
- **Cost:** 75 gold
- **Requires:** Capacity Tier 2
- **Capacity:** 1,500 lb total (+700 lb)
- **Technology:** Multiple interconnected tanks with valves
- **Feature:** Unlocks manual release controls (10% increments) and auto-release system
- **Description:** "Interconnected tanks allow precise control over steam release"

**Capacity Tier 4: Hydraulic Accumulator**
- **Cost:** 200 gold
- **Requires:** Capacity Tier 3
- **Capacity:** 2,500 lb total (+1,000 lb)
- **Technology:** Converts steam pressure to hydraulic pressure
- **Historical:** Used in Victorian-era hydraulic power networks (London, 1880s)
- **Description:** "Hydraulic system provides stable long-term storage"

**Capacity Tier 5: Battery Bank** *(Late Game)*
- **Cost:** 500 gold
- **Requires:** Capacity Tier 4 + Power System unlocked
- **Capacity:** 5,000 lb total (+2,500 lb)
- **Technology:** Electrical energy storage charged by steam turbine
- **Feature:** Maximum capacity for endgame storage needs
- **Description:** "Modern electrical storage provides massive capacity"

---

#### B. Storage Efficiency Upgrades (5 Tiers)

**Base:** 50% efficiency (when Capacity Tier 1 is purchased)

**Efficiency Tier 1: Improved Insulation**
- **Cost:** 7 gold
- **Requires:** Capacity Tier 1 (storage system unlocked)
- **Efficiency:** 60% (10% improvement from base)
- **Technology:** Cork and asbestos insulation layers
- **Description:** "Better insulation reduces heat loss when storing steam"

**Efficiency Tier 2: Double-Wall Construction**
- **Cost:** 25 gold
- **Requires:** Efficiency Tier 1
- **Efficiency:** 70% (20% total improvement from base)
- **Technology:** Vacuum-sealed double walls
- **Description:** "Double-wall design with vacuum gap minimizes thermal transfer"

**Efficiency Tier 3: Steam Trap System**
- **Cost:** 90 gold
- **Requires:** Efficiency Tier 2
- **Efficiency:** 80% (30% total improvement from base)
- **Technology:** Automatic condensate removal
- **Description:** "Prevents condensation losses with automatic steam traps"

**Efficiency Tier 4: Superheater Integration**
- **Cost:** 225 gold
- **Requires:** Efficiency Tier 3
- **Efficiency:** 90% (40% total improvement from base)
- **Technology:** Re-heats stored steam before use
- **Description:** "Superheater restores temperature to stored steam, reducing waste"

**Efficiency Tier 5: Perfect Thermal Management**
- **Cost:** 550 gold
- **Requires:** Efficiency Tier 4
- **Efficiency:** 100% (50% total improvement, no loss)
- **Technology:** Advanced thermal regulation and active heating
- **Description:** "Zero-loss storage through active thermal management"

**Storage Mechanics (Only Active After Purchase):**

```gdscript
# Level1Vars variables - NO initial storage
var has_storage_system: bool = false  # Must purchase Capacity Tier 1 to unlock
var storage_capacity_tier: int = 0  # 0 = none, 1-5 = capacity upgrade tiers
var storage_efficiency_tier: int = 0  # 0 = base (50%), 1-5 = efficiency upgrade tiers
var stored_steam_lbs: float = 0.0  # Pounds of stored steam
var max_storage_lbs: float = 0.0  # Starts at 0, set by capacity tier (300/800/1500/2500/5000 lb)
var storage_efficiency: float = 0.5  # 50% base, set by efficiency tier (60%/70%/80%/90%/100%)
var storage_diversion_percentage: float = 0.0  # % of steam production diverted to storage (0-100)
var auto_release_enabled: bool = false  # Unlocked at Capacity Tier 3
var auto_release_threshold: float = 1.8  # Auto-release when multiplier >= 1.8x (during high/critical demand)

# Capacity tier -> max storage mapping
const STORAGE_CAPACITIES = {
    0: 0.0,      # No storage
    1: 300.0,    # Steam Accumulator Tank
    2: 800.0,    # Compressed Steam Reservoir
    3: 1500.0,   # Multi-Chamber Storage
    4: 2500.0,   # Hydraulic Accumulator
    5: 5000.0    # Battery Bank
}

# Efficiency tier -> storage efficiency mapping
const STORAGE_EFFICIENCIES = {
    0: 0.5,   # Base 50%
    1: 0.6,   # Improved Insulation
    2: 0.7,   # Double-Wall Construction
    3: 0.8,   # Steam Trap System
    4: 0.9,   # Superheater Integration
    5: 1.0    # Perfect Thermal Management
}

# Payment variables (no initial storage, direct conversion)
var steam_production_rate_lbh: float = 10.0  # Starting: 10 lb/h
var demand_multiplier: float = 1.0  # Payment multiplier based on demand state
var gold_progress: float = 0.0  # Fractional gold accumulated

# In _process()
func _process(delta):
    # Calculate steam produced this tick (in pounds)
    var steam_lbs_this_tick = steam_production_rate_lbh * (delta / 3600.0)

    # WITHOUT STORAGE (initial state): Direct conversion to gold
    if not has_storage_system:
        var gold_earned = steam_lbs_this_tick * demand_multiplier * PAYMENT_RATE_CONSTANT
        gold_progress += gold_earned

        # Award whole gold coins
        if gold_progress >= 1.0:
            var whole_gold = floor(gold_progress)
            Level1Vars.current_gold += whole_gold
            gold_progress -= whole_gold

    # WITH STORAGE (after purchase): Handle storage/overflow logic
    else:
        # Check if producing excess steam relative to demand
        var demand_lbs = current_demand_rate_lbh * (delta / 3600.0)

        if steam_lbs_this_tick >= demand_lbs:
            # Excess steam - can store it
            var excess_lbs = steam_lbs_this_tick - demand_lbs
            var storable_lbs = excess_lbs * storage_efficiency
            var actually_stored = min(storable_lbs, max_storage_lbs - stored_steam_lbs)
            stored_steam_lbs += actually_stored

            # Payment from what was demanded
            var gold_earned = demand_lbs * demand_multiplier * PAYMENT_RATE_CONSTANT
            gold_progress += gold_earned
        else:
            # Deficit - use storage if available
            var deficit_lbs = demand_lbs - steam_lbs_this_tick
            var from_storage = min(deficit_lbs, stored_steam_lbs)
            stored_steam_lbs -= from_storage

            # Payment from production + storage
            var total_delivered = steam_lbs_this_tick + from_storage
            var gold_earned = total_delivered * demand_multiplier * PAYMENT_RATE_CONSTANT
            gold_progress += gold_earned

        # Award whole gold coins
        if gold_progress >= 1.0:
            var whole_gold = floor(gold_progress)
            Level1Vars.current_gold += whole_gold
            gold_progress -= whole_gold

    # Auto-release during high demand (if enabled and storage exists)
    # Uses multiplier-based trigger for precise control (not state-based)
    if has_storage_system and auto_release_enabled and demand_multiplier >= auto_release_threshold:
        if stored_steam_lbs > 0:
            release_stored_steam_manual(1.0)  # Release 100%

func release_stored_steam_manual(percentage: float):
    # Manual release of stored steam (increases production temporarily)
    var release_amount_lbs = max_storage_lbs * percentage
    var available_to_release = min(release_amount_lbs, stored_steam_lbs)

    # Boost production rate temporarily
    steam_production_rate_lbh += (available_to_release / delta) * 3600.0  # Convert back to per-hour
    stored_steam_lbs -= available_to_release

    show_notification("Released %d lb steam from storage" % int(available_to_release))
```

**UI Elements:**

**Storage Gauge (Left Panel):**
```
Storage: 450 / 1200
[■■■■■■□□□□]
```

**Storage Control Buttons (Tier 3+):**
- "Release 10%" - Releases 10% of max storage capacity per click (consistent amount regardless of current storage)
- "Auto-Release: ON/OFF" - Toggle automatic release during high demand
- Threshold slider (when auto-release enabled)

**Strategic Gameplay:**

**Active Diversion Strategy (New!):**
1. Player notices "Very Low Demand" state (0.2x multiplier) - trains coasting downhill
2. Current payment: 0.5 coins/sec (low revenue during low demand)
3. Player opens Storage Controls, sets diversion slider to 40%
4. Steam production: 25/sec → Main gets 15/sec, Storage gets 10/sec (before efficiency loss)
5. Storage builds: 200 → 400 → 600 steam over 3 minutes
6. Demand shifts to "High" (1.5x) - trains climbing steep grade
7. Payment jumps to higher value rate
8. Player sets diversion back to 0%, clicks "Release 10%" three times
9. Storage floods main reservoir with 360 steam (3 × 120)
10. Player exceeds high demand, earns maximum revenue for 2 minutes
11. Strategic profit: Stored cheap steam, sold it at premium rates!

**Overflow Capture (Passive Strategy):**
1. Zero demand state triggers (train stopped)
2. Workers continue producing steam
3. Main reservoir fills to 500/500
4. Overflow automatically diverts to storage (with 80% efficiency)
5. Storage fills to 800/1200
6. Player sees: "Excess steam stored for later use"
7. Critical demand spike occurs!
8. Player manually releases storage or auto-release triggers
9. Stored steam floods into main reservoir
10. Player maintains "Excellent" performance during spike
11. Earns bonus revenue for exceeding critical demand

### 5. Train Speed & Payment

**Purpose:** Convert steam production into Gold currency

**Payment Calculation (Direct Steam-to-Gold Conversion):**
```gdscript
# Payment Rate Constant
const PAYMENT_RATE_CONSTANT = 0.01  # Tune for desired earning speed
# Example: 10 lb/h × 1.0 multiplier × 0.01 = 0.1 gold/hour = 6 gold/hour

# Demand Multiplier Ranges (affects payment rate)
# Each state has a min/max range. Actual multiplier interpolates smoothly via sine wave.
# See DEMAND_RANGES constant in Demand Fluctuation Logic section for full definitions.
var demand_ranges = {
    "very_low": {"min": 0.0, "max": 0.45},   # Avg ~0.225x
    "low": {"min": 0.45, "max": 0.75},       # Avg ~0.6x
    "medium": {"min": 0.75, "max": 1.35},    # Avg ~1.05x
    "high": {"min": 1.35, "max": 2.65},      # Avg ~2.0x
    "critical": {"min": 2.65, "max": 3.75}   # Avg ~3.2x
}

# Current demand multiplier (interpolated value within current state's range)
var demand_multiplier: float = 1.05  # Starts at medium midpoint

# Gold accumulation (fractional)
var gold_progress: float = 0.0

# In _process(delta)
var steam_lbs_this_tick = steam_production_rate_lbh * (delta / 3600.0)
var gold_earned = steam_lbs_this_tick * demand_multiplier * PAYMENT_RATE_CONSTANT
gold_progress += gold_earned

# Award whole gold coins
if gold_progress >= 1.0:
    var whole_gold = floor(gold_progress)
    Level1Vars.current_gold += whole_gold
    gold_progress -= whole_gold

# Calculate earning rate for display (gold per minute)
var gold_per_minute = (steam_production_rate_lbh * demand_multiplier * PAYMENT_RATE_CONSTANT) / 60.0
var minutes_per_gold = 1.0 / gold_per_minute if gold_per_minute > 0 else 0
```

**Payment Display (Option 2):**
- Progress bar showing fractional gold accumulated (0.0 - 1.0)
- Visual progress: `[=====>--------------] 0.25 Gold`
- See detailed mockups in approved plan

**Payment Timing:**
- Continuous accrual while in owned_furnace scene
- Pays in **Gold** coins
- Display updates in real-time

---

## Implementation Steps

### Phase 1: Level1Vars Setup

Add core system variables to Level1Vars.gd:

```gdscript
# Furnace Heat System
var current_heat: float = 0.0
var max_heat: float = 700.0  # Starting: Cast Iron
var heat_decay_rate: float = 0.5  # per second

# Steam Production System
var steam_production_rate_lbh: float = 10.0  # pounds per hour
var steam_efficiency: float = 1.0

# Dynamic Demand System
var demand_state: String = "medium"
var demand_multiplier: float = 1.05
var demand_timer: float = 150.0
var last_demand_change_time: int = 0

# Steam Storage System (purchasable)
var has_storage_system: bool = false
var storage_capacity_tier: int = 0  # 0=none, 1-5=tiers
var storage_efficiency_tier: int = 0  # 0=base 50%, 1-5=efficiency tiers
var stored_steam_lbs: float = 0.0
var max_storage_lbs: float = 0.0
var storage_efficiency: float = 0.5
var storage_diversion_percentage: float = 0.0  # 0-100

# Payment System
var gold_progress: float = 0.0  # Fractional gold accumulation
```

### Phase 2: Heat System Implementation

Create heat generation and decay logic in owned_furnace.gd:

```gdscript
func _process(delta):
    # Heat decay
    var effective_decay = heat_decay_rate
    Level1Vars.current_heat = max(0, Level1Vars.current_heat - (effective_decay * delta))

    # Clamp to max
    Level1Vars.current_heat = min(Level1Vars.current_heat, Level1Vars.max_heat)

    # Update UI
    update_heat_gauge()

func _on_shovel_coal_pressed():
    if can_shovel():  # Check stamina
        var heat_gain = 1.0
        # Apply strength bonus (from Global stats)
        heat_gain *= (1.0 + Global.get_stat_level("strength") * 0.05)

        Level1Vars.current_heat = min(
            Level1Vars.current_heat + heat_gain,
            Level1Vars.max_heat
        )

        # Consume stamina, award XP
        consume_stamina()
        Global.add_stat_exp("strength", 1)
        Global.add_stat_exp("charisma", 0.5)  # Leadership XP
```

### Phase 3: Steam Production System

Implement steam generation based on heat:

```gdscript
func calculate_steam_production():
    # Base production from heat
    var base_lbh = (Level1Vars.current_heat / 10.0) * Level1Vars.steam_efficiency

    # Worker contributions (if workers implemented)
    # var worker_bonus = calculate_worker_steam_bonus()

    Level1Vars.steam_production_rate_lbh = base_lbh  # + worker_bonus

    update_steam_production_display()
```

### Phase 4: Demand System Implementation

Create dynamic demand state transitions:

```gdscript
const DEMAND_RANGES = {
    "very_low": {"min": 0.0, "max": 0.45},
    "low": {"min": 0.45, "max": 0.75},
    "medium": {"min": 0.75, "max": 1.35},
    "high": {"min": 1.35, "max": 2.65},
    "critical": {"min": 2.65, "max": 3.75}
}

var interpolation_time: float = 0.0
var interpolation_speed: float = 0.3

func _process(delta):
    # Smooth interpolation within current range
    interpolation_time += delta * interpolation_speed
    var normalized = (sin(interpolation_time) + 1.0) / 2.0

    var range_data = DEMAND_RANGES[Level1Vars.demand_state]
    Level1Vars.demand_multiplier = lerp(
        range_data["min"],
        range_data["max"],
        normalized
    )

    # Check for state change
    Level1Vars.demand_timer -= delta
    if Level1Vars.demand_timer <= 0:
        change_demand_state()

        # Triangular distribution: 1-5 minutes
        var rand1 = randf_range(60.0, 180.0)
        var rand2 = randf_range(60.0, 300.0)
        Level1Vars.demand_timer = (rand1 + rand2) / 2.0

func change_demand_state():
    var roll = randf()
    var new_state = "medium"

    if roll < 0.20: new_state = "very_low"
    elif roll < 0.35: new_state = "low"
    elif roll < 0.70: new_state = "medium"
    elif roll < 0.85: new_state = "high"
    else: new_state = "critical"

    Level1Vars.demand_state = new_state
    interpolation_time = 0.0

    # Show notification
    show_demand_notification(new_state)
```

### Phase 5: Payment System Implementation

Implement gold revenue calculation:

```gdscript
const PAYMENT_RATE_CONSTANT = 0.01  # Tune for balance

func _process(delta):
    # Calculate steam produced this tick (in pounds)
    var steam_lbs_this_tick = Level1Vars.steam_production_rate_lbh * (delta / 3600.0)

    # Direct conversion to gold (no storage initially)
    var gold_earned = steam_lbs_this_tick * Level1Vars.demand_multiplier * PAYMENT_RATE_CONSTANT
    Level1Vars.gold_progress += gold_earned

    # Award whole gold coins
    if Level1Vars.gold_progress >= 1.0:
        var whole_gold = floor(Level1Vars.gold_progress)
        Level1Vars.current_gold += whole_gold
        Level1Vars.gold_progress -= whole_gold

        # Notification
        Global.show_stat_notification("gold", whole_gold)

    # Update progress bar
    update_gold_progress_bar()
```

### Phase 6: Storage System (Optional Purchase)

Implement storage mechanics (activates after purchase):

```gdscript
func purchase_storage_tier_1():
    if Level1Vars.current_gold >= 5:
        Level1Vars.current_gold -= 5
        Level1Vars.has_storage_system = true
        Level1Vars.storage_capacity_tier = 1
        Level1Vars.max_storage_lbs = 300.0
        Level1Vars.storage_efficiency = 0.5

        # Show storage UI
        storage_gauge.visible = true
        storage_controls_button.visible = true

func _process(delta):
    if not Level1Vars.has_storage_system:
        # Direct payment (Phase 5 logic)
        process_direct_payment(delta)
    else:
        # Storage-enabled payment
        process_storage_payment(delta)

func process_storage_payment(delta):
    var steam_lbs = Level1Vars.steam_production_rate_lbh * (delta / 3600.0)

    # Apply diversion to storage
    var diverted = steam_lbs * (Level1Vars.storage_diversion_percentage / 100.0)
    var to_payment = steam_lbs - diverted

    # Store diverted steam (with efficiency loss)
    var storable = diverted * Level1Vars.storage_efficiency
    var space_left = Level1Vars.max_storage_lbs - Level1Vars.stored_steam_lbs
    var actually_stored = min(storable, space_left)
    Level1Vars.stored_steam_lbs += actually_stored

    # Process payment on non-diverted steam
    var gold_earned = to_payment * Level1Vars.demand_multiplier * PAYMENT_RATE_CONSTANT
    Level1Vars.gold_progress += gold_earned

    # Award coins
    if Level1Vars.gold_progress >= 1.0:
        var whole_gold = floor(Level1Vars.gold_progress)
        Level1Vars.current_gold += whole_gold
        Level1Vars.gold_progress -= whole_gold
```

---

## Testing Scenarios

### Test 1: Heat Generation and Decay

**Objective:** Verify heat increases with shoveling and decays over time

**Steps:**
1. Start owned_furnace scene
2. Observe current_heat = 0
3. Click "Shovel Coal" 10 times
4. Verify heat increases by ~1 per click (with strength bonus)
5. Stop shoveling
6. Observe heat decreasing at 0.5/second
7. Verify heat never goes below 0

**Expected Results:**
- Heat increases: 0 → ~10-12 (depending on strength)
- Heat decays: 10 → 9.5 → 9.0 → ... → 0
- UI gauge reflects changes in real-time

**Edge Cases:**
- Heat clamped at max_heat (700 initially)
- Heat cannot go negative

---

### Test 2: Steam Production Calculation

**Objective:** Verify steam production scales with heat level

**Test Cases:**

| Heat Level | Expected Steam (lb/h) | Formula |
|------------|----------------------|---------|
| 0 | 0 | 0 / 10 * 1.0 = 0 |
| 50 | 5 | 50 / 10 * 1.0 = 5 |
| 100 | 10 | 100 / 10 * 1.0 = 10 |
| 700 | 70 | 700 / 10 * 1.0 = 70 |

**Steps:**
1. Set heat to each test value (via debug or shoveling)
2. Observe steam_production_rate_lbh
3. Verify calculation matches formula

---

### Test 3: Demand State Transitions

**Objective:** Verify demand states change correctly and multipliers interpolate

**Steps:**
1. Start scene, observe initial state = "medium"
2. Wait for demand_timer to expire (~2.5 minutes average)
3. Observe state change notification
4. Verify new state is one of: very_low, low, medium, high, critical
5. Observe demand_multiplier smoothly interpolating within new range
6. Repeat 10 times, verify distribution roughly matches:
   - very_low: 20%
   - low: 15%
   - medium: 35%
   - high: 15%
   - critical: 15%

**Expected Results:**
- State changes every 1-5 minutes (avg 2.5)
- Multiplier smoothly oscillates within state range
- Notifications show appropriate environmental reasons

---

### Test 4: Payment Calculation

**Objective:** Verify gold revenue calculation across different demand states

**Test Cases:**

| Steam (lb/h) | Demand State | Multiplier | Gold/hour | Gold/minute |
|--------------|--------------|------------|-----------|-------------|
| 10 | very_low | 0.225 | 0.0225 | 0.000375 |
| 10 | medium | 1.05 | 0.105 | 0.00175 |
| 10 | critical | 3.2 | 0.32 | 0.00533 |
| 70 | medium | 1.05 | 0.735 | 0.01225 |

**Steps:**
1. Set steam production to test value
2. Force demand state to specific state (via debug)
3. Wait 1 minute
4. Verify gold_progress increased by expected amount
5. Verify whole gold coins awarded when progress >= 1.0

**Expected Results:**
- Gold progress bar fills continuously
- Whole coins awarded at threshold
- Progress bar resets to fractional remainder

---

### Test 5: Storage System Purchase and Operation

**Objective:** Verify storage system activates correctly after purchase

**Steps:**
1. Start with has_storage_system = false
2. Observe storage gauge hidden
3. Purchase Storage Tier 1 (5 gold)
4. Verify:
   - has_storage_system = true
   - max_storage_lbs = 300
   - storage_efficiency = 0.5
   - Storage gauge becomes visible
5. Set diversion to 50%
6. Produce 10 lb steam
7. Verify:
   - 5 lb goes to payment
   - 2.5 lb stored (50% * 50% efficiency)
   - stored_steam_lbs increases correctly

**Expected Results:**
- Storage only functions after purchase
- Diversion slider controls percentage correctly
- Efficiency loss applied during storage

---

### Test 6: Edge Cases and Boundary Conditions

**Test Cases:**

| Scenario | Expected Behavior |
|----------|-------------------|
| Heat = 0, no workers | Steam = 0, no payment |
| Heat = max_heat, keep shoveling | Heat stays at max_heat, no overflow |
| Demand = very_low (0.0x) | Gold progress = 0 (no payment) |
| Storage full (300/300) | Excess steam goes to payment instead |
| Diversion = 100%, demand critical | All steam stored, no payment (player error) |
| Gold progress = 0.99 | No coin awarded, bar shows 99% |
| Gold progress = 1.01 | 1 coin awarded, bar resets to 1% |

**Steps:**
1. Force each scenario (via debug or gameplay)
2. Verify expected behavior
3. Verify no crashes or undefined behavior

---

### Test 7: Integration with Save/Load

**Objective:** Verify all core systems persist correctly

**Steps:**
1. Set specific values:
   - current_heat = 350
   - demand_state = "high"
   - stored_steam_lbs = 150
   - gold_progress = 0.75
2. Save game
3. Exit and reload
4. Verify all values restored correctly
5. Verify systems continue functioning (heat decay, demand transitions, etc.)

**Expected Results:**
- All Level1Vars values persist
- Timers recalculated based on timestamps
- No desynchronization on reload

---
