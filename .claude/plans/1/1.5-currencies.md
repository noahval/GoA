# Currencies

**Goal**: Establish the foundational currency system with 4-tier currency (Copper, Silver, Gold, Platinum), basic operations, and lifetime tracking

**Success Criteria**:
- Currency data structures created in Level1Vars
- Basic add/subtract operations work correctly
- Lifetime currency tracking persists across sessions
- Save/load integration complete
- All currency operations logged for debugging

**Prerequisites**:
- Phase 1.1: Project Setup (Godot 4.5 project exists)
- Phase 1.2: Project Architecture (folder structure established)

---

## Overview

The currency system provides the foundational data structures and basic operations for GoA's 4-tier economy. This phase focuses on **data only** - exchange mechanics, market rates, and UI are in separate phases.

**IMPORTANT: Test-Driven Development Required**
This plan follows TDD methodology per BIBLE.md critical patterns:
- Write failing tests FIRST (RED)
- Implement code to make tests pass (GREEN)
- Refactor if needed
- Each function is developed with its test before moving to the next

### Key Design Principles

- **Simple Data Structures**: Dictionaries for current and lifetime amounts
- **No Business Logic**: Just data storage and basic operations
- **Extensible**: Built to support market rates (added in 1.x-currency-manager.md)
- **Persistent Tracking**: Lifetime earnings never decrease

---

## Architecture Overview

### Data Flow

```
Player earns copper → add_currency() → currency.copper increases
                                    → lifetime_currency.copper increases
                                    → save_game()
```

### Separation of Concerns

- **This phase (1.5)**: Data structures, basic add/subtract
- **1.x-currency-manager.md**: Exchange logic, fees, market rate hooks
- **1.x-atm-scene.md**: UI for viewing and exchanging
- **Phase 3.x (Market Volatility)**: Dynamic rate updates

---

## Implementation Tasks

### 1. Currency Data Structures

**File Location**: `res://level1/level_1_vars.gd`

**Variables needed**:
```gdscript
extends Node

# ===== CURRENCY SYSTEM =====

# Valid currency types (prevents typos)
const VALID_CURRENCIES = ["copper", "silver", "gold", "platinum"]

# Current currency holdings
var currency = {
	"copper": 0.0,
	"silver": 0.0,
	"gold": 0.0,
	"platinum": 0.0
}

# Lifetime currency earned (never decreases, tracks total ever earned)
var lifetime_currency = {
	"copper": 0.0,
	"silver": 0.0,
	"gold": 0.0,
	"platinum": 0.0
}

# Signals for reactive UI
signal currency_changed(currency_type: String, old_amount: float, new_amount: float)
```

**Rationale**:
- Dictionaries provide clean access via bracket notation: `currency["copper"]`
- Separate lifetime tracking for statistics
- Constants prevent typos in currency type strings
- Signals allow UI to react to currency changes automatically

---

### 2. Basic Currency Operations

**Add currency (with lifetime tracking)**:

```gdscript
# Add currency of any type
func add_currency(currency_type: String, amount: float) -> void:
	if not currency_type in VALID_CURRENCIES:
		push_error("Invalid currency type: %s. Valid: %s" % [currency_type, VALID_CURRENCIES])
		return

	if amount <= 0:
		push_warning("Attempted to add non-positive amount: %.2f" % amount)
		return

	# Update current holdings
	var old_amount = currency[currency_type]
	currency[currency_type] += amount

	# Update lifetime earnings
	lifetime_currency[currency_type] += amount

	# Emit signal for reactive UI
	emit_signal("currency_changed", currency_type, old_amount, currency[currency_type])

	# Log the transaction
	if DebugLogger:
		DebugLogger.log_resource_change("currency", currency_type, old_amount, currency[currency_type], "earned")

	# Notify player
	if Global:
		Global.show_notification("Received %.2f %s" % [amount, currency_type])
```

**Subtract currency (with validation)**:

```gdscript
# Deduct currency of any type
func deduct_currency(currency_type: String, amount: float) -> bool:
	if not currency_type in VALID_CURRENCIES:
		push_error("Invalid currency type: %s. Valid: %s" % [currency_type, VALID_CURRENCIES])
		return false

	if amount <= 0:
		push_warning("Attempted to deduct non-positive amount: %.2f" % amount)
		return false

	# Check if player has enough
	if currency[currency_type] < amount:
		if DebugLogger:
			DebugLogger.log_warning("Insufficient %s: has %.2f, needs %.2f" % [
				currency_type, currency[currency_type], amount
			])
		return false

	# Deduct the amount
	var old_amount = currency[currency_type]
	currency[currency_type] -= amount

	# Emit signal for reactive UI
	emit_signal("currency_changed", currency_type, old_amount, currency[currency_type])

	# Log the transaction
	if DebugLogger:
		DebugLogger.log_resource_change("currency", currency_type, old_amount, currency[currency_type], "spent")

	return true
```

**Get currency amount**:

```gdscript
# Get current amount of a currency type
func get_currency(currency_type: String) -> float:
	return currency.get(currency_type, 0.0)

# Check if player can afford an amount
func can_afford(currency_type: String, amount: float) -> bool:
	return get_currency(currency_type) >= amount
```

**Bulk operations (multi-currency transactions)**:

```gdscript
# Check if player can afford multiple currencies at once
func can_afford_all(costs: Dictionary) -> bool:
	for currency_type in costs:
		if not can_afford(currency_type, costs[currency_type]):
			return false
	return true

# Deduct multiple currencies (all-or-nothing)
func deduct_currencies(costs: Dictionary) -> bool:
	# Check all first
	if not can_afford_all(costs):
		return false

	# Deduct all
	for currency_type in costs:
		if not deduct_currency(currency_type, costs[currency_type]):
			push_error("Failed to deduct %s after can_afford check passed" % currency_type)
			return false

	return true
```

**Usage example**:
```gdscript
# Cost: 10 copper + 2 silver
var cost = {"copper": 10.0, "silver": 2.0}
if Level1Vars.can_afford_all(cost):
	Level1Vars.deduct_currencies(cost)
	# Purchase successful
```

---

### 3. Reset Functions

**Helper for empty currency dictionary**:

```gdscript
# Get empty currency dictionary (DRY principle)
func _get_empty_currency_dict() -> Dictionary:
	return {
		"copper": 0.0,
		"silver": 0.0,
		"gold": 0.0,
		"platinum": 0.0
	}
```

**Full reset (new game)**:

```gdscript
# Complete reset for new game
func reset_all_currency() -> void:
	currency = _get_empty_currency_dict()
	lifetime_currency = _get_empty_currency_dict()

	if DebugLogger:
		DebugLogger.log_milestone("Currency system reset")
```

---

## Testing Strategy (TDD Approach)

**IMPORTANT**: Follow RED-GREEN-REFACTOR cycle for each function:
1. **RED**: Write failing test first
2. **GREEN**: Implement minimal code to pass test
3. **REFACTOR**: Clean up if needed
4. Move to next function

### TDD Cycle 1: Data Structures

**Step 1 (RED)**: Write test for currency dictionaries

Create `tests/test_currencies.gd`:
```gdscript
extends GutTest

func before_each():
	# Reset to known state before each test
	Level1Vars.currency = Level1Vars._get_empty_currency_dict()
	Level1Vars.lifetime_currency = Level1Vars._get_empty_currency_dict()

func test_currency_dictionaries_exist():
	assert_not_null(Level1Vars.currency, "Currency dict exists")
	assert_not_null(Level1Vars.lifetime_currency, "Lifetime dict exists")
	assert_true("copper" in Level1Vars.currency, "Has copper key")
	assert_true("silver" in Level1Vars.currency, "Has silver key")
	assert_true("gold" in Level1Vars.currency, "Has gold key")
	assert_true("platinum" in Level1Vars.currency, "Has platinum key")

func test_valid_currencies_constant():
	assert_eq(Level1Vars.VALID_CURRENCIES.size(), 4, "Has 4 currency types")
	assert_true("copper" in Level1Vars.VALID_CURRENCIES, "Copper is valid")
```

**Step 2 (GREEN)**: Add currency dictionaries and constants to level_1_vars.gd (see section 1)

**Step 3 (REFACTOR)**: Verify test passes, clean up if needed

---

### TDD Cycle 2: Add Currency Function

**Step 1 (RED)**: Write failing test for add_currency

```gdscript
func test_add_currency_basic():
	Level1Vars.add_currency("copper", 100.0)

	assert_eq(Level1Vars.currency["copper"], 100.0, "Copper added correctly")
	assert_eq(Level1Vars.lifetime_currency["copper"], 100.0, "Lifetime tracking works")

func test_add_currency_accumulates():
	Level1Vars.add_currency("copper", 50.0)
	Level1Vars.add_currency("copper", 30.0)

	assert_eq(Level1Vars.currency["copper"], 80.0, "Copper accumulates")
	assert_eq(Level1Vars.lifetime_currency["copper"], 80.0, "Lifetime accumulates")

func test_add_currency_rejects_invalid_type():
	Level1Vars.add_currency("invalid", 10.0)

	# Should not crash, just log error
	assert_eq(Level1Vars.currency.get("invalid", -1), -1, "Invalid type not added")

func test_add_currency_rejects_negative():
	var before = Level1Vars.currency["copper"]
	Level1Vars.add_currency("copper", -10.0)

	assert_eq(Level1Vars.currency["copper"], before, "Negative amount rejected")
```

**Step 2 (GREEN)**: Implement add_currency function (see section 2)

**Step 3 (REFACTOR)**: Run tests, verify all pass

---

### TDD Cycle 3: Deduct Currency Function

**Step 1 (RED)**: Write failing test for deduct_currency

```gdscript
func test_deduct_currency_basic():
	Level1Vars.currency["silver"] = 50.0
	var success = Level1Vars.deduct_currency("silver", 30.0)

	assert_true(success, "Deduction succeeded")
	assert_eq(Level1Vars.currency["silver"], 20.0, "Silver deducted correctly")
	assert_eq(Level1Vars.lifetime_currency["silver"], 0.0, "Lifetime unchanged")

func test_deduct_currency_insufficient_funds():
	Level1Vars.currency["gold"] = 10.0
	var success = Level1Vars.deduct_currency("gold", 20.0)

	assert_false(success, "Deduction failed correctly")
	assert_eq(Level1Vars.currency["gold"], 10.0, "Gold unchanged")

func test_deduct_currency_exact_amount():
	Level1Vars.currency["platinum"] = 5.0
	var success = Level1Vars.deduct_currency("platinum", 5.0)

	assert_true(success, "Exact deduction succeeded")
	assert_eq(Level1Vars.currency["platinum"], 0.0, "Platinum now zero")
```

**Step 2 (GREEN)**: Implement deduct_currency function (see section 2)

**Step 3 (REFACTOR)**: Run tests, verify all pass

---

### TDD Cycle 4: Bulk Operations

**Step 1 (RED)**: Write test for multi-currency operations

```gdscript
func test_can_afford_all_success():
	Level1Vars.currency["copper"] = 100.0
	Level1Vars.currency["silver"] = 10.0

	var costs = {"copper": 50.0, "silver": 5.0}
	assert_true(Level1Vars.can_afford_all(costs), "Can afford both")

func test_can_afford_all_failure():
	Level1Vars.currency["copper"] = 100.0
	Level1Vars.currency["silver"] = 2.0

	var costs = {"copper": 50.0, "silver": 5.0}
	assert_false(Level1Vars.can_afford_all(costs), "Cannot afford silver")

func test_deduct_currencies_all_or_nothing():
	Level1Vars.currency["copper"] = 100.0
	Level1Vars.currency["silver"] = 2.0

	var costs = {"copper": 50.0, "silver": 5.0}
	var success = Level1Vars.deduct_currencies(costs)

	assert_false(success, "Transaction failed")
	assert_eq(Level1Vars.currency["copper"], 100.0, "Copper not deducted")
	assert_eq(Level1Vars.currency["silver"], 2.0, "Silver not deducted")
```

**Step 2 (GREEN)**: Implement bulk operations (see section 2)

**Step 3 (REFACTOR)**: Run tests, verify all pass

---

### Running Tests

```bash
# Run all currency tests
godot --headless --script res://addons/gut/gut_cmdln.gd -gtest=tests/test_currencies.gd

# Run specific test
godot --headless --script res://addons/gut/gut_cmdln.gd -gtest=tests/test_currencies.gd:test_add_currency_basic
```

### Manual Test Criteria

After all unit tests pass:

- [ ] Add currency via console: `Level1Vars.add_currency("copper", 100)`
- [ ] Verify currency_changed signal emits
- [ ] Verify lifetime amount increases
- [ ] Deduct currency: `Level1Vars.deduct_currency("copper", 50)`
- [ ] Verify deduction works and current amount decreases
- [ ] Verify lifetime amount unchanged
- [ ] Test insufficient funds returns false
- [ ] Test bulk operations with mixed costs
- [ ] Save game, exit, reload, verify values persist (automatic via get_save_data)

---

## Files to Create

None - all modifications to existing files

## Files to Modify

**level1/level_1_vars.gd** (~150 lines added)
- VALID_CURRENCIES constant
- Currency dictionaries (currency, lifetime_currency)
- currency_changed signal
- _get_empty_currency_dict() helper
- add_currency() function
- deduct_currency() function
- get_currency() function
- can_afford() function
- can_afford_all() function
- deduct_currencies() function
- reset_all_currency() function

**tests/test_currencies.gd** (~200 lines new)
- TDD test suite for all currency operations
- Tests for data structures
- Tests for add/deduct operations
- Tests for bulk operations
- Lifetime tracking tests
- Signal emission tests

---

## Design Values (Reference)

### Currency Tiers

- **Copper**: Starting currency (always accessible)
- **Silver**: Second tier
- **Gold**: Third tier
- **Platinum**: Premium tier

### Conversion Ratios (Reference)

Approximate 1000:1 ratios between tiers:
- 1000 copper ≈ 1 silver
- 1000 silver ≈ 1 gold
- 1000 gold ≈ 1 platinum

**Note**: Exact conversion handled by 1.x-currency-manager.md with market rates

---

## Integration Points

### Uses Global APIs (Optional)

```gdscript
Global.show_notification(message)  # Player feedback (if Global exists)
```

### Uses DebugLogger (Optional)

```gdscript
DebugLogger.log_resource_change("currency", type, old, new, reason)  # If DebugLogger exists
DebugLogger.log_milestone("Currency system reset")
DebugLogger.log_warning("Insufficient funds")
```

**Note**: Functions check for existence before calling, so system works without these dependencies.

### Provides APIs For

**1.x-currency-manager.md:**
- `get_currency(type)` - Read current amounts
- `add_currency(type, amount)` - Award currency
- `deduct_currency(type, amount)` - Spend currency
- `can_afford(type, amount)` - Check affordability
- `can_afford_all(costs)` - Check multi-currency affordability
- `deduct_currencies(costs)` - All-or-nothing multi-currency transaction

**1.x-atm-scene.md:**
- `currency` dictionary - Display current holdings
- `lifetime_currency` dictionary - Statistics
- `currency_changed` signal - React to currency updates

**Gameplay Systems:**
- All earning systems use `add_currency()`
- All purchase systems use `can_afford()` and `deduct_currency()`
- Multi-currency costs use `can_afford_all()` and `deduct_currencies()`
- UI components connect to `currency_changed` signal for reactive updates

---

## Dependencies & Integration

### Depends On:
- None (Global and DebugLogger are optional enhancements)

### Used By:
- 1.x-currency-manager.md - Exchange operations
- 1.x-atm-scene.md - Display and UI
- Phase 2.x (Copper Era) - Earning and spending
- Phase 3.x (Economy) - Market systems

---

## Notes & Decisions

**Decision 1**: Dictionary-based currency storage
- **Rationale**: Flexible, easy to extend with new currencies
- **Alternative**: Separate variables (more verbose)
- **Benefit**: Uniform access pattern, easy iteration

**Decision 2**: Lifetime tracking separate from current
- **Rationale**: Statistics tracking
- **Use case**: "You've earned 10,000 copper over all time"
- **Benefit**: Never resets, provides long-term progression tracking

**Decision 3**: VALID_CURRENCIES constant for validation
- **Rationale**: Prevent typos in string-based currency types
- **Benefit**: Clear error messages, type safety
- **Implementation**: Check against constant in all functions

**Decision 4**: currency_changed signal for reactive UI
- **Rationale**: UI can update automatically without polling
- **Benefit**: Decoupled architecture, efficient updates
- **Usage**: UI components connect to signal, refresh on change

**Decision 5**: Bulk operations for multi-currency costs
- **Rationale**: Many upgrades/purchases cost multiple currencies
- **Benefit**: All-or-nothing semantics, cleaner transaction code
- **Example**: Purse upgrade costs 10 copper + 2 silver

**Decision 6**: Test-Driven Development approach
- **Rationale**: BIBLE.md critical pattern requirement
- **Benefit**: Confidence in correctness, prevents regressions
- **Implementation**: RED-GREEN-REFACTOR cycle for each function

---

## Open Questions

- [ ] Should there be a maximum currency cap per type?
- [ ] Should lifetime earnings display somewhere in UI?
- [ ] Do we want currency conversion history tracking here or in 1.x-currency-manager.md?

---

## Implementation Checklist

Before marking this phase complete:

### TDD Cycle 1: Data Structures
- [ ] Write tests for currency dictionaries (RED)
- [ ] VALID_CURRENCIES constant added
- [ ] Currency dictionaries added to level_1_vars.gd
- [ ] currency_changed signal added
- [ ] _get_empty_currency_dict() helper implemented
- [ ] Tests pass (GREEN)

### TDD Cycle 2: Add Currency
- [ ] Write tests for add_currency() (RED)
- [ ] add_currency() function implemented
- [ ] Signal emission verified
- [ ] Tests pass (GREEN)

### TDD Cycle 3: Deduct Currency
- [ ] Write tests for deduct_currency() (RED)
- [ ] deduct_currency() function implemented
- [ ] Insufficient funds handling verified
- [ ] Tests pass (GREEN)

### TDD Cycle 4: Helper Functions
- [ ] Write tests for get_currency() and can_afford()
- [ ] get_currency() function implemented
- [ ] can_afford() function implemented
- [ ] Tests pass

### TDD Cycle 5: Bulk Operations
- [ ] Write tests for can_afford_all() and deduct_currencies() (RED)
- [ ] can_afford_all() function implemented
- [ ] deduct_currencies() function implemented
- [ ] All-or-nothing semantics verified
- [ ] Tests pass (GREEN)

### TDD Cycle 6: Reset Functions
- [ ] Write tests for reset_all_currency()
- [ ] reset_all_currency() implemented
- [ ] Tests pass

### Final Verification
- [ ] All unit tests passing
- [ ] Manual tests completed
- [ ] Signal emission verified in console
- [ ] Save/load persistence verified (automatic via get_save_data)
- [ ] Documentation updated

---

**Last Updated**: 2025-12-22
**Maintainer**: Claude + User collaboration
**Plan Version**: 1.2 (TDD approach, removed legacy compatibility, added signals and bulk operations)
