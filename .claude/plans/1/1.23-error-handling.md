# error Handling

## Overview

Comprehensive three-layer error handling system that keeps the game running through graceful degradation. Integrates with existing DebugLogger (1.22), cloud save system (1.19-1.20), and creates user-friendly error recovery mechanisms.

**Philosophy**: Never crash. Always recover. Keep player informed but not overwhelmed.

**Core Strategy**: Cloud-native approach (trust Nakama infrastructure), handle connection failures gracefully, validate loaded data, smart auto-recovery for minor issues.

---

## Architecture: Three-Layer Defense

### Layer 1: Prevention (Defensive Coding)
- Null checks before node access
- Validation before operations
- Type checking and boundary validation
- Safe defaults for missing data

### Layer 2: Recovery (Error Catching)
- Catch errors, log them, reset to safe state
- Smart auto-recovery for minor issues
- Notify user simply, continue running

### Layer 3: Isolation (Error Boundaries)
- Isolate Shop, UI, Save, Network systems
- One system failure doesn't cascade
- Safe fallbacks for each boundary

---

## Component 1: ErrorHandler Autoload

**File**: `res://error_handler.gd`

**Purpose**: Central error handling orchestrator. Provides error catching, recovery, and user notification.

**Key Features**:
- Error severity classification (MINOR, MODERATE, MAJOR, CRITICAL)
- Recovery action determination (CONTINUE, RESET_SYSTEM, LOAD_BACKUP, RESTART_SCENE, GOTO_SAFE_SCENE)
- Safe function execution with error catching
- User-friendly error translation
- Integration with DebugLogger
- Error panel management (in PlayArea)
- Connection status monitoring

**Core Functions**:
```gdscript
# Execute function safely with error catching
func safe_call(callable: Callable, context: String) -> Dictionary

# Handle error with automatic recovery
func handle_error(context: String, error_msg: String, severity: ErrorSeverity, recovery_data: Dictionary = {})

# Safe node access - never crashes
func safe_get_node(root: Node, path: String) -> Node

# Safe scene loading - returns null if fails
func safe_load_scene(scene_path: String) -> PackedScene

# Safe scene change with fallback
func safe_change_scene(tree: SceneTree, scene_path: String, fallback_path: String = "res://level1/loading_screen.tscn") -> bool

# Connection monitoring
func handle_save_failure(error_message: String)
func handle_save_success()
```

**Recovery Actions**:
- **MINOR errors**: Log and continue silently
- **MODERATE errors**: Log, notify user, continue
- **MAJOR errors**: Log, notify user, attempt recovery (reset system)
- **CRITICAL errors**: Log, notify user, load backup save or go to safe scene

**System Reset Functions**:
- Validate currency data (ensure non-negative)
- Validate stat data (ensure >= 1.0)
- Reset shop UI state
- Clear error state after MAX_RECOVERY_ATTEMPTS

---

## Component 2: Cloud Save Error Handling

**File**: `res://cloud_save_validator.gd` (class_name script)

**Purpose**: Handle cloud save connection failures and validate loaded data. No local backups - trust Nakama infrastructure.

**Error Cases**:
1. **Connection Lost**: Can't reach Nakama server
2. **Save Failed**: Server rejects or times out
3. **Load Failed**: Can't fetch data from server
4. **Data Invalid**: Data exists but malformed/corrupted

**Core Functions**:
```gdscript
class_name CloudSaveValidator
extends RefCounted

# Validate loaded save data - clamp to valid ranges
static func validate_loaded_data(data: Dictionary) -> Dictionary:
    var validated = data.duplicate(true)

    # Validate Global stats (>= 1.0)
    if validated.has("global"):
        var g = validated.global
        g.strength = max(g.get("strength", 1.0), 1.0)
        g.constitution = max(g.get("constitution", 1.0), 1.0)
        g.dexterity = max(g.get("dexterity", 1.0), 1.0)
        g.wisdom = max(g.get("wisdom", 1.0), 1.0)
        g.intelligence = max(g.get("intelligence", 1.0), 1.0)
        g.charisma = max(g.get("charisma", 1.0), 1.0)

        # Validate experience (>= 0)
        g.strength_exp = max(g.get("strength_exp", 0.0), 0.0)
        g.constitution_exp = max(g.get("constitution_exp", 0.0), 0.0)
        g.dexterity_exp = max(g.get("dexterity_exp", 0.0), 0.0)
        g.wisdom_exp = max(g.get("wisdom_exp", 0.0), 0.0)
        g.intelligence_exp = max(g.get("intelligence_exp", 0.0), 0.0)
        g.charisma_exp = max(g.get("charisma_exp", 0.0), 0.0)

        # Validate reputation (>= 0)
        g.reputation_points = max(g.get("reputation_points", 0), 0)
        g.lifetime_reputation_earned = max(g.get("lifetime_reputation_earned", 0), 0)

    # Validate Level1Vars currency (>= 0)
    if validated.has("level1_vars") and validated.level1_vars.has("currency"):
        var c = validated.level1_vars.currency
        c.copper = max(c.get("copper", 0.0), 0.0)
        c.silver = max(c.get("silver", 0.0), 0.0)
        c.gold = max(c.get("gold", 0.0), 0.0)
        c.platinum = max(c.get("platinum", 0.0), 0.0)

    # Validate Level1Vars resources (>= 0)
    if validated.has("level1_vars"):
        var lv = validated.level1_vars
        lv.coal = max(lv.get("coal", 0.0), 0.0)
        lv.shovel_lvl = max(lv.get("shovel_lvl", 0), 0)
        lv.plow_lvl = max(lv.get("plow_lvl", 0), 0)
        lv.auto_shovel_lvl = max(lv.get("auto_shovel_lvl", 0), 0)

    return validated

# Check if save data structure is valid
static func is_valid_save_structure(data: Dictionary) -> bool:
    if not data.has("global"):
        return false
    if not data.has("level1_vars"):
        return false
    return true
```

**Connection Monitoring** (in ErrorHandler):
```gdscript
# Track connection state
var is_connected_to_server: bool = true
var last_connection_check: float = 0.0
var connection_check_interval: float = 30.0  # Check every 30 seconds

# Notify when save fails due to connection
func handle_save_failure(error_message: String):
    is_connected_to_server = false

    # Show notification
    Global.show_stat_notification("Connection lost - progress not saved", "warning")

    # Log error
    DebugLogger.error("Save failed: " + error_message, "CLOUD_SAVE")

    # Update connection indicator
    _update_connection_indicator()

# Notify when connection restored
func handle_save_success():
    if not is_connected_to_server:
        is_connected_to_server = true
        Global.show_stat_notification("Connection restored", "success")

    _update_connection_indicator()
```

**Load Recovery**:
- If load fails -> Start fresh game, notify player clearly
- If data invalid -> Validate and clamp to safe values, log what was fixed

---

## Component 3: Connection Indicator in Settings Panel

**Purpose**: Visual indicator showing server connection status.

**Location**: Settings panel header (plan 1.16)

**UI Addition** to `res://settings_panel.tscn`:
```
SettingsPanel
└── MarginContainer
    └── VBoxContainer
        ├── HeaderHBox
        │   ├── TitleLabel ("Settings")
        │   ├── ConnectionIndicator (ColorRect) <- NEW
        │   │   └── ConnectionLabel ("Server: Connected") <- NEW
        │   └── CloseButton ("X")
        ├── UIScaleContainer
        ...
```

**ColorRect Properties**:
- Size: 16x16 pixels
- Color: Blue (0.2, 0.6, 1.0) when connected, Orange (1.0, 0.5, 0.0) when disconnected
- Shape: Circular or square indicator

**Script Update** (`res://settings_panel.gd`):
```gdscript
@onready var connection_indicator = $MarginContainer/VBoxContainer/HeaderHBox/ConnectionIndicator
@onready var connection_label = $MarginContainer/VBoxContainer/HeaderHBox/ConnectionIndicator/ConnectionLabel

func _ready():
    # Existing ready code...

    # Update connection status
    update_connection_status()

    # Refresh connection status every 5 seconds
    var timer = Timer.new()
    timer.wait_time = 5.0
    timer.autostart = true
    timer.timeout.connect(update_connection_status)
    add_child(timer)

func update_connection_status():
    if ErrorHandler.is_connected_to_server:
        connection_indicator.color = Color(0.2, 0.6, 1.0)  # Blue
        connection_label.text = "Server: Connected"
    else:
        connection_indicator.color = Color(1.0, 0.5, 0.0)  # Orange
        connection_label.text = "Server: Disconnected"
```

---

## Component 4: Error Boundary Wrappers

**File**: `res://error_boundaries.gd` (class_name script)

**Purpose**: Wrap critical operations with error boundaries to prevent cascading failures.

**Static Functions**:
```gdscript
class_name ErrorBoundaries
extends RefCounted

# Shop purchase with error boundary and refund on failure
static func safe_shop_purchase(item_name: String, cost, purchase_callback: Callable) -> bool:
    # Validate inputs
    if not CurrencyManager.can_afford(cost):
        Global.show_stat_notification("Cannot afford " + item_name)
        return false

    # Execute purchase in boundary
    var result = ErrorHandler.safe_call(func():
        if CurrencyManager.deduct_currency(cost):
            purchase_callback.call()
            return true
        return false
    , "Shop.purchase_" + item_name)

    if not result.success:
        # Purchase failed - refund currency
        ErrorHandler.handle_error("ShopPurchase", "Purchase failed: " + item_name, ErrorHandler.ErrorSeverity.MODERATE, {
            "item": item_name,
            "cost": cost
        })

        # Try to refund
        if typeof(cost) == TYPE_FLOAT or typeof(cost) == TYPE_INT:
            Level1Vars.currency.copper += cost
        elif typeof(cost) == TYPE_DICTIONARY:
            for currency_name in cost.keys():
                Level1Vars.currency[currency_name] += cost[currency_name]

        Global.show_stat_notification("Purchase failed - refunded")
        return false

    return true

# Stat operation with boundary
static func safe_stat_operation(stat_name: String, operation: Callable) -> bool:
    var result = ErrorHandler.safe_call(operation, "Stat." + stat_name)

    if not result.success:
        ErrorHandler.handle_error("StatOperation", "Stat operation failed: " + stat_name, ErrorHandler.ErrorSeverity.MINOR)
        return false

    return true

# UI update with boundary (won't crash if node missing)
static func safe_ui_update(ui_element_name: String, update_callback: Callable) -> void:
    var result = ErrorHandler.safe_call(update_callback, "UI." + ui_element_name)

    if not result.success:
        ErrorHandler.handle_error("UIUpdate", "UI update failed: " + ui_element_name, ErrorHandler.ErrorSeverity.MINOR)

# Resource operation with boundary and validation
static func safe_resource_operation(resource_name: String, operation: Callable, validate_callback: Callable = Callable()) -> bool:
    var result = ErrorHandler.safe_call(operation, "Resource." + resource_name)

    if not result.success:
        ErrorHandler.handle_error("ResourceOperation", "Resource operation failed: " + resource_name, ErrorHandler.ErrorSeverity.MODERATE, {
            "resource": resource_name
        })
        return false

    # Optional validation
    if validate_callback.is_valid():
        var valid = validate_callback.call()
        if not valid:
            ErrorHandler.handle_error("ResourceValidation", "Resource validation failed: " + resource_name, ErrorHandler.ErrorSeverity.MODERATE)
            return false

    return true
```

**Usage Example** (shop.gd):
```gdscript
func _on_shovel_button_pressed():
    var cost = get_shovel_cost()
    ErrorBoundaries.safe_shop_purchase("Shovel", cost, func():
        Level1Vars.shovel_lvl += 1
        UpgradeTypesConfig.track_equipment_purchase("shovel", cost)
        DebugLogger.log_shop_purchase("Shovel", cost, Level1Vars.shovel_lvl)
        update_labels()
    )
```

---

## Component 5: Safe Node Access Helpers

**File**: `res://safe_node_access.gd` (class_name script)

**Purpose**: Helper functions for safe node operations throughout the codebase.

**Static Functions**:
```gdscript
class_name SafeNodeAccess
extends RefCounted

# Get node with warning if not found
static func get_or_warn(root: Node, path: String, context: String = "") -> Node:
    if not root:
        DebugLogger.warn("Root node is null for path: " + path, "SafeNodeAccess")
        return null

    if not root.has_node(path):
        var ctx = context if context != "" else "UnknownContext"
        DebugLogger.warn("Node not found: " + path + " in " + ctx, "SafeNodeAccess")
        return null

    return root.get_node_or_null(path)

# Get node or use fallback
static func get_or_fallback(root: Node, path: String, fallback: Node = null) -> Node:
    if not root or not root.has_node(path):
        return fallback

    return root.get_node_or_null(path)

# Safely call method on node if it exists
static func safe_call_method(node: Node, method_name: String, args: Array = []) -> Variant:
    if not node:
        return null

    if not node.has_method(method_name):
        DebugLogger.warn("Method %s not found on node %s" % [method_name, node.name], "SafeNodeAccess")
        return null

    return node.callv(method_name, args)

# Safe label update (won't crash if null)
static func safe_update_label(label: Label, text: String) -> void:
    if label:
        label.text = text
    else:
        DebugLogger.warn("Tried to update null label", "SafeNodeAccess")

# Safe progress bar update (clamped to valid range)
static func safe_update_progress_bar(bar: ProgressBar, value: float) -> void:
    if bar:
        bar.value = clamp(value, bar.min_value, bar.max_value)
    else:
        DebugLogger.warn("Tried to update null progress bar", "SafeNodeAccess")
```

**Usage Example**:
```gdscript
# Old (unsafe):
@onready var coins_panel = $HBoxContainer/LeftVBox/CoinsPanel

# New (safe):
@onready var coins_panel = SafeNodeAccess.get_or_warn(self, "HBoxContainer/LeftVBox/CoinsPanel", "Shop._ready")
```

---

## Component 6: Error Panel (in PlayArea)

**File**: `res://error_panel.tscn` and `res://error_panel.gd`

**Purpose**: Simple, non-technical error panel displayed in PlayArea with "Show Details" and "Report Bug" buttons.

**Display Pattern** (similar to settings panel from 1.16):
- Error panel fills entire PlayArea
- Hides current PlayArea content while visible
- Semi-transparent background (30% opacity)
- Content area fully opaque
- Close button (X) in corner
- Escape key closes panel

**UI Structure**:
```
ErrorPanel (Panel, fills PlayArea)
└── MarginContainer
    └── VBoxContainer
        ├── HeaderHBox
        │   ├── TitleLabel ("Oops!")
        │   └── CloseButton ("X")
        ├── UserMessageLabel (friendly message)
        ├── RecoveryActionLabel (what the system did)
        ├── HSeparator
        ├── ButtonContainer (HBoxContainer)
        │   ├── ContinueButton
        │   ├── ShowDetailsButton
        │   └── ReportBugButton
        └── DetailPanel (hidden by default, VBoxContainer)
            ├── DetailLabel ("Technical Details:")
            ├── ScrollContainer
            │   └── VBoxContainer
            │       ├── ContextLabel (where error occurred)
            │       ├── TechnicalLabel (technical message)
            │       └── SeverityLabel (severity level)
            └── CopyButton ("Copy to Clipboard")
```

**Script** (`error_panel.gd`):

```gdscript
extends Panel

signal panel_closed

@onready var user_message_label = $MarginContainer/VBoxContainer/UserMessageLabel
@onready var recovery_label = $MarginContainer/VBoxContainer/RecoveryActionLabel
@onready var close_button = $MarginContainer/VBoxContainer/HeaderHBox/CloseButton
@onready var continue_button = $MarginContainer/VBoxContainer/ButtonContainer/ContinueButton
@onready var show_details_button = $MarginContainer/VBoxContainer/ButtonContainer/ShowDetailsButton
@onready var report_bug_button = $MarginContainer/VBoxContainer/ButtonContainer/ReportBugButton
@onready var detail_panel = $MarginContainer/VBoxContainer/DetailPanel
@onready var context_label = $MarginContainer/VBoxContainer/DetailPanel/ScrollContainer/VBoxContainer/ContextLabel
@onready var technical_label = $MarginContainer/VBoxContainer/DetailPanel/ScrollContainer/VBoxContainer/TechnicalLabel
@onready var severity_label = $MarginContainer/VBoxContainer/DetailPanel/ScrollContainer/VBoxContainer/SeverityLabel
@onready var copy_button = $MarginContainer/VBoxContainer/DetailPanel/CopyButton

var current_context: String = ""
var current_technical: String = ""
var current_severity: int = 0

func _ready():
    detail_panel.visible = false
    close_button.pressed.connect(_on_close_pressed)
    continue_button.pressed.connect(_on_continue_pressed)
    show_details_button.pressed.connect(_on_show_details_pressed)
    report_bug_button.pressed.connect(_on_report_bug_pressed)
    copy_button.pressed.connect(_on_copy_error_pressed)

func _input(event):
    if event.is_action_pressed("ui_cancel"):  # Escape key
        _close_panel()
        get_viewport().set_input_as_handled()

func show_error(user_message: String, recovery_text: String, context: String, technical_msg: String, severity: int) -> void:
    user_message_label.text = user_message
    recovery_label.text = recovery_text

    current_context = context
    current_technical = technical_msg
    current_severity = severity

    context_label.text = "Where: " + context
    technical_label.text = "Details: " + technical_msg
    severity_label.text = "Severity: " + ErrorHandler.ErrorSeverity.keys()[severity]

    detail_panel.visible = false
    show()

func _on_close_pressed():
    _close_panel()

func _on_continue_pressed():
    _close_panel()

func _close_panel():
    panel_closed.emit()
    queue_free()

func _on_show_details_pressed():
    detail_panel.visible = not detail_panel.visible

func _on_report_bug_pressed():
    # Close error panel and open bug report panel
    _close_panel()
    _open_debug_panel()

func _open_debug_panel():
    var debug_panel_scene = load("res://debug_panel.tscn")
    if not debug_panel_scene:
        DebugLogger.error("Failed to load debug panel scene", "ErrorPanel")
        return

    var debug_panel = debug_panel_scene.instantiate()

    var play_area = ErrorHandler.safe_get_node(get_tree().current_scene, "MainLayout/PlayArea")
    if not play_area:
        DebugLogger.error("Could not find PlayArea for debug panel", "ErrorPanel")
        return

    # Hide current content
    for child in play_area.get_children():
        child.visible = false

    # Add debug panel
    play_area.add_child(debug_panel)

    # Pre-populate with error info
    if debug_panel.has_method("show_for_error_report"):
        debug_panel.show_for_error_report(current_context, current_technical)

    # Restore visibility when closed
    debug_panel.panel_closed.connect(func():
        for child in play_area.get_children():
            if child != debug_panel:
                child.visible = true
    )

func _on_copy_error_pressed():
    var error_text = "Context: %s\nMessage: %s\nSeverity: %s" % [
        current_context,
        current_technical,
        ErrorHandler.ErrorSeverity.keys()[current_severity]
    ]
    DisplayServer.clipboard_set(error_text)
    Global.show_stat_notification("Error details copied to clipboard")
```

**Message Translation** (in ErrorHandler):
- Save/load errors -> "We had trouble with your save file. Don't worry - we'll try to recover it!"
- Scene errors -> "We couldn't load that area. Taking you somewhere safe..."
- Currency errors -> "Something went wrong with that transaction. Your items are safe!"
- Stat errors -> "We noticed an issue with your character. Everything's been fixed!"
- Generic -> "Something unexpected happened, but we're handling it!"

---

## Integration Steps

### Step 1: Add New Autoload

**Modify**: `res://project.godot`

Add to autoload section:
```ini
[autoload]
ErrorHandler="*res://error_handler.gd"
```

### Step 2: Add Connection Indicator to Settings Panel

**Modify**: `res://settings_panel.tscn` and `res://settings_panel.gd`

Add connection status indicator at top of panel:
```
SettingsPanel
└── MarginContainer
    └── VBoxContainer
        ├── HeaderHBox
        │   ├── TitleLabel ("Settings")
        │   ├── ConnectionIndicator (ColorRect) <- NEW
        │   │   └── ConnectionLabel ("Server: Connected") <- NEW
        │   └── CloseButton ("X")
        ├── UIScaleContainer
        ...
```

**Settings panel script**:
```gdscript
@onready var connection_indicator = $MarginContainer/VBoxContainer/HeaderHBox/ConnectionIndicator
@onready var connection_label = $MarginContainer/VBoxContainer/HeaderHBox/ConnectionIndicator/ConnectionLabel

func _ready():
    # Update connection status
    update_connection_status()

    # Refresh connection status every few seconds
    var timer = Timer.new()
    timer.wait_time = 5.0
    timer.autostart = true
    timer.timeout.connect(update_connection_status)
    add_child(timer)

func update_connection_status():
    if ErrorHandler.is_connected_to_server:
        connection_indicator.color = Color(0.2, 0.6, 1.0)  # Blue
        connection_label.text = "Server: Connected"
    else:
        connection_indicator.color = Color(1.0, 0.5, 0.0)  # Orange
        connection_label.text = "Server: Disconnected"
```

### Step 3: Update Global

**Modify**: `res://global.gd`

Add singleton instance tracker:
```gdscript
# Singleton panel instances
var settings_panel_instance = null
var error_panel_instance = null  # NEW
```

Update `change_scene_with_check` function:
```gdscript
func change_scene_with_check(scene_tree: SceneTree, scene_path: String):
    # Save to cloud before scene change (from plan 1.20)
    if NakamaClient.is_authenticated:
        var save_result = await NakamaClient.save_game()
        if not save_result:
            # Save failed - notify player
            ErrorHandler.handle_save_failure("Save before scene change failed")

    # Check for victory
    if check_victory_conditions():
        ErrorHandler.safe_change_scene(scene_tree, "res://victory.tscn", "res://level1/loading_screen.tscn")
        return

    # Check if caught
    if not check_get_caught():
        ErrorHandler.safe_change_scene(scene_tree, scene_path, "res://level1/loading_screen.tscn")
```

### Step 4: Update Scene Template for Error Panel

**Modify**: `res://level1/scene_template.gd`

Add error panel handler:
```gdscript
func show_error_in_play_area(user_message: String, recovery_text: String, context: String, technical_msg: String, severity: int):
    if Global.error_panel_instance:
        return  # Already showing error

    var error_scene = load("res://error_panel.tscn")
    Global.error_panel_instance = error_scene.instantiate()
    Global.error_panel_instance.panel_closed.connect(_on_error_panel_closed)

    # Hide current play area content
    for child in play_area.get_children():
        child.visible = false

    # Add error panel to PlayArea
    play_area.add_child(Global.error_panel_instance)
    Global.error_panel_instance.show_error(user_message, recovery_text, context, technical_msg, severity)

func _on_error_panel_closed():
    for child in play_area.get_children():
        if child != Global.error_panel_instance:
            child.visible = true

    Global.error_panel_instance = null
```

### Step 5: Update ErrorHandler to Use PlayArea

**Modify**: `res://error_handler.gd`

Update `_show_user_error` function:
```gdscript
func _show_user_error(context: String, error_msg: String, severity: ErrorSeverity, action: int, recovery_data: Dictionary) -> void:
    # Translate technical error to user-friendly message
    var user_message = _translate_error_for_user(context, error_msg, severity)
    var recovery_action_text = _get_recovery_action_text(action)

    # Show in scene template's PlayArea
    var current_scene = get_tree().current_scene
    if current_scene and current_scene.has_method("show_error_in_play_area"):
        current_scene.show_error_in_play_area(user_message, recovery_action_text, context, error_msg, severity)
    else:
        # Fallback: Log to console if scene doesn't support error panel
        DebugLogger.error("No error panel support in current scene", "ERROR_HANDLER")
```

### Step 6: Update NakamaClient Save/Load Error Handling

**Modify**: `res://nakama_client.gd`

Add error callbacks to save operations:
```gdscript
func save_game() -> bool:
    if not is_authenticated:
        DebugLogger.warn("Cannot save: Not authenticated", "NAKAMA")
        ErrorHandler.handle_save_failure("Not authenticated")
        return false

    # Existing save logic...
    var result = await write_storage("game_state", user_id, save_data)

    if not result:
        # Save failed
        ErrorHandler.handle_save_failure("Nakama write failed")
        return false

    # Save succeeded
    ErrorHandler.handle_save_success()
    return true

func load_game() -> bool:
    if not is_authenticated:
        DebugLogger.warn("Cannot load: Not authenticated", "NAKAMA")
        return false

    # Existing load logic...
    var result = await read_storage("game_state", user_id)

    if not result or not result.has("value"):
        # Load failed - start fresh
        DebugLogger.warn("No save data found - starting fresh", "NAKAMA")
        Global.show_stat_notification("Starting new game")
        return false

    var data = result.value

    # Validate structure
    if not CloudSaveValidator.is_valid_save_structure(data):
        ErrorHandler.handle_error("LoadGame", "Invalid save structure", ErrorHandler.ErrorSeverity.MAJOR)
        Global.show_stat_notification("Save data corrupted - starting fresh")
        return false

    # Validate and clamp values
    data = CloudSaveValidator.validate_loaded_data(data)

    # Apply to game state (existing logic)
    _apply_loaded_data(data)

    return true
```

### Step 7: Update Shop Purchases (Error Boundaries)

**Modify**: `res://level1/shop.gd`

Wrap all purchase buttons with error boundaries:
```gdscript
func _on_shovel_button_pressed():
    var cost = get_shovel_cost()
    ErrorBoundaries.safe_shop_purchase("Shovel", cost, func():
        Level1Vars.shovel_lvl += 1
        UpgradeTypesConfig.track_equipment_purchase("shovel", cost)
        DebugLogger.log_shop_purchase("Shovel", cost, Level1Vars.shovel_lvl)
        update_labels()
        update_shovels_popup_labels()
    )

# Repeat for all purchase buttons (plow, auto_shovel, etc.)
```

### Step 8: Update Node Access Patterns

**Modify**: Shop, loading_screen, and other UI-heavy scenes

Replace unsafe node access with SafeNodeAccess:
```gdscript
func _ready():
    # Safe node access
    suspicion_panel = SafeNodeAccess.get_or_warn(self, "HBoxContainer/LeftVBox/SuspicionPanel", "Shop._ready")
    suspicion_bar = SafeNodeAccess.get_or_warn(self, "HBoxContainer/LeftVBox/SuspicionPanel/SuspicionBar", "Shop._ready")
    break_timer_bar = SafeNodeAccess.get_or_warn(self, "HBoxContainer/LeftVBox/BreakTimerPanel/BreakTimerBar", "Shop._ready")
    # ...
```

### Step 9: Update Currency Manager Validation

**Modify**: `res://currency_manager.gd`

Add input validation:
```gdscript
func add_currency(currency_type: int, amount: float, reason: String = "earned") -> float:
    # Validate inputs
    if amount < 0:
        ErrorHandler.handle_error("CurrencyManager.add_currency", "Negative amount: " + str(amount), ErrorHandler.ErrorSeverity.MODERATE)
        return 0.0

    if currency_type < 0 or currency_type > CurrencyType.PLATINUM:
        ErrorHandler.handle_error("CurrencyManager.add_currency", "Invalid currency type: " + str(currency_type), ErrorHandler.ErrorSeverity.MODERATE)
        return 0.0

    # Existing logic...
```

### Step 10: Update Debug Panel for Pre-Population

**Modify**: `res://debug_panel.gd` (from plan 1.22)

Add function to show panel with pre-populated error info:
```gdscript
func show_for_error_report(error_context: String, error_technical: String):
    # Pre-populate description
    description_box.text = "Error occurred: %s\n\nDetails: %s\n\nWhat I was doing:\n" % [error_context, error_technical]

    # Switch to advanced mode
    if not is_advanced_mode:
        _on_mode_toggle()

    # Auto-select recent error/warning logs
    var recent_logs = DebugLogger.get_recent_logs(50)
    var now = Time.get_unix_time_from_system()

    for i in range(error_list.get_child_count()):
        var checkbox = error_list.get_child(i)
        if i < recent_logs.size():
            var log = recent_logs[i]
            var log_time = Time.get_unix_time_from_datetime_string(log.timestamp)

            # Auto-select logs from last 60 seconds that are errors/warnings
            if (now - log_time) < 60 and (log.level == "ERROR" or log.level == "WARN"):
                checkbox.button_pressed = true
                selected_logs.append(log)
```

---

## Error Classification Reference

### Must Recover From (Game-Breaking)
- Save file won't load -> Use backup or start fresh
- Scene won't load -> Return to main menu
- Cloud auth fails -> Fall back to local save
- Null node crashes -> Reset that scene component

### Can Continue Through (Annoying but Not Fatal)
- Stat calculation gives weird result -> Clamp to valid range, log it
- Missing UI texture -> Use placeholder/default
- Currency display glitches -> Refresh the UI
- Notification system errors -> Skip that notification

### Should Ask User (Player Decides)
- "Save conflict: Local save is newer than cloud. Which do you want to keep?"
- "Purchase failed: Not enough currency. Earn more to continue."
- "Scene load failed: Return to menu or retry?"

---

## Testing Strategy

### Manual Test Cases

1. **Connection Failure Test**:
   - Disconnect internet
   - Trigger save (purchase, scene change, etc.)
   - Expected: Notification "Connection lost - progress not saved"
   - Settings panel shows orange connection indicator
   - Reconnect internet
   - Trigger save again
   - Expected: Notification "Connection restored", blue indicator

2. **Error Panel UI Test**:
   - Trigger error (invalid scene, etc.)
   - Expected: Error panel appears in PlayArea, hides game content
   - Click "Show Details" -> Technical info expands
   - Click "Report Bug" -> Debug panel opens with pre-populated info

3. **Bug Report Flow Test**:
   - Error occurs -> Error panel shows
   - Click "Report Bug"
   - Expected: Debug panel opens in PlayArea
   - Description pre-populated with error info
   - Relevant logs auto-selected
   - Can add custom description
   - Submit to Nakama

4. **Missing Scene Test**:
   - Try to change to non-existent scene path
   - Expected: Falls back to loading_screen.tscn, shows error panel

5. **Invalid Cloud Save Test**:
   - Manually corrupt save in Nakama database (set negative currency)
   - Load game
   - Expected: Validation resets values to safe minimums, logs errors

6. **No Cloud Save Test**:
   - Delete save from Nakama database
   - Load game
   - Expected: Starts fresh, notification "Starting new game"

7. **Null Node Reference Test**:
   - Remove a UI node from scene
   - Try to update it
   - Expected: Logs warning, continues without crash

8. **Purchase Failure Test**:
   - Simulate currency deduction failure mid-purchase
   - Expected: Refunds currency, shows error panel

### Testing Functions (Add to ErrorHandler)

```gdscript
# === TESTING FUNCTIONS (REMOVE IN PRODUCTION) ===

func test_connection_failure():
    # Simulate connection failure
    handle_save_failure("Simulated connection timeout")

func test_missing_scene():
    safe_change_scene(get_tree(), "res://nonexistent_scene.tscn")

func test_negative_currency():
    Level1Vars.currency.copper = -100.0
    _validate_currency_data()

func test_invalid_stat():
    Global.strength = 0.0
    _validate_stat_data()
```

### Testing Checklist

- [ ] Connection indicator shows blue when connected
- [ ] Connection indicator shows orange when disconnected
- [ ] Save failure shows notification: "Connection lost - progress not saved"
- [ ] Save success after disconnection shows: "Connection restored"
- [ ] Error panel fills PlayArea
- [ ] Error panel hides game content while visible
- [ ] X button closes error panel
- [ ] Escape key closes error panel
- [ ] "Show Details" reveals technical info
- [ ] "Report Bug" opens debug panel
- [ ] Debug panel pre-populates with error info
- [ ] Auto-selects relevant logs
- [ ] Can submit bug report to Nakama
- [ ] No cloud save found -> Starts fresh with notification
- [ ] Invalid cloud data -> Validates and clamps values
- [ ] Negative currency in save -> Resets to 0
- [ ] Negative stat in save -> Resets to 1
- [ ] Purchase with exact currency -> Works
- [ ] Purchase without currency -> Error panel, refund
- [ ] Invalid scene change -> Falls back
- [ ] Remove UI node -> Logs warning, continues
- [ ] Multiple errors -> Recovery mode
- [ ] "Copy Error" copies to clipboard

---

## Files to Create

1. **res://error_handler.gd** - Main error handling autoload (400+ lines)
2. **res://cloud_save_validator.gd** - Validate loaded cloud save data, class_name script (100+ lines)
3. **res://error_boundaries.gd** - Error boundary wrappers, class_name script (100+ lines)
4. **res://safe_node_access.gd** - Safe node access helpers, class_name script (80+ lines)
5. **res://error_panel.tscn** - Error panel UI scene (in PlayArea)
6. **res://error_panel.gd** - Error panel script (150+ lines)

## Files to Modify

1. **res://project.godot** - Add ErrorHandler autoload
2. **res://global.gd** - Add error_panel_instance singleton, update change_scene_with_check()
3. **res://level1/scene_template.gd** - Add show_error_in_play_area() function
4. **res://nakama_client.gd** - Add error handling to save_game() and load_game()
5. **res://settings_panel.tscn** - Add connection indicator (ColorRect + Label)
6. **res://settings_panel.gd** - Add connection status monitoring and display
7. **res://currency_manager.gd** - Add input validation to add_currency, deduct_currency
8. **res://level1/shop.gd** - Wrap purchases in ErrorBoundaries, safe node access
9. **res://level1/loading_screen.gd** - Safe node access in _ready()
10. **res://debug_panel.gd** (from plan 1.22) - Add show_for_error_report() function

---

## Dependencies

**Before This**:
- Phase 1.x-logging-debug-system (Logging Debug System) - DebugLogger and debug_panel must exist
- Phase 1.x-save-system-cloud (Save System Cloud) - NakamaClient cloud save system
- Phase 1.x-nakama-server (Nakama Server) - Nakama integration
- Phase 1.x-settings-panel (Settings Panel) - Scene template pattern with PlayArea
- Phase 1.x-scene-template (Scene Template) - MainLayout/PlayArea structure

**After This**:
- All future systems benefit from error handling
- Reduced crash reports from playtesters
- Better user experience during errors
- Seamless bug reporting flow

---

## Success Criteria

- [ ] Game never crashes from null references
- [ ] Connection indicator (blue/orange) in settings panel
- [ ] Notification appears when save fails: "Connection lost - progress not saved"
- [ ] Notification appears when connection restored
- [ ] Invalid cloud save data gets validated and clamped
- [ ] Missing cloud save starts fresh game with notification
- [ ] Scene load failures fall back gracefully
- [ ] Shop purchases refund on failure
- [ ] Error panel appears in PlayArea (like settings panel)
- [ ] Error panel hides game content while visible
- [ ] User sees friendly error messages (non-technical)
- [ ] "Show Details" button reveals technical info
- [ ] "Report Bug" button opens debug panel
- [ ] Debug panel pre-populates with error context
- [ ] Relevant logs auto-selected in debug panel
- [ ] Can submit bug report with custom description
- [ ] All errors logged to DebugLogger
- [ ] Multiple error recovery attempts trigger safe mode
- [ ] Validation prevents negative currency/stats

---

## Notes

**Cloud-Native Approach**:
- No local save files - trust Nakama infrastructure for backups
- Nakama PostgreSQL handles redundancy at database level
- Focus on handling connection failures gracefully
- Validate loaded data, clamp to safe ranges
- Never crashes - always finds a way forward

**User Experience Priority**:
- Error panel in PlayArea (consistent with settings panel)
- Simple messages by default
- Technical details on demand
- Direct path to bug reporting
- Automatic recovery when possible
- User prompted only for critical decisions
- Connection status always visible in settings

**Bug Reporting Flow**:
- Error occurs -> Error panel shows
- User clicks "Report Bug"
- Debug panel opens with pre-populated context
- Relevant logs auto-selected
- User adds description of what they were doing
- Submit to Nakama for review

**Developer Experience**:
- Easy to add boundaries with ErrorBoundaries.safe_* wrappers
- All errors logged with context
- Testing functions to simulate failures
- Clear error classification system
- Bug reports come with full context

---