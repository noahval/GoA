# Logging and Debug System Plan

## Overview
Comprehensive logging system with cloud-based bug reporting. Helps us find and fix problems during development, and collect detailed error reports from playtesters that get saved to the server for review.

## Core Goals
1. Centralized logging with adjustable detail levels
2. Automatic error collection to files
3. Player bug reporting tool with cloud storage
4. Enhanced logging mode for bug reproduction
5. Email notifications for new bug reports
6. Claude-assisted bug review and fixing workflow

---

## Part 1: Basic Logger (DebugLogger Autoload)

### What It Does
- Writes messages to a log file on disk
- Can adjust how much detail gets logged (levels: ERROR, WARN, INFO, DEBUG)
- Timestamps everything automatically
- Works in background, never interrupts gameplay
- Provides recent log buffer for bug reports

### Log Levels Explained
- **ERROR** (level 3): Crashes, broken features, critical failures
- **WARN** (level 2): Something's wrong but game keeps running
- **INFO** (level 1): Normal events worth tracking (player bought item, stat leveled up)
- **DEBUG** (level 0): Everything including tiny details (function called, variable changed)

### File: debug_logger.gd (Autoload)
```gdscript
extends Node

# Configuration - change these to control logging
var current_log_level: int = 1  # 0=DEBUG, 1=INFO, 2=WARN, 3=ERROR
var enable_logging: bool = true
var log_file_path: String = "user://goa_debug.log"
var enhanced_mode: bool = false  # For bug reproduction

var log_file: FileAccess = null
var recent_logs: Array[Dictionary] = []  # Buffer for bug reports
const MAX_RECENT_LOGS = 200  # Keep last 200 entries

func _ready():
	if enable_logging:
		_open_log_file()

func _exit_tree():
	_close_log_file()

func _open_log_file():
	log_file = FileAccess.open(log_file_path, FileAccess.WRITE)
	if log_file:
		log_file.store_line("========================================")
		log_file.store_line("GoA Debug Log Started")
		log_file.store_line("Time: " + Time.get_datetime_string_from_system())
		log_file.store_line("Enhanced Mode: " + str(enhanced_mode))
		log_file.store_line("========================================")
		log_file.flush()
	else:
		push_error("Could not create log file")

func _close_log_file():
	if log_file:
		log_file.store_line("========================================")
		log_file.store_line("Log Ended: " + Time.get_datetime_string_from_system())
		log_file.store_line("========================================")
		log_file.close()

# Main logging function
func write_log(message: String, level: int = 1, category: String = "GENERAL"):
	if not enable_logging:
		return

	# In enhanced mode, log everything regardless of level
	var effective_level = 0 if enhanced_mode else current_log_level

	if level < effective_level:
		return

	var level_name = ["DEBUG", "INFO", "WARN", "ERROR"][level]
	var timestamp = Time.get_datetime_string_from_system()
	var formatted = "[%s] [%s] [%s] %s" % [timestamp, level_name, category, message]

	# Write to file
	if log_file:
		log_file.store_line(formatted)
		log_file.flush()

	# Add to recent buffer for bug reports
	recent_logs.append({
		"timestamp": timestamp,
		"level": level_name,
		"category": category,
		"message": message,
		"formatted": formatted
	})

	# Trim buffer if too large
	if recent_logs.size() > MAX_RECENT_LOGS:
		recent_logs.pop_front()

	# Also print errors to console
	if level >= 3:
		push_error(message)

# Convenience functions
func debug(message: String, category: String = "DEBUG"):
	write_log(message, 0, category)

func info(message: String, category: String = "INFO"):
	write_log(message, 1, category)

func warn(message: String, category: String = "WARN"):
	write_log(message, 2, category)

func error(message: String, category: String = "ERROR"):
	write_log(message, 3, category)

# Get recent logs for bug reports
func get_recent_logs(count: int = 100) -> Array[Dictionary]:
	var start_index = max(0, recent_logs.size() - count)
	return recent_logs.slice(start_index)

# Enable enhanced logging for bug reproduction
func set_enhanced_mode(enabled: bool):
	enhanced_mode = enabled
	if enabled:
		info("Enhanced logging enabled - capturing all debug details", "LOGGER")
	else:
		info("Enhanced logging disabled - back to normal level", "LOGGER")
```

### Where to Add It
Add to project.godot autoload section:
```
DebugLogger="*res://debug_logger.gd"
```

---

## Part 2: Integration Points

### When to Log Things

#### Game Startup/Shutdown
```gdscript
# In loading_screen.gd _ready():
DebugLogger.info("Game started - Loading screen displayed", "GAME")

# When scene changes:
DebugLogger.info("Scene changed to: " + scene_name, "SCENE")
```

#### Errors and Warnings
```gdscript
# Whenever something goes wrong:
if not player_data_loaded:
	DebugLogger.error("Failed to load player data", "SAVE")

# When something suspicious happens:
if coins < 0:
	DebugLogger.warn("Coins went negative: " + str(coins), "CURRENCY")
```

#### Important Game Events
```gdscript
# Player purchases:
DebugLogger.info("Player bought shovel upgrade level " + str(level), "SHOP")

# Stat gains:
DebugLogger.info("Strength increased to " + str(strength), "STATS")

# Currency changes:
DebugLogger.info("Copper earned: " + str(amount) + " | Total: " + str(total), "CURRENCY")
```

### Strategic Placement
- **Global.gd**: Log stat changes, scene changes
- **Shop scenes**: Log purchases, currency spent
- **Save/Load**: Log save success/failure
- **Error handlers**: Log any caught errors
- **NakamaClient**: Log authentication, cloud saves, network errors

---

## Part 3: Bug Report System

### 3.1 Debug Panel in Settings

Add "Report Bug" button to settings panel that opens debug panel in play area.

### 3.2 Debug Panel UI (debug_panel.tscn)

**Components**:
- **Log Viewer** (TextEdit, read-only) - Shows recent logs
- **Simple/Advanced Toggle** - Switch between views
- **Enhanced Logging Toggle** - Enable detailed logging
- **Error Checkboxes** - Select relevant log entries (Advanced mode only)
- **Description TextEdit** - Player describes what happened
- **Submit Button** - Send bug report to server
- **Close Button** - Close panel

**Layout**:
```
[Debug Panel - Fills Play Area]
+----------------------------------------+
| Simple Mode [Toggle] Advanced Mode     |
+----------------------------------------+
| [Enhanced Logging: OFF] [Turn On]      |
+----------------------------------------+
| Log Viewer (scrollable):               |
| [2025-12-01 14:23] [INFO] Game started |
| [2025-12-01 14:24] [ERROR] Null ref... |
| ...                                    |
+----------------------------------------+
| (Advanced mode shows checkboxes here)  |
+----------------------------------------+
| Describe what happened:                |
| [                                    ] |
| [                                    ] |
+----------------------------------------+
| [Submit Bug Report]  [Close]           |
+----------------------------------------+
```

### 3.3 Debug Panel Script (debug_panel.gd)

```gdscript
extends Control

@onready var log_viewer = $LogViewer
@onready var mode_toggle = $ModeToggle
@onready var enhanced_toggle = $EnhancedToggle
@onready var error_list = $ErrorList  # VBoxContainer with checkboxes
@onready var description_box = $DescriptionBox
@onready var submit_button = $SubmitButton
@onready var close_button = $CloseButton

var is_advanced_mode = false
var selected_logs: Array[Dictionary] = []

func _ready():
	mode_toggle.pressed.connect(_on_mode_toggle)
	enhanced_toggle.pressed.connect(_on_enhanced_toggle)
	submit_button.pressed.connect(_on_submit_pressed)
	close_button.pressed.connect(_on_close_pressed)

	_refresh_logs()
	_update_ui_mode()

func _refresh_logs():
	var recent = DebugLogger.get_recent_logs(100)

	if is_advanced_mode:
		# Show logs with checkboxes
		_populate_error_list(recent)
	else:
		# Show simplified view
		_populate_simple_view(recent)

func _populate_simple_view(logs: Array[Dictionary]):
	log_viewer.clear()

	# Show errors and warnings only
	for log in logs:
		if log.level == "ERROR" or log.level == "WARN":
			var time = log.timestamp.split(" ")[1]  # Extract HH:MM:SS
			log_viewer.text += "[%s] %s: %s\n" % [time, log.level, log.message]

	if log_viewer.text.is_empty():
		log_viewer.text = "No errors or warnings in recent logs."

func _populate_error_list(logs: Array[Dictionary]):
	# Clear existing checkboxes
	for child in error_list.get_children():
		child.queue_free()

	# Add checkbox for each log entry
	for log in logs:
		var checkbox = CheckBox.new()
		var time = log.timestamp.split(" ")[1]
		checkbox.text = "[%s] [%s] [%s] %s" % [time, log.level, log.category, log.message]
		checkbox.toggled.connect(_on_log_selected.bind(log))
		error_list.add_child(checkbox)

func _on_log_selected(selected: bool, log: Dictionary):
	if selected:
		selected_logs.append(log)
	else:
		selected_logs.erase(log)

func _on_mode_toggle():
	is_advanced_mode = not is_advanced_mode
	_update_ui_mode()
	_refresh_logs()

func _update_ui_mode():
	if is_advanced_mode:
		mode_toggle.text = "Switch to Simple"
		error_list.visible = true
		log_viewer.visible = false
	else:
		mode_toggle.text = "Switch to Advanced"
		error_list.visible = false
		log_viewer.visible = true

func _on_enhanced_toggle():
	var enabled = not DebugLogger.enhanced_mode
	DebugLogger.set_enhanced_mode(enabled)

	if enabled:
		enhanced_toggle.text = "Enhanced: ON (capturing everything)"
	else:
		enhanced_toggle.text = "Enhanced: OFF"

func _on_submit_pressed():
	var description = description_box.text.strip_edges()

	if description.is_empty():
		_show_error("Please describe what happened")
		return

	submit_button.disabled = true
	submit_button.text = "Submitting..."

	# Prepare bug report data
	var bug_report = {
		"description": description,
		"timestamp": Time.get_datetime_string_from_system(),
		"game_version": "1.0",  # Update this from version manager
		"selected_logs": selected_logs if is_advanced_mode else [],
		"all_recent_logs": DebugLogger.get_recent_logs(100),
		"enhanced_mode": DebugLogger.enhanced_mode,
		"player_stats": _get_current_stats(),
		"player_progress": _get_current_progress()
	}

	# Submit to Nakama
	var success = await BugReporter.submit_bug_report(bug_report)

	if success:
		_show_success("Bug report submitted! Thank you!")
		description_box.text = ""
		selected_logs.clear()
		await get_tree().create_timer(2.0).timeout
		hide()
	else:
		_show_error("Failed to submit. Check your connection.")

	submit_button.disabled = false
	submit_button.text = "Submit Bug Report"

func _get_current_stats() -> Dictionary:
	return {
		"strength": Global.strength,
		"constitution": Global.constitution,
		"dexterity": Global.dexterity,
		"wisdom": Global.wisdom,
		"intelligence": Global.intelligence,
		"charisma": Global.charisma
	}

func _get_current_progress() -> Dictionary:
	return {
		"copper": Level1Vars.currency.copper,
		"silver": Level1Vars.currency.silver,
		"gold": Level1Vars.currency.gold,
		"platinum": Level1Vars.currency.platinum,
		"shovel_lvl": Level1Vars.shovel_lvl,
		"current_scene": get_tree().current_scene.scene_file_path
	}

func _on_close_pressed():
	hide()

func _show_error(message: String):
	# Show error label or popup
	pass

func _show_success(message: String):
	# Show success label or popup
	pass
```

---

## Part 4: Bug Reporter System

### 4.1 BugReporter Autoload (bug_reporter.gd)

```gdscript
extends Node

# Submit bug report to Nakama storage
func submit_bug_report(report_data: Dictionary) -> bool:
	if not NakamaClient.is_authenticated:
		DebugLogger.warn("Cannot submit bug report: Not authenticated", "BUG_REPORT")
		# Try to submit anyway using device ID
		await NakamaClient.authenticate_device()

		if not NakamaClient.is_authenticated:
			return false

	# Generate unique report ID
	var report_id = _generate_report_id()

	# Add metadata
	report_data["report_id"] = report_id
	report_data["user_id"] = NakamaClient.user_id
	report_data["username"] = NakamaClient.username
	report_data["platform"] = OS.get_name()

	# Store in Nakama
	var result = await NakamaClient.write_storage("bug_reports", report_id, report_data)

	if result:
		DebugLogger.info("Bug report submitted: " + report_id, "BUG_REPORT")

		# Trigger email notification (external script handles this)
		_notify_new_bug_report(report_id)

		return true
	else:
		DebugLogger.error("Failed to submit bug report", "BUG_REPORT")
		return false

func _generate_report_id() -> String:
	var timestamp = Time.get_unix_time_from_system()
	var random_suffix = randi() % 10000
	return "bug_%d_%04d" % [timestamp, random_suffix]

func _notify_new_bug_report(report_id: String):
	# This could call a webhook or write to a notification queue
	# For now, just write to a special collection that monitoring script checks
	var notification = {
		"report_id": report_id,
		"timestamp": Time.get_unix_time_from_system(),
		"notified": false
	}

	NakamaClient.write_storage("bug_notifications", report_id, notification)
	DebugLogger.info("Bug report notification queued", "BUG_REPORT")
```

Add to project.godot autoload:
```
BugReporter="*res://bug_reporter.gd"
```

---

## Part 5: Server-Side Monitoring & Email Notifications

### 5.1 Monitoring Script (External)

You'll need a separate script (Python, Node.js, etc.) that:
1. Runs on a schedule (e.g., every 15 minutes via cron)
2. Checks Nakama for new bug notifications
3. Sends you an email with bug report details
4. Marks notifications as sent

**Example: Python script (bug_monitor.py)**
```python
import requests
import time
import smtplib
from email.mime.text import MIMEText

NAKAMA_URL = "https://nakama.goasso.xyz"
SERVER_KEY = "hijbtdhbgiunhyojunbghijnhytgfrde"
YOUR_EMAIL = "your@email.com"

def check_new_bugs():
	# Query Nakama for bug_notifications collection
	# This is pseudocode - actual Nakama API calls needed
	response = requests.get(f"{NAKAMA_URL}/v2/storage/bug_notifications")

	new_reports = []
	for notification in response.json():
		if not notification['notified']:
			new_reports.append(notification['report_id'])

	return new_reports

def send_email_notification(report_ids):
	body = f"New bug reports submitted:\n\n"
	for report_id in report_ids:
		body += f"- {report_id}\n"

	body += f"\nTo review, tell Claude: 'Check bug reports from Nakama'"

	msg = MIMEText(body)
	msg['Subject'] = f"[GoA] {len(report_ids)} New Bug Report(s)"
	msg['From'] = "noreply@goasso.xyz"
	msg['To'] = YOUR_EMAIL

	# Send via your email provider
	# ... SMTP code here ...

def main():
	while True:
		new_bugs = check_new_bugs()

		if new_bugs:
			send_email_notification(new_bugs)

		time.sleep(900)  # Check every 15 minutes

if __name__ == "__main__":
	main()
```

### 5.2 Setup Instructions

1. **Create Python script** on your server or local machine
2. **Install dependencies**: `pip install requests`
3. **Configure email settings** (Gmail, SendGrid, etc.)
4. **Run as service** or cron job:
   ```bash
   # Cron every 15 minutes
   */15 * * * * /usr/bin/python3 /path/to/bug_monitor.py
   ```

---

## Part 6: Claude Bug Review Workflow

### 6.1 When You Get Email Notification

You receive email: "[GoA] 3 New Bug Report(s)"

### 6.2 Tell Claude to Review

In our chat, you say:
> "Claude, check for new bug reports from Nakama"

### 6.3 Claude Pulls Reports

I run code to query Nakama API:
```gdscript
# I would create a test script or use Nakama HTTP API directly
func fetch_bug_reports():
	# Authenticate to Nakama
	# Query bug_reports collection
	# Return all unreviewed reports
```

### 6.4 Claude Analyzes Each Report

For each report, I:
1. Read the description
2. Review selected logs / recent logs
3. Check player stats and progress
4. Identify the issue (null ref, logic error, missing validation, etc.)
5. Review relevant code files

### 6.5 Claude Suggests Fixes

I respond with:

**Option A: Confident Fix**
> "Bug Report #123: Null reference in shop.gd line 45
>
> **Issue**: Player can click upgrade button when coins are null
>
> **Fix**: Add null check before purchase
>
> I'm confident this is a simple fix. Should I implement it?"

**Option B: Need Your Input**
> "Bug Report #456: Currency conversion failing
>
> **Issue**: Player reports silver not converting to gold
>
> **Possible causes**:
> 1. Threshold logic incorrect
> 2. Market rate calculation broken
> 3. ATM unlock flag not set
>
> Which direction should I investigate first?"

### 6.6 You Approve or Guide

You say:
- "Looks good, fix it" → I implement the fix
- "Check cause #2" → I investigate further
- "Let me think about this" → I wait for your decision

---

## Part 7: Implementation Workflow

### Phase 1: Basic Logging (Do First)
- [ ] Create debug_logger.gd autoload
- [ ] Add to project.godot
- [ ] Add logging to Global.gd key events
- [ ] Add logging to shop scenes
- [ ] Test log file creation and writing

### Phase 2: Debug Panel UI (Do Second)
- [ ] Create debug_panel.tscn scene
- [ ] Build simple mode UI
- [ ] Build advanced mode UI
- [ ] Add enhanced logging toggle
- [ ] Test log display

### Phase 3: Bug Reporter (Do Third)
- [ ] Create bug_reporter.gd autoload
- [ ] Implement submit_bug_report function
- [ ] Test submission to Nakama
- [ ] Verify data structure in Nakama storage

### Phase 4: Email Monitoring (Do Fourth)
- [ ] Create monitoring script (Python/Node.js)
- [ ] Configure email settings
- [ ] Test email notifications
- [ ] Setup as cron job or service

### Phase 5: Claude Review Integration (Do Fifth)
- [ ] Document API endpoints for bug report queries
- [ ] Test Claude pulling reports from Nakama
- [ ] Establish fix approval workflow
- [ ] Run through complete bug report -> fix -> test cycle

---

## Success Criteria

- [ ] Log file created and populated during gameplay
- [ ] Can adjust log_level to see more/less detail
- [ ] Enhanced logging mode captures everything
- [ ] Debug panel displays logs clearly in both modes
- [ ] Playtesters can submit bug reports successfully
- [ ] Bug reports save to Nakama storage
- [ ] Email notifications work for new reports
- [ ] Claude can query and review bug reports
- [ ] Fix workflow is smooth (suggest -> approve -> implement)

---

## Notes

- Keep logging simple - don't log every frame
- Enhanced mode is for short-term bug reproduction only
- Bug reports should be anonymous-friendly (use device ID if not logged in)
- Email monitoring runs externally, not in game
- Claude can't autonomously poll - you trigger reviews

---

## Dependencies

**Before This**:
- Nakama Server Integration (for bug report storage)
- Save System Cloud Storage (uses same Nakama storage patterns)

**After This**:
- Can integrate with error handling system
- Can add performance monitoring later

---

## Files to Create

- `debug_logger.gd` - Core logging autoload
- `debug_panel.gd` / `debug_panel.tscn` - Bug report UI
- `bug_reporter.gd` - Bug submission autoload
- `bug_monitor.py` - External monitoring script (Python)
- Email configuration file for monitoring script

---

## API Reference for Claude

### Querying Bug Reports
```
GET https://nakama.goasso.xyz/v2/storage
Collection: bug_reports
Authorization: Bearer [server_key]
```

### Reading Specific Report
```
GET https://nakama.goasso.xyz/v2/storage/bug_reports/[report_id]
```

### Marking Report as Reviewed
```
PUT https://nakama.goasso.xyz/v2/storage
Collection: bug_reports
Key: [report_id]
Add field: "reviewed": true, "reviewed_by": "Claude", "reviewed_at": timestamp
```
