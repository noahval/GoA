# Nakama Server

## Overview
Build a clean, minimal Nakama client from scratch for cloud save functionality in the GoA rewrite. This is the AUTHORITATIVE SOURCE for all Nakama implementation details. Other plans (1.20, 1.21) reference this plan but do not duplicate implementation details.

## Purpose
Create a simple cloud backend connection that:
- Authenticates players (device ID, username/password, Google OAuth)
- Saves/loads game state to cloud storage (includes settings - see 1.x-settings-panel.md)
- Handles account migration (device ID to username/Google)
- Resolves save conflicts when migrating accounts

## Server Infrastructure
- **Server**: Nakama 3.x (will be migrated to new URL before implementation)
- **Plugin**: `addons/com.heroiclabs.nakama/` (Godot plugin)
- **Database**: PostgreSQL
- **Protocol**: HTTPS (port 443)
- **Note**: Server configuration (URL, key) will be finalized during implementation

---

## Part 1: Core Client Architecture

### 1.1 Create nakama_client.gd Autoload
Clean, minimal autoload script with only essential features.

**File**: `nakama_client.gd`

**Core Components**:
```gdscript
extends Node

# Nakama objects
var client: NakamaClient
var session: NakamaSession

# Server config (values TBD during implementation)
const SERVER_KEY = ""  # Set during implementation
const SERVER_HOST = ""  # Set during implementation
const SERVER_PORT = 443
const SERVER_SCHEME = "https"

# Auth state
var is_authenticated = false
var user_id = ""
var username = ""

# Signals
signal authentication_succeeded(session_data)
signal authentication_failed(error_message)
signal save_conflict_detected(device_save, account_save)
signal migration_completed(success: bool)
```

**Key Principles**:
- Keep it simple - only what's necessary
- No socket connection (not needed for single-player)
- No deprecated functions
- Clean error handling
- All saves are cloud-based (NO local save fallback)

### 1.2 Initialize Client
Basic client setup on ready:
```gdscript
func _ready():
	_initialize_client()

func _initialize_client():
	client = Nakama.create_client(
		SERVER_KEY,
		SERVER_HOST,
		SERVER_PORT,
		SERVER_SCHEME
	)
```

---

## Part 2: Authentication Methods

All three authentication methods create cloud-based Nakama accounts. There are NO local saves or offline fallback.

### 2.1 Device ID Authentication
Cloud-based authentication using device ID - no username/password required.

**Purpose**: Low-friction authentication that still provides cloud saves.

**Implementation**:
```gdscript
func authenticate_device() -> bool:
	var device_id = OS.get_unique_id()
	var auth_result = await client.authenticate_device_async(
		device_id,
		null,
		true,  # Create account if doesn't exist
		{}
	)

	if auth_result.is_exception():
		var error = auth_result.get_exception().message
		authentication_failed.emit(error)
		return false

	session = auth_result as NakamaSession
	_set_auth_state(session)
	authentication_succeeded.emit(_get_session_data())
	return true
```

**Note**: Device ID creates a CLOUD account linked to this device. It's not "offline mode" - it's cloud-based authentication without username/password.

### 2.2 Username/Password Authentication
For players who want portable accounts accessible from any device.

**Purpose**: Manual account creation and login.

**Implementation**:
```gdscript
func authenticate_email(username_input: String, password: String, create_account: bool) -> bool:
	# Use custom auth with hashed password for unique ID
	var custom_id = username_input + ":" + password.sha256_text()

	var auth_result = await client.authenticate_custom_async(
		custom_id,
		username_input,
		create_account
	)

	if auth_result.is_exception():
		var error = auth_result.get_exception().message
		authentication_failed.emit(error)
		return false

	session = auth_result as NakamaSession
	_set_auth_state(session)
	authentication_succeeded.emit(_get_session_data())
	return true
```

### 2.3 Google OAuth (Web Builds Only)
For web players using Google accounts.

**Purpose**: SSO for web builds.

**Implementation**:
```gdscript
func authenticate_google(google_token: String) -> bool:
	var auth_result = await client.authenticate_google_async(
		google_token,
		null,
		true,  # Create account if doesn't exist
		{}
	)

	if auth_result.is_exception():
		var error = auth_result.get_exception().message
		authentication_failed.emit(error)
		return false

	session = auth_result as NakamaSession
	_set_auth_state(session)
	authentication_succeeded.emit(_get_session_data())
	return true
```

### 2.4 Helper Functions
```gdscript
func _set_auth_state(nakama_session: NakamaSession):
	is_authenticated = true
	user_id = nakama_session.user_id
	username = nakama_session.username

func _get_session_data() -> Dictionary:
	return {
		"user_id": user_id,
		"username": username,
		"session": session
	}
```

---

## Part 3: Cloud Storage API

### 3.1 Generic Storage Functions
Low-level read/write for any data.

**Write Storage**:
```gdscript
func write_storage(collection: String, key: String, value: Dictionary):
	if not is_authenticated:
		DebugLogger.error("Cannot write storage: Not authenticated")
		return null

	var write_object = NakamaWriteStorageObject.new(
		collection,
		key,
		2,  # Read permission: owner only
		1,  # Write permission: owner only
		JSON.stringify(value),
		""
	)

	var result = await client.write_storage_objects_async(session, [write_object])

	if result.is_exception():
		DebugLogger.error("Storage write failed: " + result.get_exception().message)
		return null

	return result
```

**Read Storage**:
```gdscript
func read_storage(collection: String, key: String):
	if not is_authenticated:
		DebugLogger.error("Cannot read storage: Not authenticated")
		return null

	var storage_id = NakamaStorageObjectId.new(collection, key, user_id)
	var result = await client.read_storage_objects_async(session, [storage_id])

	if result.is_exception():
		DebugLogger.error("Storage read failed: " + result.get_exception().message)
		return null

	if result.objects.size() > 0:
		return JSON.parse_string(result.objects[0].value)

	return null
```

### 3.2 Game Save/Load Functions
High-level functions for full game state.

**Save Game**:
```gdscript
func save_game() -> bool:
	if not is_authenticated:
		DebugLogger.error("Cannot save: Not authenticated")
		return false

	# Update timestamp before saving
	Level1Vars.last_played_timestamp = Time.get_unix_time_from_system()

	var save_data = {
		"version": "2.0",
		"timestamp": Time.get_unix_time_from_system(),
		"global": _get_global_data(),
		"level1_vars": _get_level1_vars_data()
	}

	var result = await write_storage("player_data", "game_save", save_data)
	if result:
		DebugLogger.info("Game saved to cloud")
		return true

	DebugLogger.error("Game save failed")
	return false
```

**Load Game**:
```gdscript
func load_game() -> bool:
	if not is_authenticated:
		DebugLogger.error("Cannot load: Not authenticated")
		return false

	var save_data = await read_storage("player_data", "game_save")

	if not save_data:
		DebugLogger.info("No cloud save found")
		return false

	if not save_data.has("global") or not save_data.has("level1_vars"):
		DebugLogger.error("Invalid cloud save structure")
		return false

	_set_global_data(save_data.global)
	_set_level1_vars_data(save_data.level1_vars)

	DebugLogger.info("Game loaded from cloud")
	return true
```

**Note**: Settings are included in the game save using the combined approach from 1.x-settings-panel.md. Settings are preserved during prestige/reset operations through surgical preservation (see 1.x-settings-panel.md for details).

---

## Part 4: Save Data Serialization

### 4.1 Global Data Serialization
Framework for adding Global.gd variables to cloud saves.

**Get Global Data**:
```gdscript
func _get_global_data() -> Dictionary:
	return {
		# Settings (preserved during prestige/reset - see 1.x-settings-panel.md)
		"ui_scale": Global.ui_scale,
		"music_volume": Global.music_volume,
		"sfx_volume": Global.sfx_volume,
		# Note: dev_speed_mode is session-only, not saved to cloud

		# Stats
		"strength": Global.strength,
		"constitution": Global.constitution,
		"dexterity": Global.dexterity,
		"wisdom": Global.wisdom,
		"intelligence": Global.intelligence,
		"charisma": Global.charisma,

		# Experience
		"strength_exp": Global.strength_exp,
		"constitution_exp": Global.constitution_exp,
		"dexterity_exp": Global.dexterity_exp,
		"wisdom_exp": Global.wisdom_exp,
		"intelligence_exp": Global.intelligence_exp,
		"charisma_exp": Global.charisma_exp,

		# Play time tracking (for migration conflict resolution)
		"total_play_length": Global.total_play_length,
		"last_played_timestamp": Time.get_unix_time_from_system(),

		# ADD MORE GLOBAL VARIABLES HERE AS NEEDED
	}
```

**Set Global Data**:
```gdscript
func _set_global_data(data: Dictionary) -> void:
	# Settings (preserved during prestige/reset - see 1.x-settings-panel.md)
	Global.ui_scale = data.get("ui_scale", 1.0)
	Global.music_volume = data.get("music_volume", 0.8)
	Global.sfx_volume = data.get("sfx_volume", 0.8)
	# Note: dev_speed_mode is session-only, not loaded from cloud

	# Stats
	Global.strength = data.get("strength", 1.0)
	Global.constitution = data.get("constitution", 1.0)
	Global.dexterity = data.get("dexterity", 1.0)
	Global.wisdom = data.get("wisdom", 1.0)
	Global.intelligence = data.get("intelligence", 1.0)
	Global.charisma = data.get("charisma", 1.0)

	# Experience
	Global.strength_exp = data.get("strength_exp", 0.0)
	Global.constitution_exp = data.get("constitution_exp", 0.0)
	Global.dexterity_exp = data.get("dexterity_exp", 0.0)
	Global.wisdom_exp = data.get("wisdom_exp", 0.0)
	Global.intelligence_exp = data.get("intelligence_exp", 0.0)
	Global.charisma_exp = data.get("charisma_exp", 0.0)

	# Play time tracking
	Global.total_play_length = data.get("total_play_length", 0.0)

	# ADD MORE GLOBAL VARIABLES HERE AS NEEDED
```

**Note**: `total_play_length` variable needs to be added to Global.gd (see plan 1.3-global-autoload.md).

### 4.2 Level1Vars Data Serialization
Framework for adding Level1Vars.gd variables to cloud saves.

**Get Level1Vars Data**:
```gdscript
func _get_level1_vars_data() -> Dictionary:
	return {
		# Currency (multi-tier system)
		"currency": Level1Vars.currency,
		"lifetime_currency": Level1Vars.lifetime_currency,

		# Resources
		"coal": Level1Vars.coal,

		# Upgrades (will be added as development progresses)
		"shovel_lvl": Level1Vars.shovel_lvl if Level1Vars.has("shovel_lvl") else 0,
		"plow_lvl": Level1Vars.plow_lvl if Level1Vars.has("plow_lvl") else 0,

		# Timestamps
		"last_played_timestamp": Level1Vars.last_played_timestamp,

		# ADD MORE LEVEL1VARS VARIABLES HERE AS NEEDED
	}
```

**Set Level1Vars Data**:
```gdscript
func _set_level1_vars_data(data: Dictionary) -> void:
	# Currency (multi-tier system with defaults)
	Level1Vars.currency = data.get("currency", {"copper": 0.0, "silver": 0.0, "gold": 0.0, "platinum": 0.0})
	Level1Vars.lifetime_currency = data.get("lifetime_currency", {"copper": 0.0, "silver": 0.0, "gold": 0.0, "platinum": 0.0})

	# Resources
	Level1Vars.coal = data.get("coal", 0.0)

	# Upgrades
	if Level1Vars.has("shovel_lvl"):
		Level1Vars.shovel_lvl = data.get("shovel_lvl", 0)
	if Level1Vars.has("plow_lvl"):
		Level1Vars.plow_lvl = data.get("plow_lvl", 0)

	# Timestamps
	Level1Vars.last_played_timestamp = data.get("last_played_timestamp", Time.get_unix_time_from_system())

	# ADD MORE LEVEL1VARS VARIABLES HERE AS NEEDED
```

---

## Part 4: Account Migration System

When a player switches from device ID authentication to username/password or Google authentication, their progress needs to migrate to the new account.

### 4.1 Check for Migration
Determines if migration is needed and if there are conflicts.

```gdscript
func check_for_migration_needed(old_user_id: String, new_user_id: String) -> Dictionary:
	# Read saves from both accounts
	var old_save = await _read_storage_for_user(old_user_id, "player_data", "game_save")
	var new_save = await _read_storage_for_user(new_user_id, "player_data", "game_save")

	var has_old_save = old_save != null
	var has_new_save = new_save != null

	return {
		"needs_migration": has_old_save,
		"has_conflict": has_old_save and has_new_save,
		"old_save": old_save if has_old_save else {},
		"new_save": new_save if has_new_save else {}
	}

func _read_storage_for_user(target_user_id: String, collection: String, key: String):
	# Helper to read storage for a specific user ID
	var storage_id = NakamaStorageObjectId.new(collection, key, target_user_id)
	var result = await client.read_storage_objects_async(session, [storage_id])

	if result.is_exception():
		return null

	if result.objects.size() > 0:
		return JSON.parse_string(result.objects[0].value)

	return null
```

### 4.2 Migrate Save Between Accounts
Copies save data from device ID account to username/Google account.

```gdscript
func migrate_save_to_account(from_user_id: String, to_user_id: String) -> bool:
	# Read save from old account
	var old_save = await _read_storage_for_user(from_user_id, "player_data", "game_save")

	if not old_save:
		DebugLogger.error("No save found on old account")
		return false

	# Write save to new account (overwrites if exists)
	var result = await write_storage("player_data", "game_save", old_save)

	if result:
		DebugLogger.info("Save migrated successfully")
		migration_completed.emit(true)
		return true
	else:
		DebugLogger.error("Save migration failed")
		migration_completed.emit(false)
		return false
```

### 4.3 Get Save Summary for Conflict Resolution
Extracts key information from save data to display in conflict resolution UI.

```gdscript
func get_save_summary(save_data: Dictionary) -> Dictionary:
	if not save_data.has("global") or not save_data.has("level1_vars"):
		return {}

	var global_data = save_data.global
	var level1_data = save_data.level1_vars

	# Convert total_play_length from seconds to hours
	var play_hours = global_data.get("total_play_length", 0.0) / 3600.0

	return {
		"last_played": save_data.get("timestamp", 0),
		"total_play_hours": play_hours,
		"stats": {
			"strength": global_data.get("strength", 1),
			"constitution": global_data.get("constitution", 1),
			"dexterity": global_data.get("dexterity", 1),
			"wisdom": global_data.get("wisdom", 1),
			"intelligence": global_data.get("intelligence", 1),
			"charisma": global_data.get("charisma", 1)
		},
		"currency": level1_data.get("currency", {"copper": 0, "silver": 0, "gold": 0, "platinum": 0})
	}
```

### 4.4 Emit Conflict Signal
When migration conflict detected, emit signal for UI to handle.

```gdscript
func emit_save_conflict(device_save: Dictionary, account_save: Dictionary):
	# Get summaries for UI display
	var device_summary = get_save_summary(device_save)
	var account_summary = get_save_summary(account_save)

	save_conflict_detected.emit(device_summary, account_summary)
```

---

## Part 5: Connection Status Monitoring

Track connection state and notify player when saves fail.

### 5.1 Connection State Tracking

**Add to nakama_client.gd**:
```gdscript
# Connection state
var is_connected: bool = true
var last_successful_save: float = 0.0

signal connection_lost()
signal connection_restored()
```

### 5.2 Update Save/Load to Track Connection

**Modify save_game()**:
```gdscript
func save_game() -> bool:
	if not is_authenticated:
		DebugLogger.error("Cannot save: Not authenticated", "NAKAMA")
		_mark_connection_lost()
		return false

	var save_data = {
		"version": "2.0",
		"timestamp": Time.get_unix_time_from_system(),
		"global": _get_global_data(),
		"level1_vars": _get_level1_vars_data()
	}

	var result = await write_storage("player_data", "game_save", save_data)

	if result:
		_mark_connection_success()
		DebugLogger.info("Game saved to cloud", "NAKAMA")
		return true
	else:
		_mark_connection_lost()
		DebugLogger.error("Game save failed", "NAKAMA")
		return false

func _mark_connection_success():
	var was_disconnected = not is_connected
	is_connected = true
	last_successful_save = Time.get_unix_time_from_system()

	if was_disconnected:
		connection_restored.emit()
		Global.show_stat_notification("Connection restored", "success")

func _mark_connection_lost():
	if is_connected:
		is_connected = false
		connection_lost.emit()
		Global.show_stat_notification("Connection lost - progress not saved", "warning")
```

### 5.3 Connection Indicator in Settings Panel

**Add to settings_panel.tscn UI**:
```
SettingsPanel
└── MarginContainer
    └── VBoxContainer
        ├── HeaderHBox
        │   ├── TitleLabel ("Settings")
        │   ├── Spacer (Control with expand)
        │   ├── ConnectionStatus (HBoxContainer)
        │   │   ├── ConnectionDot (ColorRect, 12x12)
        │   │   └── ConnectionLabel ("Connected")
        │   └── CloseButton ("X")
        ...
```

**Add to settings_panel.gd**:
```gdscript
@onready var connection_dot = $MarginContainer/VBoxContainer/HeaderHBox/ConnectionStatus/ConnectionDot
@onready var connection_label = $MarginContainer/VBoxContainer/HeaderHBox/ConnectionStatus/ConnectionLabel

func _ready():
	# Existing code...

	# Connect to Nakama signals
	NakamaClient.connection_lost.connect(_on_connection_lost)
	NakamaClient.connection_restored.connect(_on_connection_restored)

	# Update initial status
	_update_connection_display()

	# Periodic refresh
	var timer = Timer.new()
	timer.wait_time = 5.0
	timer.autostart = true
	timer.timeout.connect(_update_connection_display)
	add_child(timer)

func _update_connection_display():
	if NakamaClient.is_connected:
		connection_dot.color = Color(0.2, 0.8, 0.3)  # Green
		connection_label.text = "Connected"
	else:
		connection_dot.color = Color(1.0, 0.5, 0.0)  # Orange
		connection_label.text = "Disconnected"

func _on_connection_lost():
	_update_connection_display()

func _on_connection_restored():
	_update_connection_display()
```

---

## Part 6: Error Handling

### 6.1 Authentication Failures
If authentication fails (server unreachable, invalid credentials):
- Emit `authentication_failed` signal with error message
- Return `false` from auth function
- Caller (auth screen) can show error to player and allow retry

**No offline fallback** - all three auth methods require server connection.

### 6.2 Unauthenticated Storage Access
If trying to save/load without authentication:
- Log error via DebugLogger
- Return `null` or `false`
- Don't crash - let caller handle gracefully

### 6.3 Save/Load Failures
If storage operations fail:
- Log error via DebugLogger
- Return `null` or `false`
- Mark connection as lost
- Show notification to player
- Caller can retry or show error to player

---

## Implementation Checklist

### Phase 1: Core Client
- [ ] Create `nakama_client.gd` file
- [ ] Add to project.godot as autoload
- [ ] Implement `_initialize_client()`
- [ ] Set placeholder server config (update later)

### Phase 2: Authentication
- [ ] Implement device ID authentication
- [ ] Implement username/password authentication
- [ ] Implement Google OAuth authentication (web only)
- [ ] Add helper functions for auth state
- [ ] Implement authentication signals

### Phase 3: Storage API
- [ ] Implement generic `write_storage()`
- [ ] Implement generic `read_storage()`
- [ ] Implement `save_game()` (includes settings - see 1.x-settings-panel.md)
- [ ] Implement `load_game()` (includes settings - see 1.x-settings-panel.md)

### Phase 4: Serialization
- [ ] Implement `_get_global_data()` with settings, stats, and total_play_length
- [ ] Implement `_set_global_data()` with settings, stats, and total_play_length
- [ ] Implement `_get_level1_vars_data()` with currency/coal/upgrades
- [ ] Implement `_set_level1_vars_data()` with currency/coal/upgrades
- [ ] Add comments indicating where to add more variables
- [ ] See 1.x-settings-panel.md for settings preservation during reset/prestige

### Phase 5: Migration System
- [ ] Implement `check_for_migration_needed()`
- [ ] Implement `_read_storage_for_user()` helper
- [ ] Implement `migrate_save_to_account()`
- [ ] Implement `get_save_summary()` for conflict UI
- [ ] Implement `emit_save_conflict()` signal
- [ ] Add migration signals

### Phase 6: Connection Monitoring
- [ ] Add `is_connected` state variable
- [ ] Add `connection_lost` and `connection_restored` signals
- [ ] Implement `_mark_connection_success()`
- [ ] Implement `_mark_connection_lost()`
- [ ] Update `save_game()` to track connection state
- [ ] Add connection indicator UI to settings panel
- [ ] Connect settings panel to Nakama signals
- [ ] Test connection loss detection
- [ ] Test connection restoration detection

### Phase 7: Error Handling
- [ ] Test authentication failure (no server)
- [ ] Test invalid credentials
- [ ] Test unauthenticated storage access
- [ ] Test save/load failures
- [ ] Test connection lost notification
- [ ] Test connection restored notification

### Phase 8: Integration with Global.gd
- [ ] Add `total_play_length` variable to Global.gd (see plan 1.3)
- [ ] Track total play time in seconds (increment in _process)
- [ ] Ensure all serialized variables exist in Global.gd

---

## Integration Notes

### Auth Screen Integration (Plan 1.21)
- Auth screen calls these authentication functions
- Auth screen handles migration UI and conflict resolution
- Auth screen loads game (including settings) after successful auth

### Save System Integration (Plan 1.20)
- Save system determines WHEN to call `save_game()`
- This plan provides the IMPLEMENTATION of `save_game()`
- Save triggers: purchases, stat gains, scene changes, periodic, exit

### Settings Persistence (1.x-settings-panel.md)
- Settings are included in game save using combined approach
- Settings preserved during prestige/reset via surgical preservation
- See 1.x-settings-panel.md for settings panel and persistence logic

---

## Dependencies

**Before This Plan**:
- [x] Global.gd with stats system (1.x-global-autoload.md) - needs `total_play_length` added
- [x] Level1Vars autoload (1.x-level-variables-autoload.md)
- [x] Currency system (1.x-currencies.md, 1.x-currency-manager.md, 1.x-atm-scene.md)
- [x] Settings Panel (1.x-settings-panel.md) - provides settings variables and persistence logic

**After This Plan**:
- [ ] Auth Screen (1.x-auth-screen.md) - Uses authentication functions
- [ ] Save System Cloud (1.x-save-system-cloud.md) - Determines save triggers

---

## Files Created

- `nakama_client.gd` - Cloud backend client (autoload)

**Files Modified**:
- `project.godot` - Add NakamaClient autoload
- `global.gd` - Add `total_play_length` variable (coordinate with 1.x-global-autoload.md)
- `settings_panel.tscn` - Add connection indicator UI (see 1.x-settings-panel.md)
- `settings_panel.gd` - Connect to Nakama signals and display connection status

---

## Success Criteria

- [ ] NakamaClient autoload exists and initializes
- [ ] Device ID auth creates cloud accounts
- [ ] Username/password auth creates/logs into cloud accounts
- [ ] Google OAuth works on web builds
- [ ] `save_game()` writes game state (including settings) to cloud storage
- [ ] `load_game()` reads game state (including settings) from cloud storage
- [ ] Settings included in Global data serialization (see 1.x-settings-panel.md)
- [ ] Settings persist across save wipes (via 1.x-settings-panel.md surgical preservation)
- [ ] `check_for_migration_needed()` detects account migration scenarios
- [ ] `migrate_save_to_account()` copies saves between accounts
- [ ] `get_save_summary()` provides data for conflict resolution UI
- [ ] Migration signals emit correctly
- [ ] Connection state tracked (is_connected variable)
- [ ] Connection lost signal emits when save fails
- [ ] Connection restored signal emits when save succeeds after failure
- [ ] Connection indicator shows in settings panel header
- [ ] Green dot + "Connected" when connected
- [ ] Orange dot + "Disconnected" when connection lost
- [ ] Notification shown when connection lost
- [ ] Notification shown when connection restored
- [ ] Authentication failures handled gracefully (no crashes)
- [ ] Framework allows easy addition of new save variables
- [ ] Clean, readable code with no v1 spaghetti
- [ ] All saves are cloud-based (no local save system)

---

## Notes

### Clean Rebuild Philosophy
- Don't copy v1 code, rebuild from scratch
- Simple and minimal: Only essential features, no bloat
- Framework approach: Easy to add variables as development progresses

### Cloud-Only Architecture
- NO local saves or offline fallback
- Device ID authentication creates cloud account (not "offline mode")
- All three auth methods require server connection
- All saves stored on Nakama server

### Account Types
- **Device ID**: Cloud account linked to this device (convenient, no login)
- **Username/Password**: Cloud account accessible from any device (portable)
- **Google OAuth**: Cloud account via Google SSO (web builds)

### Migration System
- Happens automatically when switching from device ID to username/Google
- No conflict: Ask user to upload device ID progress
- Conflict: Show both saves with timestamps/play time, let user choose
- Requires `total_play_length` tracking in Global.gd (coordinate with 1.x-global-autoload.md)

### Settings Persistence (1.x-settings-panel.md)
- Uses combined approach: settings and game progress in same save
- Settings preserved during prestige/reset via surgical preservation
- Settings variables: ui_scale, music_volume, sfx_volume (dev_speed_mode is session-only)
- See 1.x-settings-panel.md for full implementation details

### Future Server Migration
- Server URL will change before implementation
- Fresh start when implemented (wipe old saves)
- Test thoroughly after server migration

---
