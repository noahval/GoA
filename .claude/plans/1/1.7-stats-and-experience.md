# Stats & Experience System

**Goal**: Implement six-stat system with independent XP tracking and leveling mechanics

**Success Criteria**:
- Six stats (STR, DEX, CON, INT, WIS, CHA) implemented with integer level tracking
- XP accumulation per stat with configurable leveling curve
- Level-up notifications trigger automatically
- Progress tracking API for UI integration
- Save/load persistence for all stat and XP values
- Unit tests validate leveling mechanics

**Prerequisites**:
- Phase 1.3: Global Autoload (Global.gd exists)

---

## Overview

**IMPORTANT: Complete Rewrite Context**
This plan is part of a complete game rewrite. The stats and experience systems provide foundational character progression that persists across all game phases.

The stats and experience system provides the core character progression framework for GoA. Six independent stats (Strength, Dexterity, Constitution, Intelligence, Wisdom, Charisma) each accumulate experience points and level up independently. This plan focuses solely on the backend data structures and leveling mechanics - individual gameplay features will handle awarding XP and using stat values.

### Key Design Principles

- **Backend Mechanic Only**: No UI in this phase - pure data and logic
- **Independent Progression**: Each stat has its own XP pool and levels independently
- **Unified Curve**: All stats use the same leveling formula (no per-stat scaling)
- **Integer Levels**: Stats are whole numbers (1, 2, 3...), XP is fractional for smooth accumulation
- **No Caps**: Stats can level indefinitely (phase-specific caps handled elsewhere if needed)
- **No Reset**: Stats are permanent progression (no respec mechanics)
- **Automatic Notifications**: Stat setters trigger simple feedback messages on level-up
- **Separation of Concerns**: This plan defines WHAT stats are and HOW they level - feature plans define WHEN/WHY they're awarded

---

## Architecture Overview

### Data Flow

```
Gameplay Action -> Feature awards XP -> add_stat_exp()
                                     -> XP accumulates
                                     -> _check_level_up()
                                     -> Stat increases
                                     -> Setter triggers notification
                                     -> Save system persists
```

### Component Separation

- **This Phase (1.8)**: Data structures, leveling formula, core API
- **Feature Plans**: When/why XP is awarded (furnace -> STR, talking -> CHA, etc.)
- **Phase 2.9**: Progression pacing and balance for copper era
- **UI Plans**: Visual display of stats and XP progress (future)

---

## Implementation Tasks

### 1. Stat Variables with Notification Setters

**File Location**: `res://global.gd` (or `res://autoloads/global.gd`)

**Variables needed**:
```gdscript
# ===== SIX-STAT SYSTEM =====

var strength: int = 1:
	set(value):
		if is_node_ready() and value > strength:
			show_stat_notification("You feel stronger")
		strength = value

var dexterity: int = 1:
	set(value):
		if is_node_ready() and value > dexterity:
			show_stat_notification("You feel more precise")
		dexterity = value

var constitution: int = 1:
	set(value):
		if is_node_ready() and value > constitution:
			show_stat_notification("You feel more resilient")
		constitution = value

var intelligence: int = 1:
	set(value):
		if is_node_ready() and value > intelligence:
			show_stat_notification("You feel smarter")
		intelligence = value

var wisdom: int = 1:
	set(value):
		if is_node_ready() and value > wisdom:
			show_stat_notification("You feel more introspective")
		wisdom = value

var charisma: int = 1:
	set(value):
		if is_node_ready() and value > charisma:
			show_stat_notification("You understand people better")
		charisma = value
```

**Implementation Details**:
- Type: `int` (whole levels only)
- Starting value: 1 (everyone starts at level 1)
- Setter logic:
  - Checks `is_node_ready()` to prevent notifications during load/initialization
  - Only triggers notification when value increases (not decreases)
  - Compares new value to current value before assignment
- Notification messages are simple, consistent flavor text

---

### 2. Experience Tracking Variables

**Variables needed**:
```gdscript
# ===== EXPERIENCE SYSTEM =====

# Experience accumulation per stat (fractional for smooth accumulation)
var strength_exp: float = 0.0
var dexterity_exp: float = 0.0
var constitution_exp: float = 0.0
var intelligence_exp: float = 0.0
var wisdom_exp: float = 0.0
var charisma_exp: float = 0.0
```

**Implementation Details**:
- Type: `float` (allows fractional XP like 0.4 per action)
- Starting value: 0.0 (no XP at game start)
- No setters needed (simple accumulation, no side effects)
- XP never decreases (only accumulates over time)

---

### 3. Experience Curve Configuration

**Constants needed**:
```gdscript
# XP curve configuration
const BASE_XP_FOR_LEVEL = 100.0     # XP needed for first level-up (1->2)
const EXP_SCALING = 1.8              # Growth curve steepness
```

**XP Formula**:
```gdscript
func get_xp_for_level(level: int) -> float:
	if level <= 1:
		return 0.0
	return BASE_XP_FOR_LEVEL * pow(level - 1, EXP_SCALING)
```

**Formula**: `XP_for_level_N = 100 * (N - 1)^1.8`

**Leveling Progression Table**:

| Level | XP Required (This Level) | Total XP | XP to Next |
|-------|-------------------------|----------|------------|
| 1 | 0 | 0 | 100 |
| 2 | 100 | 100 | 349 |
| 3 | 349 | 449 | 721 |
| 4 | 721 | 1,170 | 1,200 |
| 5 | 1,200 | 2,370 | 1,770 |
| 6 | 1,770 | 4,140 | 2,430 |
| 7 | 2,430 | 6,570 | 3,180 |
| 8 | 3,180 | 9,750 | 4,020 |
| 9 | 4,020 | 13,770 | 4,940 |
| 10 | 4,940 | 18,710 | 5,950 |

**Rationale**:
- Gentle enough for early progression (level 2 feels achievable)
- Steep enough to feel meaningful (level 10+ is a real achievement)
- Same curve for all stats (simpler to balance, no "easy" or "hard" stats)

---

### 4. Core API Functions

#### Add Experience (Primary Public API)

```gdscript
# Add experience to a stat and handle level-ups
func add_stat_exp(stat_name: String, amount: float) -> void:
	var stat_data = _get_stat_data(stat_name)
	if not stat_data:
		push_error("Invalid stat name: " + stat_name)
		return

	if amount <= 0:
		push_warning("Attempted to add non-positive XP: %.2f" % amount)
		return

	# Add experience
	var old_exp = get(stat_data.exp_var)
	set(stat_data.exp_var, old_exp + amount)

	# Check for level-up(s)
	_check_level_up(stat_name)
```

**Usage**:
```gdscript
# From gameplay code
Global.add_stat_exp("strength", 0.4)     # Small incremental gain
Global.add_stat_exp("intelligence", 50)  # Larger discovery bonus
Global.add_stat_exp("charisma", 2.0)     # Social interaction
```

**Behavior**:
- Adds XP to the specified stat's XP pool
- Validates stat name (errors on typos)
- Rejects negative or zero XP amounts
- Automatically checks for level-ups after adding XP
- Can trigger multiple level-ups if enough XP added at once

---

#### Check Level-Up (Internal)

```gdscript
# Check if a stat should level up (can level multiple times)
func _check_level_up(stat_name: String) -> void:
	var stat_data = _get_stat_data(stat_name)
	if not stat_data:
		return

	var current_level = get(stat_data.stat_var)
	var current_exp = get(stat_data.exp_var)
	var xp_needed = get_xp_for_level(current_level + 1)

	# Keep leveling up while we have enough XP
	while current_exp >= xp_needed:
		current_level += 1
		set(stat_data.stat_var, current_level)
		# Setter will trigger notification automatically

		# Check if we can level again
		xp_needed = get_xp_for_level(current_level + 1)
```

**Behavior**:
- Uses `while` loop to handle multiple level-ups
- Example: Adding 1000 XP at level 1 could jump straight to level 3+
- Setter triggers notification for each level gained
- XP is never consumed (accumulates forever - level is just a threshold check)

---

#### Get Level Progress (UI Helper)

```gdscript
# Get progress toward next level (0.0 to 1.0)
func get_stat_level_progress(stat_name: String) -> float:
	var stat_data = _get_stat_data(stat_name)
	if not stat_data:
		return 0.0

	var current_level = get(stat_data.stat_var)
	var current_exp = get(stat_data.exp_var)
	var xp_for_current = get_xp_for_level(current_level)
	var xp_for_next = get_xp_for_level(current_level + 1)
	var xp_in_level = current_exp - xp_for_current
	var xp_needed_in_level = xp_for_next - xp_for_current

	if xp_needed_in_level <= 0:
		return 1.0

	return clamp(xp_in_level / xp_needed_in_level, 0.0, 1.0)
```

**Returns**:
- `0.0` = Just leveled up (no progress toward next level)
- `0.5` = Halfway to next level
- `1.0` = At threshold (about to level up on next XP gain)

**Usage** (future UI):
```gdscript
var progress = Global.get_stat_level_progress("strength")
progress_bar.value = progress * 100  # Convert to percentage
```

---

#### Stat Data Helper (Internal)

```gdscript
# Get stat variable names for dynamic access
func _get_stat_data(stat_name: String) -> Dictionary:
	var stat_map = {
		"strength": {"stat_var": "strength", "exp_var": "strength_exp"},
		"dexterity": {"stat_var": "dexterity", "exp_var": "dexterity_exp"},
		"constitution": {"stat_var": "constitution", "exp_var": "constitution_exp"},
		"intelligence": {"stat_var": "intelligence", "exp_var": "intelligence_exp"},
		"wisdom": {"stat_var": "wisdom", "exp_var": "wisdom_exp"},
		"charisma": {"stat_var": "charisma", "exp_var": "charisma_exp"}
	}
	return stat_map.get(stat_name.to_lower(), {})
```

**Purpose**: Maps stat names (strings) to variable names for dynamic access

**Rationale**: Allows `add_stat_exp("strength", 10)` instead of needing six separate functions

---

### 5. Reset Functions

```gdscript
# Reset all stats to starting values (level 1, 0 XP)
func reset_stats() -> void:
	# Reset stat levels
	strength = 1
	dexterity = 1
	constitution = 1
	intelligence = 1
	wisdom = 1
	charisma = 1

	# Reset XP accumulation
	strength_exp = 0.0
	dexterity_exp = 0.0
	constitution_exp = 0.0
	intelligence_exp = 0.0
	wisdom_exp = 0.0
	charisma_exp = 0.0
```

**Usage**: Complete save reset, new game initialization

**Note**: Stats do NOT reset on prestige - they are permanent progression

---

### 6. Save/Load Integration

**Save Function Updates** (in LocalSaveManager and NakamaManager):

```gdscript
# Add to save_data dictionary
save_data["strength"] = Global.strength
save_data["dexterity"] = Global.dexterity
save_data["constitution"] = Global.constitution
save_data["intelligence"] = Global.intelligence
save_data["wisdom"] = Global.wisdom
save_data["charisma"] = Global.charisma

save_data["strength_exp"] = Global.strength_exp
save_data["dexterity_exp"] = Global.dexterity_exp
save_data["constitution_exp"] = Global.constitution_exp
save_data["intelligence_exp"] = Global.intelligence_exp
save_data["wisdom_exp"] = Global.wisdom_exp
save_data["charisma_exp"] = Global.charisma_exp
```

**Load Function Updates**:

```gdscript
# Load with defaults
Global.strength = save_data.get("strength", 1)
Global.dexterity = save_data.get("dexterity", 1)
Global.constitution = save_data.get("constitution", 1)
Global.intelligence = save_data.get("intelligence", 1)
Global.wisdom = save_data.get("wisdom", 1)
Global.charisma = save_data.get("charisma", 1)

Global.strength_exp = save_data.get("strength_exp", 0.0)
Global.dexterity_exp = save_data.get("dexterity_exp", 0.0)
Global.constitution_exp = save_data.get("constitution_exp", 0.0)
Global.intelligence_exp = save_data.get("intelligence_exp", 0.0)
Global.wisdom_exp = save_data.get("wisdom_exp", 0.0)
Global.charisma_exp = save_data.get("charisma_exp", 0.0)
```

**Implementation Details**:
- All 12 values (6 stats + 6 XP vars) saved
- Defaults provided for missing values (backward compatibility)
- Works with both local and cloud saves
- No special serialization needed (basic types)

---

## Testing Strategy

### Unit Tests

Create `tests/test_stats_and_experience.gd`:

```gdscript
extends GutTest

func before_each():
	# Reset stats before each test
	Global.reset_stats()

# Test: XP calculation formula
func test_xp_calculation():
	assert_eq(Global.get_xp_for_level(1), 0.0, "Level 1 needs 0 XP")
	assert_eq(Global.get_xp_for_level(2), 100.0, "Level 2 needs 100 XP")
	assert_almost_eq(Global.get_xp_for_level(3), 349.0, 1.0, "Level 3 needs ~349 XP")
	assert_almost_eq(Global.get_xp_for_level(4), 721.0, 1.0, "Level 4 needs ~721 XP")

# Test: Single level-up
func test_single_level_up():
	Global.add_stat_exp("strength", 100.0)
	assert_eq(Global.strength, 2, "Strength leveled up to 2")
	assert_eq(Global.strength_exp, 100.0, "XP accumulated to 100")

# Test: Multiple level-ups at once
func test_multiple_level_ups():
	# Add enough XP to reach level 3+ (total 450+ XP)
	Global.add_stat_exp("dexterity", 500.0)
	assert_gte(Global.dexterity, 3, "Dexterity jumped multiple levels")
	assert_eq(Global.dexterity_exp, 500.0, "XP accumulated to 500")

# Test: Level progress calculation
func test_level_progress():
	# Add half the XP needed for level 2
	Global.add_stat_exp("wisdom", 50.0)
	var progress = Global.get_stat_level_progress("wisdom")
	assert_almost_eq(progress, 0.5, 0.01, "Progress is ~50%")

# Test: Fractional XP accumulation
func test_fractional_xp():
	Global.add_stat_exp("strength", 0.4)
	Global.add_stat_exp("strength", 0.3)
	Global.add_stat_exp("strength", 0.3)
	assert_almost_eq(Global.strength_exp, 1.0, 0.01, "Fractional XP sums correctly")

# Test: Invalid stat name
func test_invalid_stat_name():
	# Should not crash, should log error
	Global.add_stat_exp("invalid_stat", 100.0)
	# No assertion - just verify no crash

# Test: Negative XP rejected
func test_negative_xp():
	Global.add_stat_exp("charisma", -50.0)
	assert_eq(Global.charisma_exp, 0.0, "Negative XP rejected")

# Test: Cross-stat independence
func test_stat_independence():
	Global.add_stat_exp("strength", 100.0)
	assert_eq(Global.strength, 2, "Strength increased")
	assert_eq(Global.dexterity, 1, "Dexterity unchanged")
	assert_eq(Global.dexterity_exp, 0.0, "Dexterity XP unchanged")

# Test: Reset functionality
func test_reset_stats():
	Global.add_stat_exp("intelligence", 500.0)
	Global.reset_stats()
	assert_eq(Global.intelligence, 1, "Intelligence reset to 1")
	assert_eq(Global.intelligence_exp, 0.0, "Intelligence XP reset to 0")

# Test: Save/load round-trip
func test_save_load():
	# Set some values
	Global.add_stat_exp("constitution", 150.0)
	var saved_level = Global.constitution
	var saved_exp = Global.constitution_exp

	# Simulate save
	var save_data = {
		"constitution": Global.constitution,
		"constitution_exp": Global.constitution_exp
	}

	# Reset
	Global.reset_stats()

	# Simulate load
	Global.constitution = save_data.get("constitution", 1)
	Global.constitution_exp = save_data.get("constitution_exp", 0.0)

	# Verify restoration
	assert_eq(Global.constitution, saved_level, "Level restored")
	assert_eq(Global.constitution_exp, saved_exp, "XP restored")
```

**Run tests:**
```bash
godot --headless --script res://addons/gut/gut_cmdln.gd -gtest=tests/test_stats_and_experience.gd
```

### Integration Tests

| Scenario | Setup | Action | Expected Result |
|----------|-------|--------|-----------------|
| Level-up notification | strength=1, 0 XP | Add 100 XP | "You feel stronger" shown, strength=2 |
| Progress tracking | dex=1, 50/100 XP | Check progress | Returns 0.5 (50%) |
| Cross-stat independence | STR=5, DEX=1 | Add 100 STR XP | DEX unchanged |
| Fractional XP | str_exp=0.0 | Add 0.4 XP 3 times | str_exp=1.2 |
| Multi-level jump | wis=1, 0 XP | Add 1000 XP | wis>=3, notification shown multiple times |

### Manual Test Criteria

- [ ] Start new game, verify all stats = 1, all XP = 0.0
- [ ] Award XP via console: `Global.add_stat_exp("strength", 100)`
- [ ] Verify notification appears: "You feel stronger"
- [ ] Check stat increased to level 2
- [ ] Test each stat's notification message
- [ ] Add large XP amount (1000+), verify multiple notifications
- [ ] Save game, exit, reload, verify stats and XP persist
- [ ] Verify `reset_stats()` returns everything to defaults

---

## Files to Modify

**global.gd** (~100 lines added/modified)
- Six stat variables with notification setters
- Six XP tracking variables
- XP curve constants (BASE_XP_FOR_LEVEL, EXP_SCALING)
- Core API functions (add_stat_exp, get_stat_level_progress, get_xp_for_level)
- Helper functions (_check_level_up, _get_stat_data)
- reset_stats() function

**local_save_manager.gd** (~25 lines modified)
- Add 12 fields to save_data dictionary (6 stats + 6 XP vars)
- Add 12 fields to load_data logic with defaults

**nakama_client.gd** (~25 lines modified)
- Add 12 fields to cloud save data structure
- Add 12 fields to cloud load logic with defaults

**tests/test_stats_and_experience.gd** (~150 lines new)
- 10 unit tests covering all core functionality
- Test runner setup

---

## Design Values (Reference)

### Leveling Curve

**Formula**: `XP = 100 * (level - 1)^1.8`

**Tuning Constants**:
- **BASE_XP_FOR_LEVEL**: 100.0 - Controls overall leveling speed
- **EXP_SCALING**: 1.8 - Controls curve steepness

**Curve Characteristics**:
- Gentle early progression (level 2-3 achievable quickly)
- Meaningful mid-game (levels 5-10 feel earned)
- Long-term goals (level 20+ requires dedication)

**Tuning Guidance**:
- If leveling too fast: Increase BASE_XP (affects all levels proportionally)
- If late-game too grindy: Decrease EXP_SCALING (flattens curve)
- If early-game too slow: Decrease BASE_XP (faster early levels)

**Progression Estimates** (placeholder - actual pacing in Phase 2.9):
- Level 1→2: Early game (tutorial phase)
- Level 2→5: Mid-game (core loop mastery)
- Level 5→10: Late-game (optimization phase)
- Level 10+: Prestige cycles, long-term goals

### Notification Messages

Simple, consistent flavor text per stat:
- **Strength**: "You feel stronger"
- **Dexterity**: "You feel more precise"
- **Constitution**: "You feel more resilient"
- **Intelligence**: "You feel smarter"
- **Wisdom**: "You feel more introspective"
- **Charisma**: "You understand people better"

**Rationale**: Clear, concise, thematic. No need for variety at this stage.

---

## Dependencies & Integration

### Depends On:
- Phase 1.3 (Global Autoload) - Global.gd exists
- Notification system - Global.show_stat_notification() works

### Used By:
- **All gameplay features** - Furnace, shop, dream, social interactions
- **Phase 2.9** (Stat Progression Mechanics) - Defines XP award patterns
- **Future UI** - Stat screens, character sheets, progress bars
- **Save/Load** - Persistence systems

### Provides APIs For:

**Gameplay Features**:
```gdscript
Global.add_stat_exp(stat_name, amount)  # Award XP from actions
```

**UI Systems** (future):
```gdscript
Global.get_stat_level_progress(stat_name)  # Progress bars
Global.strength  # Display current level
```

**Balance/Design**:
```gdscript
Global.get_xp_for_level(level)  # Calculate thresholds for planning
```

---


## Notes & Decisions

**Decision 1**: Integer stats, float XP
- **Rationale**: Whole levels feel discrete and meaningful; fractional XP allows smooth accumulation
- **Benefit**: Clean level-up moments, but granular XP rewards (0.4 XP per action is fine)

**Decision 2**: Same curve for all stats
- **Rationale**: Simpler to balance, no "easy" or "hard" stats
- **Benefit**: Players choose specialization based on preference, not efficiency
- **Alternative considered**: Different curves per stat (rejected - unnecessary complexity)

**Decision 3**: Stat setters with notifications
- **Rationale**: Automatic feedback on level-up, no manual notification code needed
- **Implementation**: Setter compares old vs new, triggers notification on increase
- **Guard**: `is_node_ready()` prevents notifications during load/init

**Decision 4**: No stat caps
- **Rationale**: Unlimited progression feels better for idle/incremental mechanics
- **Benefit**: Always something to work toward
- **Future**: Phase-specific caps could be added separately if needed

**Decision 5**: No reset/respec
- **Rationale**: Stats are permanent progression, not build choices
- **Benefit**: Simpler system, emphasizes long-term growth
- **Note**: This differs from spendable currencies - stats never decrease

**Decision 6**: Per-stat XP pools
- **Rationale**: Different actions develop different stats
- **Benefit**: Emergent specialization, varied progression paths
- **Alternative**: Single XP pool with allocation (rejected - less organic)

**Decision 7**: Backend only (no UI this phase)
- **Rationale**: Core mechanics first, presentation later
- **Benefit**: Can implement and test without UI dependencies
- **Future**: Stat screen UI in separate plan

---

## Implementation Checklist

Before marking Phase 1.8 complete:

- [ ] Six stat variables defined in global.gd with setters
- [ ] Six XP variables defined in global.gd
- [ ] BASE_XP_FOR_LEVEL and EXP_SCALING constants defined
- [ ] get_xp_for_level() function implemented
- [ ] add_stat_exp() function implemented
- [ ] _check_level_up() function implemented
- [ ] get_stat_level_progress() function implemented
- [ ] _get_stat_data() helper function implemented
- [ ] reset_stats() function implemented
- [ ] Notification system integration verified (simple messages)
- [ ] Save/load functions updated (LocalSaveManager)
- [ ] Save/load functions updated (NakamaManager)
- [ ] Unit tests written and passing (10 tests minimum)
- [ ] Integration tests completed
- [ ] Manual tests verified (all stats, notifications, save/load)
- [ ] Code reviewed for clarity and maintainability
- [ ] Documentation updated (game-systems.md cross-references if needed)

---

**Last Updated**: 2025-11-30
**Maintainer**: Claude + User collaboration
**Plan Version**: 1.0 (Complete rewrite - combined stats + experience)
