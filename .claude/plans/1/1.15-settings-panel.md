# Settings Button & Panel

**Goal**: Create settings button in menu and settings panel in play area with UI scale, audio volume, dev speed mode, and save reset

**Success Criteria**:
- Settings button appears in menu (right side) of every scene
- Clicking settings shows panel overlaying entire screen
- Panel contains: UI Scale slider, Music Volume slider, SFX Volume slider, Dev Speed Mode toggle, Save Reset button
- X button in corner closes panel
- Escape key closes panel
- Panel closes automatically on scene change
- Settings auto-save on change (combined with game progress in save.json)

**Prerequisites**:
- Phase 1.13 (Scene Template) - Scene template with Menu and PlayArea
- Phase 1.14 (Button Hierarchy) - Settings button sorted to bottom
- Phase 1.12 (UI Scale Slider) - UI scale system exists
- AudioManager autoload exists with set_music_volume() and set_sfx_volume() methods

---

## Overview

Adds a Settings button to every scene's menu that opens a settings panel overlaying the entire screen. Panel includes all player preferences (UI scale, audio volumes, dev mode) and game management (save reset). Uses structured save system where settings and game progress are separated into distinct sections within save.json. Reset operations preserve the settings section while clearing the game section.

### Key Design Principles

- **Always accessible**: Settings button in every scene's menu
- **Full-screen overlay**: Uses CanvasLayer to overlay entire screen, blocks all input
- **Close methods**: X button, Escape key
- **Auto-save**: Settings save immediately on change
- **Structured save**: Settings and game data separated in save.json for clean reset logic
- **Surgical reset**: reset_save() preserves settings section, clears game section
- **Auto-close on scene change**: Panel detects scene changes and closes automatically

---

## Implementation Tasks

### 1. Create Settings Panel Scene

**File**: `res://settings_panel.tscn`

**Structure**:
```
SettingsPanel (CanvasLayer)
└── PanelContainer
    └── MarginContainer
        └── VBoxContainer
            ├── HeaderHBox
            │   ├── TitleLabel ("Settings")
            │   └── CloseButton ("X")
            ├── UIScaleContainer (HBoxContainer)
            │   ├── Label ("UI Scale:")
            │   ├── UIScaleSlider (HSlider, 0.8-1.2, step 0.05)
            │   └── UIScaleValueLabel ("100%")
            ├── MusicVolumeContainer (HBoxContainer)
            │   ├── Label ("Music Volume:")
            │   ├── MusicVolumeSlider (HSlider, 0-100)
            │   └── MusicVolumeValueLabel ("80%")
            ├── SFXVolumeContainer (HBoxContainer)
            │   ├── Label ("SFX Volume:")
            │   ├── SFXVolumeSlider (HSlider, 0-100)
            │   └── SFXVolumeValueLabel ("80%")
            ├── DevSpeedContainer (HBoxContainer)
            │   ├── Label ("Dev Speed Mode:")
            │   └── DevSpeedCheckBox (CheckBox)
            ├── HSeparator
            └── SaveResetButton (Button, "Reset Save")
```

**PanelContainer properties**:
- Anchors: Full rect (0,0,1,1)
- Custom minimum size: 400x300
- Layout: Center container with margins
- Background: Semi-transparent dark panel (use theme override)

**CanvasLayer properties**:
- Layer: 100 (ensures it's above all gameplay)
- Follow viewport: Enabled

### 2. Settings Panel Script

**File**: `res://settings_panel.gd`

```gdscript
extends CanvasLayer

signal panel_closed

const UI_SCALE_MIN = 0.8
const UI_SCALE_MAX = 1.2
const VOLUME_MIN = 0
const VOLUME_MAX = 100

@onready var close_button = $PanelContainer/MarginContainer/VBoxContainer/HeaderHBox/CloseButton
@onready var ui_scale_slider = $PanelContainer/MarginContainer/VBoxContainer/UIScaleContainer/UIScaleSlider
@onready var ui_scale_value = $PanelContainer/MarginContainer/VBoxContainer/UIScaleContainer/UIScaleValueLabel
@onready var music_slider = $PanelContainer/MarginContainer/VBoxContainer/MusicVolumeContainer/MusicVolumeSlider
@onready var music_value = $PanelContainer/MarginContainer/VBoxContainer/MusicVolumeContainer/MusicVolumeValueLabel
@onready var sfx_slider = $PanelContainer/MarginContainer/VBoxContainer/SFXVolumeContainer/SFXVolumeSlider
@onready var sfx_value = $PanelContainer/MarginContainer/VBoxContainer/SFXVolumeContainer/SFXVolumeValueLabel
@onready var dev_speed_checkbox = $PanelContainer/MarginContainer/VBoxContainer/DevSpeedContainer/DevSpeedCheckBox
@onready var save_reset_button = $PanelContainer/MarginContainer/VBoxContainer/SaveResetButton

var current_scene_path: String = ""

func _ready():
    # Track current scene to detect changes
    current_scene_path = get_tree().current_scene.scene_file_path

    # Load and validate current settings
    ui_scale_slider.value = clampf(Global.ui_scale, UI_SCALE_MIN, UI_SCALE_MAX)
    music_slider.value = clampf(Global.music_volume * 100, VOLUME_MIN, VOLUME_MAX)
    sfx_slider.value = clampf(Global.sfx_volume * 100, VOLUME_MIN, VOLUME_MAX)
    dev_speed_checkbox.button_pressed = Global.dev_speed_mode

    update_value_labels()

    # Connect signals
    close_button.pressed.connect(_close_panel)
    ui_scale_slider.value_changed.connect(_on_ui_scale_changed)
    music_slider.value_changed.connect(_on_music_volume_changed)
    sfx_slider.value_changed.connect(_on_sfx_volume_changed)
    dev_speed_checkbox.toggled.connect(_on_dev_speed_toggled)
    save_reset_button.pressed.connect(_on_save_reset_pressed)

func _process(_delta):
    # Auto-close if scene changed
    if get_tree().current_scene.scene_file_path != current_scene_path:
        _close_panel()

func _input(event):
    if event.is_action_pressed("ui_cancel"):  # Escape key
        _close_panel()
        get_viewport().set_input_as_handled()

func _close_panel():
    panel_closed.emit()
    queue_free()

func _on_ui_scale_changed(value: float):
    var clamped_value = clampf(value, UI_SCALE_MIN, UI_SCALE_MAX)
    Global.ui_scale = clamped_value
    update_value_labels()
    Global.save()

    # Apply to current scene if ResponsiveLayout exists
    if is_instance_valid(ResponsiveLayout):
        ResponsiveLayout.apply_to_scene(get_tree().current_scene)

func _on_music_volume_changed(value: float):
    var clamped_value = clampf(value, VOLUME_MIN, VOLUME_MAX)
    Global.music_volume = clamped_value / 100.0
    update_value_labels()
    Global.save()

    # Apply audio change if AudioManager exists
    if is_instance_valid(AudioManager):
        AudioManager.set_music_volume(Global.music_volume)

func _on_sfx_volume_changed(value: float):
    var clamped_value = clampf(value, VOLUME_MIN, VOLUME_MAX)
    Global.sfx_volume = clamped_value / 100.0
    update_value_labels()
    Global.save()

    # Apply audio change if AudioManager exists
    if is_instance_valid(AudioManager):
        AudioManager.set_sfx_volume(Global.sfx_volume)

func _on_dev_speed_toggled(pressed: bool):
    Global.dev_speed_mode = pressed
    Global.save()

func _on_save_reset_pressed():
    # Confirmation dialog
    var confirm = ConfirmationDialog.new()
    confirm.dialog_text = "Reset all game progress? Settings will be preserved."
    confirm.confirmed.connect(_perform_save_reset)
    add_child(confirm)
    confirm.popup_centered()

func _perform_save_reset():
    Global.reset_save()
    _close_panel()

func update_value_labels():
    ui_scale_value.text = "%d%%" % int(Global.ui_scale * 100)
    music_value.text = "%d%%" % int(Global.music_volume * 100)
    sfx_value.text = "%d%%" % int(Global.sfx_volume * 100)
```

### 3. Add Settings Button to Scene Template

**Modify**: `res://level1/scene_template.tscn`

Add settings button to Menu container:
```
[node name="SettingsButton" type="Button" parent="MainLayout/Menu"]
layout_mode = 2
text = "Settings"
```

**Note**: ButtonHierarchy will automatically sort this to bottom (ButtonType.SETTINGS)

### 4. Settings Button Handler (in scene_template)

**Add script to scene_template**: `res://level1/scene_template.gd`

```gdscript
extends Control

@onready var settings_button = $MainLayout/Menu/SettingsButton

var settings_panel_instance: CanvasLayer = null

func _ready():
    ResponsiveLayout.apply_to_scene(self)

    # Connect settings button (works for all inherited scenes)
    if settings_button:
        settings_button.pressed.connect(_on_settings_pressed)

func _on_settings_pressed():
    # Prevent multiple panels
    if is_instance_valid(settings_panel_instance):
        return  # Already open

    # Create settings panel
    var settings_scene = load("res://settings_panel.tscn")
    settings_panel_instance = settings_scene.instantiate()
    settings_panel_instance.panel_closed.connect(_on_settings_closed)

    # Add to scene tree (CanvasLayer handles overlay automatically)
    add_child(settings_panel_instance)

func _on_settings_closed():
    settings_panel_instance = null
```

**Benefits**:
- Works automatically for all scenes inheriting from scene_template
- No per-scene code needed
- Local tracking prevents duplicate panels (no Global pollution)
- CanvasLayer naturally overlays and blocks input - no visibility toggling needed

### 5. Structured Save System in Global

**Modify**: `res://global.gd`

```gdscript
extends Node

# Structured save data (settings/game separation for clean reset logic)
var save_data = {
    "settings": {
        "ui_scale": 1.0,
        "music_volume": 0.8,
        "sfx_volume": 0.8,
        "dev_speed_mode": false,
    },
    "game": {
        "copper_current": 0,
        "copper_lifetime": 0,
        "strength": 1,
        "dexterity": 1,
        "constitution": 1,
        "intelligence": 1,
        "wisdom": 1,
        "charisma": 1,
        # ... other game vars
    }
}

# Convenience accessors for settings (use like: Global.ui_scale = 1.2)
var ui_scale: float:
    get: return save_data.settings.ui_scale
    set(value): save_data.settings.ui_scale = clampf(value, 0.8, 1.2)

var music_volume: float:
    get: return save_data.settings.music_volume
    set(value): save_data.settings.music_volume = clampf(value, 0.0, 1.0)

var sfx_volume: float:
    get: return save_data.settings.sfx_volume
    set(value): save_data.settings.sfx_volume = clampf(value, 0.0, 1.0)

var dev_speed_mode: bool:
    get: return save_data.settings.dev_speed_mode
    set(value): save_data.settings.dev_speed_mode = value

# Convenience accessors for game data
var copper_current: int:
    get: return save_data.game.copper_current
    set(value): save_data.game.copper_current = maxi(value, 0)

# ... add getters/setters for other game fields

const SAVE_FILE_PATH = "user://save.json"

func _ready():
    load_save()

func save():
    """
    Save all settings and game progress.
    Called automatically on setting changes and after technique/upgrade selections.
    """
    var file = FileAccess.open(SAVE_FILE_PATH, FileAccess.WRITE)
    if not file:
        push_error("Failed to open save file for writing: " + SAVE_FILE_PATH)
        return

    var json_string = JSON.stringify(save_data, "\t")
    file.store_string(json_string)
    file.close()

func load_save():
    """Load settings and game progress"""
    if not FileAccess.file_exists(SAVE_FILE_PATH):
        return  # Use defaults

    var file = FileAccess.open(SAVE_FILE_PATH, FileAccess.READ)
    if not file:
        push_error("Failed to open save file for reading: " + SAVE_FILE_PATH)
        return

    var json_text = file.get_as_text()
    file.close()

    var json = JSON.new()
    var parse_result = json.parse(json_text)

    if parse_result != OK:
        push_error("Failed to parse save file JSON at line " + str(json.get_error_line()) + ": " + json.get_error_message())
        return

    var loaded_data = json.data
    if typeof(loaded_data) != TYPE_DICTIONARY:
        push_error("Save file does not contain a dictionary")
        return

    # Merge loaded settings with defaults (handles new fields gracefully)
    if loaded_data.has("settings") and typeof(loaded_data.settings) == TYPE_DICTIONARY:
        for key in loaded_data.settings:
            if save_data.settings.has(key):
                save_data.settings[key] = loaded_data.settings[key]

    # Merge loaded game data with defaults
    if loaded_data.has("game") and typeof(loaded_data.game) == TYPE_DICTIONARY:
        for key in loaded_data.game:
            if save_data.game.has(key):
                save_data.game[key] = loaded_data.game[key]

func reset_save():
    """Reset game progress, preserve settings (called from settings panel)"""
    # Preserve settings, get fresh game defaults
    var settings_backup = save_data.settings.duplicate(true)

    # Reconstruct save_data with default game data
    save_data.settings = settings_backup
    save_data.game = get_default_game_data()

    save()
    get_tree().reload_current_scene()

func get_default_game_data() -> Dictionary:
    """Returns default game data structure (used by reset_save and prestige)"""
    return {
        "copper_current": 0,
        "copper_lifetime": 0,
        "strength": 1,
        "dexterity": 1,
        "constitution": 1,
        "intelligence": 1,
        "wisdom": 1,
        "charisma": 1,
        # ... etc
    }
```

**Save triggers**:
- Settings sliders/toggles changed → `Global.save()`
- Technique selected (Phase 2.3) → `Global.save()`
- Upgrade purchased → `Global.save()`
- Major game events → `Global.save()`

**Benefits of structured approach**:
- Settings and game data cleanly separated
- `reset_save()` simply replaces `game` section, preserves `settings` section
- Adding new settings/game vars only requires updating one location (the defaults dict)
- Validation in setters prevents corruption
- Error handling prevents crashes from corrupted saves

---

## Testing

**Settings Button:**
- [ ] Settings button appears in every scene's menu
- [ ] Settings button is at bottom of menu (after nav buttons)
- [ ] Clicking button opens settings panel

**Settings Panel:**
- [ ] Panel fills entire PlayArea
- [ ] Panel has semi-transparent dark background
- [ ] All sliders and controls visible and labeled
- [ ] Panel appears above gameplay content

**UI Scale:**
- [ ] Slider shows current UI scale (default 100%)
- [ ] Moving slider changes UI scale immediately
- [ ] Value label updates (80%-120%)
- [ ] Changes persist after closing panel

**Audio Volume:**
- [ ] Music slider shows current volume (default 80%)
- [ ] SFX slider shows current volume (default 80%)
- [ ] Moving sliders changes volume immediately
- [ ] Value labels update (0%-100%)
- [ ] Volume changes audible in real-time

**Dev Speed Mode:**
- [ ] Checkbox shows current state (default off)
- [ ] Toggling checkbox changes Global.dev_speed_mode
- [ ] State persists after closing panel

**Save Reset:**
- [ ] Button shows confirmation dialog
- [ ] Confirming resets game progress
- [ ] Settings preserved after reset (UI scale, volumes, dev mode)
- [ ] Scene reloads after reset

**Close Methods:**
- [ ] X button closes panel
- [ ] Escape key closes panel
- [ ] Panel closes automatically when scene changes
- [ ] Panel properly removed from scene tree

**Persistence:**
- [ ] Change settings, close panel, reopen - settings match
- [ ] Change settings, restart game - settings persist
- [ ] Reset save - settings persist, game progress reset

---

## Files to Create

- `res://settings_panel.tscn` - Settings panel UI
- `res://settings_panel.gd` - Settings panel script
- `res://level1/scene_template.gd` - Settings button handler script

## Files to Modify

- `res://level1/scene_template.tscn` - Add SettingsButton to Menu, attach scene_template.gd script
- `res://global.gd` - Add structured save_data (settings/game), save(), load_save(), reset_save(), get_default_game_data()

---

## Design Values

### Settings Panel Sizing

- **CanvasLayer**: Layer 100 (above gameplay)
- **PanelContainer**: Full screen anchors (0,0,1,1)
- **Content margins**: 50px all sides
- **Minimum size**: 400x300

### Slider Ranges

| Setting | Min | Max | Default | Step |
|---------|-----|-----|---------|------|
| UI Scale | 0.8 | 1.2 | 1.0 | 0.05 |
| Music Volume | 0 | 100 | 80 | 1 |
| SFX Volume | 0 | 100 | 80 | 1 |

### Save Structure

```json
{
    "settings": {
        "ui_scale": 1.0,
        "music_volume": 0.8,
        "sfx_volume": 0.8,
        "dev_speed_mode": false
    },
    "game": {
        "copper_current": 150,
        "strength": 5
    }
}
```

**settings section**: Preserved during prestige/reset
**game section**: Reset by prestige, cleared by save reset

---

## Notes

**Decision**: Structured save with settings/game sections
- **Rationale**: Clean separation prevents accidental settings loss during resets
- **Benefit**: reset_save() is simple - duplicate settings, replace game section
- **Maintainability**: Adding new settings/game vars only requires updating default dicts
- **Validation**: Getters/setters clamp values to valid ranges, preventing corruption
- **Error handling**: All file operations check for failures and log errors
- **Cloud compatibility**: This save_data structure applies to both local saves (FileAccess) and cloud saves (Nakama). When using cloud saves, save()/load_save() are replaced with NakamaClient.save_game()/load_game() calls (see 1.x-nakama-server.md), but data structure and settings preservation remain the same.

**Decision**: CanvasLayer for settings panel
- **Rationale**: Natural full-screen overlay, blocks all input automatically
- **Benefit**: No manual visibility toggling, no z-index issues, clean implementation
- **Implementation**: CanvasLayer layer 100 ensures it's above all gameplay
- **Auto-close**: Detects scene changes via _process() and closes automatically

**Decision**: Local panel tracking in scene_template
- **Rationale**: Avoids polluting Global autoload with UI state
- **Implementation**: `settings_panel_instance` variable in scene_template.gd
- **Benefit**: Prevents duplicate panels, keeps data/UI separation clean

**Decision**: Two close methods (X button, Escape)
- **Rationale**: Cover both mouse and keyboard users
- **Removed**: Click-outside-to-close (complex, error-prone, not essential)
- **Added**: Auto-close on scene change (prevents orphaned panels)

**Decision**: Settings button in scene_template
- **Rationale**: Universal access from every scene, zero per-scene code
- **Implementation**: scene_template.gd handles button connection automatically
- **ButtonHierarchy**: Automatically sorts to bottom (priority 100)
- **Consistency**: Works identically in all inherited scenes

**Decision**: Auto-save on change
- **Rationale**: No save button needed, changes persist immediately
- **Implementation**: Each slider/toggle change calls Global.save()
- **Trade-off**: Slightly more disk writes (negligible for small JSON)

**Decision**: Confirmation for save reset
- **Rationale**: Destructive action, prevent accidents
- **Implementation**: ConfirmationDialog built into Godot
- **Message**: Clear about what's reset vs preserved

---

**Last Updated**: 2025-12-09
**Maintainer**: Claude + User collaboration
