# Simple Logging System Plan

## Overview
Session-based logging system that writes errors and events to disk. No UI, no cloud sync - just reliable local logging for debugging.

## Core Goals
1. Session-based logs with automatic rotation
2. Configurable log levels (development vs production)
3. Memory buffer for recent logs (used by bug reporting later)
4. Crash-resistant (immediate flush, no batching)
5. Bounded disk usage with size limits

---

## Part 1: Core Logger (DebugLogger Autoload)

### What It Does
- Creates new log file per session with unique session ID
- Rotates old logs by modification time (keeps last 10)
- Flushes immediately (no batch delays that lose data on crash)
- Buffers recent logs in memory for later bug reporting
- Writes filtered logs to disk based on level
- Caps individual log file size to prevent runaway logging

### Log Levels
```gdscript
enum LogLevel {
	DEBUG = 0,  # Detailed traces (memory only by default)
	INFO = 1,   # Normal events (scene changes, purchases)
	WARN = 2,   # Suspicious states (negative currency)
	ERROR = 3   # Critical failures (save failures, null refs)
}
```

### File: debug_logger.gd (Autoload)

```gdscript
extends Node

# Log levels enum
enum LogLevel {
	DEBUG = 0,
	INFO = 1,
	WARN = 2,
	ERROR = 3
}

# Configuration
var disk_log_level: int = LogLevel.INFO
var enable_logging: bool = true
var log_directory: String = "user://logs/"
var current_log_file: String = ""
var session_id: String = ""

# File management
var log_file: FileAccess = null
var current_log_size: int = 0
const MAX_LOG_FILE_SIZE: int = 5 * 1024 * 1024  # 5MB per session
const MAX_TOTAL_LOG_SIZE: int = 50 * 1024 * 1024  # 50MB total
const MAX_LOG_FILES: int = 10

# Memory buffer for bug reports (always captures everything)
var recent_logs: Array[Dictionary] = []
const MAX_RECENT_LOGS: int = 300

# Level names for formatting
const LEVEL_NAMES = ["DEBUG", "INFO", "WARN", "ERROR"]

func _ready():
	if enable_logging:
		_load_settings()
		_setup_log_directory()
		_rotate_old_logs()
		_open_new_session_log()

func _exit_tree():
	_close_log_file()

func _load_settings():
	# Load from project settings if available
	disk_log_level = ProjectSettings.get_setting("debug/disk_log_level", LogLevel.INFO)
	enable_logging = ProjectSettings.get_setting("debug/enable_logging", true)

func _setup_log_directory():
	var dir = DirAccess.open("user://")
	if not dir:
		push_error("Failed to access user:// directory")
		enable_logging = false
		return

	if not dir.dir_exists("logs"):
		var err = dir.make_dir("logs")
		if err != OK:
			push_error("Failed to create logs directory: " + str(err))
			enable_logging = false

func _open_new_session_log():
	# Generate unique session ID
	session_id = _generate_session_id()

	# Create session log file: goa_2025-12-09_14-30-45_abc123.log
	var datetime = Time.get_datetime_dict_from_system()
	current_log_file = log_directory + "goa_%04d-%02d-%02d_%02d-%02d-%02d_%s.log" % [
		datetime.year, datetime.month, datetime.day,
		datetime.hour, datetime.minute, datetime.second,
		session_id
	]

	log_file = FileAccess.open(current_log_file, FileAccess.WRITE)
	if not log_file:
		push_error("Failed to create log file: " + current_log_file)
		enable_logging = false
		return

	current_log_size = 0

	# Write header
	var separator = "=".repeat(60)
	var header = [
		separator,
		"GoA Debug Log - Session Started",
		"Session ID: " + session_id,
		"Time: " + Time.get_datetime_string_from_system(),
		"Platform: " + OS.get_name(),
		"OS Version: " + OS.get_version(),
		"Godot Version: " + Engine.get_version_info().string,
		"Disk Log Level: " + LEVEL_NAMES[disk_log_level],
		separator
	]

	for line in header:
		log_file.store_line(line)
		current_log_size += line.length() + 1

	log_file.flush()

func _close_log_file():
	if log_file:
		var separator = "=".repeat(60)
		log_file.store_line(separator)
		log_file.store_line("Session Ended: " + Time.get_datetime_string_from_system())
		log_file.store_line(separator)
		log_file.flush()
		log_file.close()
		log_file = null

func _generate_session_id() -> String:
	# Generate short unique ID: 6 random hex chars
	var chars = "0123456789abcdef"
	var result = ""
	for i in range(6):
		result += chars[randi() % chars.length()]
	return result

func _rotate_old_logs():
	var dir = DirAccess.open(log_directory)
	if not dir:
		return

	# Collect all log files with metadata
	var log_files: Array[Dictionary] = []
	dir.list_dir_begin()
	var file_name = dir.get_next()

	while file_name != "":
		if file_name.begins_with("goa_") and file_name.ends_with(".log"):
			var file_path = log_directory + file_name
			var mod_time = FileAccess.get_modified_time(file_path)
			var file_size = FileAccess.open(file_path, FileAccess.READ).get_length()

			log_files.append({
				"name": file_name,
				"path": file_path,
				"modified": mod_time,
				"size": file_size
			})
		file_name = dir.get_next()

	dir.list_dir_end()

	# Sort by modification time (oldest first)
	log_files.sort_custom(func(a, b): return a.modified < b.modified)

	# Calculate total size
	var total_size = 0
	for log_entry in log_files:
		total_size += log_entry.size

	# Delete oldest logs if over total size limit OR over max file count
	while log_files.size() >= MAX_LOG_FILES or total_size > MAX_TOTAL_LOG_SIZE:
		if log_files.is_empty():
			break

		var oldest = log_files.pop_front()
		dir.remove(oldest.name)
		total_size -= oldest.size
		print("Deleted old log file: " + oldest.name + " (size: " + str(oldest.size) + ")")

# Main logging function
func write_log(message: String, level: int = LogLevel.INFO, category: String = "GENERAL"):
	if not enable_logging:
		return

	# Clamp level to valid range
	level = clampi(level, LogLevel.DEBUG, LogLevel.ERROR)

	var level_name = LEVEL_NAMES[level]
	var timestamp = Time.get_datetime_string_from_system()
	var formatted = "[%s] [%s] [%s] %s" % [timestamp, level_name, category, message]

	# Always add to memory buffer (for bug reports in 1.22-advanced-logging)
	recent_logs.append({
		"session_id": session_id,
		"timestamp": timestamp,
		"level": level_name,
		"category": category,
		"message": message,
		"formatted": formatted
	})

	# Trim buffer if too large
	if recent_logs.size() > MAX_RECENT_LOGS:
		recent_logs.pop_front()

	# Write to disk if level is high enough
	if level >= disk_log_level and log_file:
		# Check if we've exceeded max file size
		if current_log_size >= MAX_LOG_FILE_SIZE:
			log_file.store_line("[LOG SIZE LIMIT REACHED - STOPPING SESSION LOG]")
			log_file.flush()
			# Don't close file, just stop writing (keeps session open)
			return

		log_file.store_line(formatted)
		current_log_size += formatted.length() + 1
		log_file.flush()  # Immediate flush - survives crashes

	# Also print to console
	if level >= LogLevel.ERROR:
		push_error(message)
	elif level == LogLevel.WARN:
		push_warning(message)

# Convenience functions
func debug(message: String, category: String = "DEBUG"):
	write_log(message, LogLevel.DEBUG, category)

func info(message: String, category: String = "INFO"):
	write_log(message, LogLevel.INFO, category)

func warn(message: String, category: String = "WARN"):
	write_log(message, LogLevel.WARN, category)

func error(message: String, category: String = "ERROR"):
	write_log(message, LogLevel.ERROR, category)

# Get recent logs for bug reports (used by 1.22-advanced-logging)
func get_recent_logs(count: int = 150) -> Array[Dictionary]:
	var start_index = max(0, recent_logs.size() - count)
	return recent_logs.slice(start_index)

# Get errors and warnings only
func get_error_logs(count: int = 50) -> Array[Dictionary]:
	var errors = recent_logs.filter(func(log_entry): return log_entry.level == "ERROR" or log_entry.level == "WARN")
	var start_index = max(0, errors.size() - count)
	return errors.slice(start_index)

# Get current session ID (used by bug reports to correlate with log files)
func get_session_id() -> String:
	return session_id
```

### Add to project.godot Autoload
```ini
[autoload]
DebugLogger="*res://debug_logger.gd"
```

### Optional: Add to project.godot Settings
```ini
[debug]
disk_log_level=1
enable_logging=true
```

---

## Part 2: Integration Points

### When to Log Things

#### Game Startup/Shutdown
```gdscript
# In loading_screen.gd _ready():
DebugLogger.info("Game started - Loading screen displayed", "GAME")

# When scene changes:
DebugLogger.info("Scene changed to: " + scene_name, "SCENE")
```

#### Errors and Warnings
```gdscript
# Critical failures:
if not player_data_loaded:
	DebugLogger.error("Failed to load player data", "SAVE")

# Suspicious states:
if coins < 0:
	DebugLogger.warn("Coins went negative: " + str(coins), "CURRENCY")

# Caught exceptions:
if not resource_loaded:
	DebugLogger.error("Resource load failed: " + path, "RESOURCES")
```

#### Important Game Events
```gdscript
# Player actions:
DebugLogger.info("Player bought shovel upgrade level " + str(level), "SHOP")

# Stat changes:
DebugLogger.info("Strength increased to " + str(strength), "STATS")

# Currency changes:
DebugLogger.info("Copper earned: " + str(amount) + " | Total: " + str(total), "CURRENCY")
```

#### Debug Traces (Development Only)
```gdscript
# Function entry/exit:
DebugLogger.debug("calculate_damage() called with base=" + str(base), "COMBAT")

# State transitions:
DebugLogger.debug("Shop state changed: " + old_state + " -> " + new_state, "SHOP")
```

### Strategic Placement Priority
1. **Global.gd**: Scene changes, stat changes, game state transitions
2. **Shop scenes**: Purchases, currency transactions
3. **Save/Load systems**: Save/load success/failure with details
4. **Currency systems**: All currency operations (especially negative checks)
5. **NakamaClient** (when implemented): Authentication, network errors

---

## Part 3: Implementation Workflow

### Tasks
- [ ] Create debug_logger.gd with session-based logging
- [ ] Add to project.godot autoload
- [ ] Add optional project settings for configuration
- [ ] Test log file creation and session ID
- [ ] Test log rotation (create 15 dummy logs, verify only 10 remain)
- [ ] Test max file size limit (spam logs, verify it stops)
- [ ] Add logging to Global.gd key events
- [ ] Add logging to shop scenes
- [ ] Add logging to save/load systems
- [ ] Test crash survival (kill game mid-session, verify logs exist)

---

## Success Criteria

- [ ] Session log files created with unique session IDs in filename
- [ ] Old logs rotated by modification time (keeps last 10)
- [ ] Individual log files capped at 5MB
- [ ] Total log directory capped at 50MB
- [ ] Immediate flush - logs survive crashes
- [ ] Memory buffer captures all levels for future bug reports
- [ ] Can adjust disk_log_level via project settings
- [ ] No crashes from invalid log levels
- [ ] Log location documented and accessible

---

## Notes

### Development vs Production
- **Development**: Set `disk_log_level = LogLevel.DEBUG` (or 0) to write everything
- **Production**: Set `disk_log_level = LogLevel.WARN` (or 2) to only write warnings/errors

### Performance
- Immediate flushing is used for crash resistance
- If profiling shows performance issues later, can add batching in 1.22-advanced-logging
- DEBUG logs only in memory by default (not written to disk)

### Log File Sizes
- **5MB per session** is roughly:
  - 50,000 log lines at ~100 chars each
  - 30-60 minutes of heavy logging
- **50MB total** keeps ~10 recent sessions
- Prevents runaway disk usage from forgotten debug spam

### Log File Location
Logs stored in `user://logs/` which maps to:
- **Windows**: `%APPDATA%\Godot\app_userdata\GoA\logs\`
- **Linux**: `~/.local/share/godot/app_userdata/GoA/logs/`
- **macOS**: `~/Library/Application Support/Godot/app_userdata/GoA/logs/`

### Session ID Purpose
- 6-character hex ID in filename: `goa_2025-12-09_14-30-45_abc123.log`
- Correlates log files with bug reports in 1.22-advanced-logging
- Makes it easy to find a specific session when debugging issues

---

## Dependencies

**Before This**:
- None (logging is standalone)

**After This**:
- 1.22-advanced-logging.md (bug report UI, uses memory buffer and session ID)
- All future systems should add logging at key points

---

## Files to Create

- `debug_logger.gd` - Core session-based logger autoload

---

## GDScript Common Pitfalls

**CRITICAL - Avoid These Errors:**

### 1. Iterator Variable Names
NEVER use reserved built-in function names as iterator variables:
```gdscript
# WRONG - 'log' shadows built-in log() function
for log in log_files:
    total_size += log.size

# CORRECT - use descriptive name
for log_entry in log_files:
    total_size += log_entry.size
```

**Why this matters:** GDScript built-in functions like `log()`, `error()`, `name`, etc. will cause shadowing warnings if used as variable names.

### 2. Lambda Parameter Names
Same rule applies to lambda/anonymous function parameters:
```gdscript
# WRONG - 'log' parameter shadows built-in
var errors = recent_logs.filter(func(log): return log.level == "ERROR")

# CORRECT
var errors = recent_logs.filter(func(log_entry): return log_entry.level == "ERROR")
```

### 3. Unused Function Parameters
GDScript warns about unused parameters. Either use them or remove them:
```gdscript
# WRONG - to_scene declared but never used
func _update_scene_history(from_scene: String, to_scene: String) -> void:
    scene_history.append(from_scene)  # to_scene not used!

# CORRECT - remove unused parameter
func _update_scene_history(from_scene: String) -> void:
    scene_history.append(from_scene)
```

### 4. Output Parameters Don't Work
GDScript passes strings by value, not reference. "Output parameters" don't work:
```gdscript
# WRONG - block_reason won't get modified in caller
func can_do_thing(block_reason: String = "") -> bool:
    block_reason = "Some error"  # This only modifies the local copy!
    return false

# CORRECT - return Dictionary with results
func can_do_thing() -> Dictionary:
    return {"allowed": false, "reason": "Some error"}
```

### 5. Type Mismatches in String Formatting
Use correct format specifiers for types:
```gdscript
# WRONG - %d (integer) with float value
print("Added %d XP" % [amount])  # amount is float - narrowing conversion warning

# CORRECT - use %f or %.1f for floats
print("Added %.1f XP" % [amount])
```

## Quick Reference: Logging Best Practices

### Do Log:
- All errors and warnings
- State transitions (scene changes, game state changes)
- Currency transactions (with before/after values)
- Player actions (purchases, upgrades)
- Save/load operations
- Network operations (when Nakama is implemented)

### Don't Log:
- Every frame in `_process()`
- Frequent position updates
- Mouse movements
- Render updates
- Trivial getter calls

### Standard Categories:
- `GAME` - Game lifecycle events
- `SCENE` - Scene transitions
- `CURRENCY` - All currency operations
- `SHOP` - Purchases and unlocks
- `STATS` - Stat changes
- `SAVE` - Save/load operations
- `NETWORK` - Nakama operations (1.18-1.20)
- `LOGGER` - Logger internal operations
