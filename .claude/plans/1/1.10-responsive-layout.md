# Responsive Layout System

**Goal**: Create simple, unified layout system with right-side menu, play area, and notification bar that scales fluidly from 1280x720 upward with 16:9 aspect ratio locked

**Success Criteria**:
- Single layout structure (landscape only, no portrait mode)
- 16:9 aspect ratio locked (letterboxed/pillarboxed if needed)
- Right menu (33% width) for stats, currencies, navigation
- Play area (66% width) for gameplay interaction
- Notification bar (dynamic height based on 3 lines of text) at bottom
- Font scaling: 25px base at 1280x720 scales to 37px at 1920x1080
- Automatic scaling capped at 1.5x maximum
- 8px gaps between play area, menu, and notification bar
- All scenes inherit layout automatically via scene template

**Prerequisites**:
- Phase 1.1 (Project Setup) - Base resolution configured

---

## Overview

Establishes the foundational layout structure used by ALL game scenes. Provides a simple 3-area layout (play area, menu, notifications) with automatic font and element scaling based on screen resolution. Designed for landscape-only desktop/browser gameplay with clean separation of concerns.

**This plan is the authoritative source for ALL font sizing, button sizing, and scaling logic.** The Default Theme (Phase 1.11) references values defined here.

### Key Design Principles

- **Landscape only**: No portrait mode, no mobile support
- **16:9 aspect ratio locked**: Letterbox/pillarbox non-16:9 viewports with black bars
- **Percentage-based widths**: Menu and play area scale with screen width
- **Dynamic notification height**: Calculated from 3 lines of font size (not hardcoded pixels)
- **Automatic font scaling**: 25px base → 37px at 1080p → cap at 1.5x
- **8px gaps**: Visual breathing room between major areas
- **Single layout mode**: No complex reparenting or orientation switching
- **Template inheritance**: All scenes inherit from base template
- **Optimized scaling**: Cached values, only recalculates on viewport changes

---

## Layout Structure

```
Screen (100% width × 100% height, 16:9 aspect ratio enforced)
├── Play Area (66% width minus gap, left side)
│   └── Gameplay interaction (coal shoveling, furnace, etc.)
├── Gap (8px vertical separator)
├── Menu (33% width minus gap, right side)
│   ├── Stats display
│   ├── Currencies
│   ├── Navigation buttons
│   └── Scene-specific controls
├── Gap (8px horizontal separator)
└── Notification Bar (bottom, dynamic height based on 3 lines)
    └── 3 lines of notification text (height auto-calculated)
```

### Visual Layout Diagram

```
+----------------------------------------+
|                         |              |
|                         |   [Stats]    |
|                         |              |
|    PLAY AREA (66%)      |   [Money]    |
|                         |              |
|  (Furnace, coal,        | MENU (33%)   |
|   interactions)         |              |
|                         | [Navigation] |
|                         |              |
|                         |  [Buttons]   |
|                         |              |
+----------------------------------------+
|  Notification Bar (dynamic / 3 lines)  |
+----------------------------------------+

Note: 8px gaps between Play/Menu and Notification Bar
```

---

## Implementation Tasks

### 1. Create Scene Template

**File**: `res://level1/scene_template.tscn`

**Node Structure**:
```
SceneRoot (Control, anchors fill parent)
├── Background (ColorRect, black - for letterbox/pillarbox)
├── AspectContainer (AspectRatioContainer, ratio = 16:9)
│   └── MainContainer (Control)
│       ├── Background (TextureRect, stretch mode: keep aspect covered)
│       ├── mainarea (HBoxContainer with gaps)
│       │   ├── PlayArea (Control, size calculated dynamically)
│       │   │   └── CenterContainer (optional, for centering content)
│       │   ├── Separator (8px gap)
│       │   └── Menu (VBoxContainer, size calculated dynamically)
│       │       └── (Scene-specific menu content goes here)
│       ├── Separator (8px gap)
│       └── NotificationBar (VBoxContainer, bottom anchor)
│           └── (Notifications appear here, managed by Global.gd)
```

**Properties**:
- **SceneRoot**: anchors (0,0,1,1), mouse_filter = PASS
- **Background (ColorRect)**: anchors (0,0,1,1), color = black, mouse_filter = PASS (for letterboxing)
- **AspectContainer**: ratio = 1.777778 (16/9), stretch_mode = FIT, anchors centered
- **MainContainer**: anchors (0,0,1,1) within AspectContainer
- **Background (TextureRect)**: anchors (0,0,1,1), stretch_mode = KEEP_ASPECT_COVERED, mouse_filter = PASS
  - For TextureRect: stretch_mode = 6 (KEEP_ASPECT_COVERED) - maintains aspect ratio, covers entire area, crops overflow
  - For VideoStreamPlayer: Use `expand = true` with similar covered behavior - maintains aspect ratio while filling screen
- **mainarea**: HBoxContainer with custom_constants/separation = 8, anchors calculated by code (excludes notification bar + gap)
- **PlayArea**: size_flags_horizontal = EXPAND_FILL, custom_minimum_size calculated in _ready()
- **Menu**: size_flags_horizontal = EXPAND_FILL, custom_minimum_size calculated in _ready()
- **Separator**: Control nodes with fixed width/height of 8px
- **NotificationBar**: anchor_bottom = 1.0, custom_minimum_size_y calculated dynamically from font size

### 2. Create ResponsiveLayout Autoload

**File**: `res://responsive_layout.gd`

```gdscript
extends Node

# Base resolution (design target: 1280x720, 16:9 aspect ratio)
const BASE_WIDTH: int = 1280
const BASE_HEIGHT: int = 720
const BASE_ASPECT_RATIO: float = 16.0 / 9.0

# Layout percentages
const PLAY_AREA_WIDTH_PERCENT: float = 0.66
const MENU_WIDTH_PERCENT: float = 0.33

# Gaps (8px spacing between areas)
const GAP_SIZE: int = 8

# Font sizing (base values for 1280x720)
const BASE_FONT_SIZE: int = 25
const LINE_HEIGHT_MULTIPLIER: float = 1.3
const NOTIFICATION_LINES: int = 3
const NOTIFICATION_PADDING: int = 20  # Top + bottom padding

# Scaling limits
const MAX_AUTO_SCALE: float = 1.5  # Cap automatic scaling at 1.5x
const MIN_AUTO_SCALE: float = 1.0  # Don't scale below base

# Cache for optimization
var current_auto_scale: float = 1.0
var cached_viewport_size: Vector2 = Vector2.ZERO
var cached_notification_height: int = 0
var cached_play_area_width: int = 0
var cached_menu_width: int = 0
var nodes_to_scale: Array[Node] = []  # Cache nodes that need font scaling

func _ready():
    calculate_scale()
    get_viewport().size_changed.connect(_on_viewport_size_changed)

func _on_viewport_size_changed():
    # Only recalculate if viewport actually changed
    var new_size = get_viewport().get_visible_rect().size
    if new_size != cached_viewport_size:
        calculate_scale()

func calculate_scale() -> float:
    """
    Calculate automatic resolution-based scale factor.
    Uses BOTH width and height to prevent issues with ultrawide/tall monitors.
    Base: 1280x720 = 1.0x
    1920x1080 = 1.5x
    Capped at MAX_AUTO_SCALE (1.5x)
    """
    var viewport = get_viewport()
    if not viewport:
        return 1.0

    var viewport_size = viewport.get_visible_rect().size
    cached_viewport_size = viewport_size

    # Calculate scale based on BOTH dimensions, use the smaller one
    # This prevents oversized UI on ultrawide monitors or undersized on tall monitors
    var width_scale = viewport_size.x / float(BASE_WIDTH)
    var height_scale = viewport_size.y / float(BASE_HEIGHT)
    var scale = min(width_scale, height_scale)

    # Clamp between min and max
    current_auto_scale = clamp(scale, MIN_AUTO_SCALE, MAX_AUTO_SCALE)

    # Invalidate caches when scale changes
    _invalidate_caches()

    return current_auto_scale

func _invalidate_caches():
    """Clear cached calculated values so they're recalculated on next access"""
    cached_notification_height = 0
    cached_play_area_width = 0
    cached_menu_width = 0

func get_auto_scale() -> float:
    """
    Returns current automatic scale (1.0 to 1.5)
    """
    return current_auto_scale

func get_final_scale() -> float:
    """
    Returns final scale including user UI scale preference.
    final_scale = auto_scale * user_ui_scale
    (user_ui_scale comes from settings, see Phase 1.12)
    """
    var user_scale = 1.0
    # Check if Global autoload exists and has ui_scale property
    if has_node("/root/Global") and Global.has_method("get") and Global.get("ui_scale") != null:
        user_scale = Global.ui_scale
    return current_auto_scale * user_scale

func get_scaled_font_size(base_size: int = BASE_FONT_SIZE) -> int:
    """
    Returns scaled font size based on resolution and user preference.
    This is the AUTHORITATIVE font sizing function - all UI should use this.
    """
    return int(base_size * get_final_scale())

func get_notification_bar_height() -> int:
    """
    Returns notification bar height dynamically calculated from font size.
    Formula: (font_size * line_height * num_lines) + padding
    This ensures 3 lines of text always fit perfectly.
    """
    if cached_notification_height > 0:
        return cached_notification_height

    var font_size = get_scaled_font_size()
    var line_height = font_size * LINE_HEIGHT_MULTIPLIER
    var total_text_height = line_height * NOTIFICATION_LINES
    cached_notification_height = int(total_text_height + NOTIFICATION_PADDING)
    return cached_notification_height

func get_play_area_width() -> int:
    """
    Returns play area width in pixels (accounting for gap)
    """
    if cached_play_area_width > 0:
        return cached_play_area_width

    var viewport_width = cached_viewport_size.x if cached_viewport_size.x > 0 else get_viewport().get_visible_rect().size.x
    # Subtract one gap (between play area and menu)
    cached_play_area_width = int((viewport_width * PLAY_AREA_WIDTH_PERCENT) - (GAP_SIZE / 2.0))
    return cached_play_area_width

func get_menu_width() -> int:
    """
    Returns menu width in pixels (accounting for gap)
    """
    if cached_menu_width > 0:
        return cached_menu_width

    var viewport_width = cached_viewport_size.x if cached_viewport_size.x > 0 else get_viewport().get_visible_rect().size.x
    # Subtract one gap (between play area and menu)
    cached_menu_width = int((viewport_width * MENU_WIDTH_PERCENT) - (GAP_SIZE / 2.0))
    return cached_menu_width

func apply_to_scene(scene_root: Control) -> void:
    """
    Apply responsive layout to a scene.
    Call from scene's _ready(): ResponsiveLayout.apply_to_scene(self)
    """
    call_deferred("_apply_layout", scene_root)

func _apply_layout(scene_root: Control) -> void:
    calculate_scale()

    # Get layout nodes (updated paths for new structure)
    var aspect_container = scene_root.get_node_or_null("AspectContainer")
    var main_container = scene_root.get_node_or_null("AspectContainer/MainContainer") if aspect_container else null
    var main_layout = main_container.get_node_or_null("mainarea") if main_container else null
    var play_area = main_layout.get_node_or_null("PlayArea") if main_layout else null
    var menu = main_layout.get_node_or_null("Menu") if main_layout else null
    var notification_bar = main_container.get_node_or_null("NotificationBar") if main_container else null

    if not main_layout or not play_area or not menu:
        push_warning("ResponsiveLayout: Scene missing required layout nodes")
        return

    # Set aspect ratio container
    if aspect_container and aspect_container is AspectRatioContainer:
        aspect_container.ratio = BASE_ASPECT_RATIO

    # Set widths based on percentages (accounting for gaps)
    play_area.custom_minimum_size.x = get_play_area_width()
    menu.custom_minimum_size.x = get_menu_width()

    # Set mainarea bottom offset to leave room for notification bar + gap
    if notification_bar and main_layout:
        var notif_height = get_notification_bar_height()
        main_layout.set_anchor_and_offset(SIDE_BOTTOM, 1.0, -(notif_height + GAP_SIZE))

    # Set notification bar height (dynamically calculated)
    if notification_bar:
        notification_bar.custom_minimum_size.y = get_notification_bar_height()

    # Apply font scaling to all labels and buttons
    _apply_font_scaling(scene_root)

    # Set mouse filters
    _set_mouse_filters(scene_root)

func _apply_font_scaling(node: Node) -> void:
    """
    Apply font scaling to all UI elements.
    Optimized: caches nodes on first pass for faster subsequent updates.
    """
    var scaled_font = get_scaled_font_size()

    if node is Label or node is Button or node is RichTextLabel:
        # Only apply if node doesn't have a custom theme font size already set
        # This allows manual overrides for special cases (titles, debug text, etc.)
        node.add_theme_font_size_override("font_size", scaled_font)

        # Cache this node for future updates
        if node not in nodes_to_scale:
            nodes_to_scale.append(node)

    for child in node.get_children():
        _apply_font_scaling(child)

func _set_mouse_filters(scene_root: Control) -> void:
    """
    Set mouse_filter to PASS on background and containers to prevent click blocking
    """
    var background = scene_root.get_node_or_null("Background")
    if background:
        background.mouse_filter = Control.MOUSE_FILTER_PASS

    var aspect_container = scene_root.get_node_or_null("AspectContainer")
    if aspect_container:
        aspect_container.mouse_filter = Control.MOUSE_FILTER_PASS

    var main_container = scene_root.get_node_or_null("AspectContainer/MainContainer")
    if main_container:
        main_container.mouse_filter = Control.MOUSE_FILTER_PASS

    var main_layout = scene_root.get_node_or_null("AspectContainer/MainContainer/mainarea")
    if main_layout:
        main_layout.mouse_filter = Control.MOUSE_FILTER_PASS
```

### 3. Configure Project Settings for Aspect Ratio

**File**: `project.godot`

Update display settings to use "expand" stretch mode which works with AspectRatioContainer:

```ini
[display]

window/size/viewport_width=1280
window/size/viewport_height=720
window/size/mode=2  # Windowed resizable
window/size/resizable=true
window/stretch/mode="viewport"
window/stretch/aspect="expand"
```

**Why "expand" mode?**
- Works with AspectRatioContainer to maintain 16:9
- Non-16:9 viewports will show black bars (letterbox/pillarbox)
- Content always displays at correct aspect ratio

### 4. Register Autoload

**File**: `project.godot`

```ini
[autoload]

ResponsiveLayout="*res://responsive_layout.gd"
```

### 5. Usage in Scenes

**In any scene script** (that inherits from scene_template.tscn):

```gdscript
extends Control

func _ready():
    ResponsiveLayout.apply_to_scene(self)

    # Scene-specific setup below
    # ...
```

---

## Notification System Integration

**Note**: Detailed notification plans are covered in separate TOC items:
- **Notifications** - Generic notification system
- **Stat Notification System** - Stat gain feedback

**Layout responsibilities** (this plan):
- Provide notification bar area (120px base, bottom of screen)
- Scale notification bar with resolution
- Ensure notifications don't overlap play area or menu

**Notification system responsibilities** (future plans):
- Display notification messages
- Queue and timing logic
- Animation and styling
- Stat-specific formatting


---

## Typography & Font Sizing

**This section is the AUTHORITATIVE source for ALL font sizing in the game.**
The Default Theme (Phase 1.11) references these values.

### Base Font Size

```gdscript
BASE_FONT_SIZE = 25  # Pixels at base resolution (1280x720)
```

**Scaling Behavior**:
- **1280x720 (base)**: 25px
- **1920x1080 (1.5x)**: 37px
- **2560x1440 (2.0x, capped at 1.5x)**: 37px
- **User adjustable**: Via UI Scale Slider (Phase 1.12)

### Font Size Constants

All font sizes are derived from `BASE_FONT_SIZE` and scaled automatically via `ResponsiveLayout.get_scaled_font_size()`:

```gdscript
# Primary font sizes (all scale automatically)
FONT_NORMAL = 25        # Base font for labels, buttons, body text
FONT_SMALL = 20         # Secondary info, tooltips, timestamps
FONT_LARGE = 32         # Headers, titles, important stats
FONT_HUGE = 40          # Main title text, major headings

# Line height multiplier
LINE_HEIGHT_MULTIPLIER = 1.3  # 130% of font size for comfortable spacing
```

### Usage in Code

**Standard approach** (automatic scaling):
```gdscript
# Let ResponsiveLayout apply font size automatically
# No manual override needed - fonts scale with resolution
```

**Manual override** (special cases only):
```gdscript
# For custom font sizes (titles, debug text, etc.)
var title_font_size = ResponsiveLayout.get_scaled_font_size(40)  # FONT_HUGE
label.add_theme_font_size_override("font_size", title_font_size)
```

**When to use manual overrides**:
- Large titles/headings (use FONT_LARGE or FONT_HUGE)
- Small debug text or timestamps (use FONT_SMALL)
- Special UI elements that need different sizing

**Default behavior**: All Labels, Buttons, and RichTextLabels automatically get `FONT_NORMAL` (25px scaled) applied by `ResponsiveLayout.apply_to_scene()`.

### Typography Hierarchy

| Element | Font Size Constant | Base Size | 1080p Size | Usage |
|---------|-------------------|-----------|------------|-------|
| Body text | FONT_NORMAL | 25px | 37px | Buttons, labels, standard text |
| Small text | FONT_SMALL | 20px | 30px | Tooltips, timestamps, secondary info |
| Headers | FONT_LARGE | 32px | 48px | Section headers, stat categories |
| Titles | FONT_HUGE | 40px | 60px | Scene titles, major headings |

**Design principle**: Use FONT_NORMAL for 90% of UI. Reserve larger/smaller sizes for emphasis and hierarchy.

---

## Button Sizing Guidelines

All buttons should follow these consistent sizing guidelines to ensure uniform appearance across scenes:

### Standard Button Dimensions

```gdscript
# Minimum button size (in pixels at base resolution 1280x720)
MIN_BUTTON_WIDTH: int = 120
MIN_BUTTON_HEIGHT: int = 50

# Padding (space between text and button edge)
BUTTON_PADDING_HORIZONTAL: int = 20  # 10px each side
BUTTON_PADDING_VERTICAL: int = 10    # 5px top + bottom

# For larger buttons (primary actions, navigation)
LARGE_BUTTON_WIDTH: int = 160
LARGE_BUTTON_HEIGHT: int = 60
```

### Button Sizing Rules

1. **Minimum clickable area**: All buttons must be at least 120x50px at base resolution (1280x720)
2. **Text padding**: Maintain at least 10px horizontal and 5px vertical padding from button edges
3. **Auto-sizing**: Buttons should expand to fit text, but never shrink below minimum size
4. **Icon spacing**: If button has an icon, add 8px gap between icon and text
5. **Scaling**: Button sizes scale with resolution via ResponsiveLayout.get_auto_scale()

### Implementation in Theme

These values should be applied in the Default Theme (Phase 1.11) via:
- `custom_minimum_size` properties
- StyleBoxFlat `content_margin` properties (for padding)
- Theme overrides for different button variations

---

## Code Examples

### Complete Scene Template Setup

**scene_template.tscn** (text format excerpt):

```
[gd_scene format=3]

[node name="SceneRoot" type="Control"]
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
mouse_filter = 2

[node name="Background" type="ColorRect" parent="."]
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
color = Color(0, 0, 0, 1)
mouse_filter = 2

[node name="AspectContainer" type="AspectRatioContainer" parent="."]
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
ratio = 1.777778
stretch_mode = 3
mouse_filter = 2

[node name="MainContainer" type="Control" parent="AspectContainer"]
layout_mode = 2
mouse_filter = 2

[node name="Background" type="TextureRect" parent="AspectContainer/MainContainer"]
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
expand_mode = 1
stretch_mode = 6
mouse_filter = 2

[node name="mainarea" type="HBoxContainer" parent="AspectContainer/MainContainer"]
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
mouse_filter = 2
theme_override_constants/separation = 8

[node name="PlayArea" type="Control" parent="AspectContainer/MainContainer/mainarea"]
custom_minimum_size = Vector2(0, 0)
layout_mode = 2
size_flags_horizontal = 3

[node name="Menu" type="VBoxContainer" parent="AspectContainer/MainContainer/mainarea"]
custom_minimum_size = Vector2(0, 0)
layout_mode = 2
size_flags_horizontal = 3

[node name="NotificationBar" type="VBoxContainer" parent="AspectContainer/MainContainer"]
anchors_preset = 12
anchor_top = 1.0
anchor_right = 1.0
anchor_bottom = 1.0
custom_minimum_size = Vector2(0, 0)
```

**Note**: All `custom_minimum_size` values start at (0, 0) and are calculated dynamically by `ResponsiveLayout.apply_to_scene()` in the scene's `_ready()` function. This prevents the flash of incorrect sizes at non-base resolutions.

### Scaling Examples

**Font Scaling**:
```gdscript
# At 1280x720 (base):
ResponsiveLayout.get_scaled_font_size(25)  # Returns: 25px

# At 1920x1080 (1.5x):
ResponsiveLayout.get_scaled_font_size(25)  # Returns: 37px

# At 2560x1440 (2.0x, but capped at 1.5x):
ResponsiveLayout.get_scaled_font_size(25)  # Returns: 37px (capped)
```

**Layout Widths** (accounting for 8px gap):
```gdscript
# At 1280x720:
ResponsiveLayout.get_play_area_width()  # Returns: ~841px (66% - 4px for gap)
ResponsiveLayout.get_menu_width()       # Returns: ~418px (33% - 4px for gap)

# At 1920x1080:
ResponsiveLayout.get_play_area_width()  # Returns: ~1263px (66% - 4px for gap)
ResponsiveLayout.get_menu_width()       # Returns: ~630px (33% - 4px for gap)
```

**Notification Bar Height** (dynamically calculated):
```gdscript
# At 1280x720 (base, 25px font):
ResponsiveLayout.get_notification_bar_height()  # Returns: ~118px
# Formula: (25 * 1.3 * 3) + 20 = 97.5 + 20 = 117.5 ≈ 118px

# At 1920x1080 (1.5x scale, 37px font):
ResponsiveLayout.get_notification_bar_height()  # Returns: ~164px
# Formula: (37 * 1.3 * 3) + 20 = 144.3 + 20 = 164.3 ≈ 164px
```

---

## Testing Strategy

### Manual Test Criteria

**Layout Structure:**
- [ ] Scene template created with AspectRatioContainer structure
- [ ] Black ColorRect background for letterboxing visible
- [ ] PlayArea takes 66% width (minus 4px gap)
- [ ] Menu takes 33% width (minus 4px gap)
- [ ] 8px gap visible between PlayArea and Menu
- [ ] 8px gap visible between mainarea and NotificationBar
- [ ] Notification bar at bottom, height dynamically calculated

**Aspect Ratio Enforcement (16:9):**
- [ ] At 1280x720 (16:9): No letterboxing, fills screen
- [ ] At 1920x1080 (16:9): No letterboxing, fills screen
- [ ] At 1920x1200 (16:10): Black bars top/bottom (letterbox)
- [ ] At 2560x1080 (21:9 ultrawide): Black bars left/right (pillarbox)
- [ ] Content maintains 16:9 aspect at all viewport sizes

**Resolution Scaling:**
- [ ] At 1280x720: Font 25px, notification bar ~118px
- [ ] At 1920x1080: Font 37px, notification bar ~164px
- [ ] At 2560x1440: Font 37px (capped), notification bar ~164px (capped)
- [ ] At 3840x2160 (4K): Font 37px (capped), notification bar ~164px (capped)
- [ ] Scale calculated from BOTH width and height (uses smaller)

**Layout Proportions:**
- [ ] Play area always 66% width at all resolutions (accounting for gap)
- [ ] Menu always 33% width at all resolutions (accounting for gap)
- [ ] Notification bar height dynamically calculated from font size
- [ ] Notification bar can fit 3 lines of text comfortably

**Mouse Interaction:**
- [ ] Clicks work in play area
- [ ] Buttons in menu are clickable
- [ ] Background doesn't block clicks
- [ ] Notifications don't block play area clicks
- [ ] Black letterbox/pillarbox bars don't interfere with clicks

**Cross-Scene Consistency:**
- [ ] Multiple scenes inherit template correctly
- [ ] Layout consistent across scene changes
- [ ] Scaling applies to all scenes uniformly

**Performance:**
- [ ] No visible flash when scene loads at non-base resolution
- [ ] Window resize doesn't cause lag spikes
- [ ] Cached values only recalculate when viewport actually changes

---

## Files to Create

- `res://responsive_layout.gd` - Responsive layout autoload
- `res://level1/scene_template.tscn` - Base scene template with AspectRatioContainer for inheritance

## Files to Modify

- `project.godot` - Add ResponsiveLayout autoload and update display settings for aspect ratio locking

---

## Design Values (Reference)

### Layout Percentages (with 8px gaps)

| Area | Width % | Calculation (at 1280x720) | Calculation (at 1920x1080) |
|------|---------|---------------------------|----------------------------|
| Play Area | 66% - 4px | (1280 × 0.66) - 4 = ~841px | (1920 × 0.66) - 4 = ~1263px |
| Gap | 8px fixed | 8px | 8px |
| Menu | 33% - 4px | (1280 × 0.33) - 4 = ~418px | (1920 × 0.33) - 4 = ~630px |
| Gap | 8px fixed | 8px | 8px |
| Notification Bar | 100% width | 1280px | 1920px |

### Notification Bar Height (Dynamic Calculation)

**Formula**:
```
height = (font_size × line_height_multiplier × num_lines) + padding
```

**Examples**:
- **1280x720 (25px font)**: (25 × 1.3 × 3) + 20 = 97.5 + 20 = **~118px**
- **1920x1080 (37px font)**: (37 × 1.3 × 3) + 20 = 144.3 + 20 = **~164px**
- **2560x1440 (37px font, capped)**: (37 × 1.3 × 3) + 20 = 144.3 + 20 = **~164px**

**Key Insight**: Height is calculated FROM font size, not hardcoded. This ensures 3 lines always fit perfectly.

### Font Scaling

| Resolution | Scale Factor | Base Font (25px) | Result |
|------------|--------------|------------------|--------|
| 1280x720 | 1.0x | 25px | 25px |
| 1600x900 | 1.25x | 25px | 31px |
| 1920x1080 | 1.5x | 25px | 37px |
| 2560x1440 | 2.0x (capped at 1.5x) | 25px | 37px |
| 3840x2160 | 3.0x (capped at 1.5x) | 25px | 37px |

**Why cap at 1.5x?**
- Prevents excessively large text at 4K
- 37px is already very readable
- Allows more information density at higher resolutions
- User can adjust with UI Scale Slider (Phase 1.12) if needed

---

## Notes & Decisions

**Decision 1**: Lock to 16:9 aspect ratio
- **Rationale**: Desktop/browser focus, single background asset, simpler implementation
- **Implementation**: AspectRatioContainer + letterbox/pillarbox black bars
- **Benefit**: Consistent layout across all screen sizes, no distortion
- **Trade-off**: Black bars on non-16:9 displays (acceptable for targeted desktop experience)

**Decision 2**: Landscape only (no portrait mode)
- **Rationale**: Desktop/browser focus, simpler implementation, no mobile support needed
- **Benefit**: Eliminates complex reparenting logic, easier to maintain
- **Trade-off**: Not usable on mobile devices (acceptable for this project)

**Decision 3**: 66/33 split (play area/menu)
- **Rationale**: Prioritizes gameplay area while giving menu enough space for stats/currencies
- **Alternative considered**: 75/25 (rejected - menu too cramped), 50/50 (rejected - play area too small)

**Decision 4**: Percentage-based widths (not fixed pixels)
- **Rationale**: Scales naturally with resolution, maintains proportions
- **Benefit**: Looks correct at all resolutions without manual adjustment

**Decision 5**: Dynamic notification height (calculated from font size)
- **Rationale**: Always fits 3 lines perfectly regardless of resolution/font size
- **Benefit**: No hardcoded pixel values that break at different scales
- **Formula**: (font_size × 1.1 × 3) + 5px padding

**Decision 6**: Cap automatic scaling at 1.5x
- **Rationale**: Prevents giant text at 4K, maintains information density
- **Override**: User can adjust with UI Scale Slider if they want bigger text
- **Min scale**: 1.0x (no scaling below base resolution)

**Decision 7**: 8px gaps between major areas
- **Rationale**: Visual breathing room, prevents elements from touching
- **Benefit**: Cleaner visual separation, easier to distinguish sections
- **Implementation**: HBoxContainer separation constant + manual gap spacing

**Decision 8**: Scale from BOTH width and height (use smaller)
- **Rationale**: Prevents oversized UI on ultrawide, undersized on tall monitors
- **Example**: 2560×1080 ultrawide uses height-based scale (1.5x), not width-based (2.0x)

**Decision 9**: Menu on right side
- **Rationale**: Western reading pattern (left to right), play area gets visual priority
- **Benefit**: Natural eye flow from gameplay to stats

**Decision 10**: Cache calculated values for performance
- **Rationale**: Avoid recalculating widths/heights on every access
- **Benefit**: Reduces CPU usage, only recalculates when viewport actually changes
- **Implementation**: Invalidate cache on viewport size change only

---

## Implementation Checklist

Before marking this phase complete:

**Code & Files:**
- [ ] responsive_layout.gd created with all functions
- [ ] scene_template.tscn created with AspectRatioContainer structure
- [ ] Autoload registered in project.godot
- [ ] project.godot display settings updated for aspect ratio lock

**Core Functionality:**
- [ ] calculate_scale() uses BOTH width and height (min of both)
- [ ] get_scaled_font_size() function working
- [ ] get_notification_bar_height() dynamically calculates from font size
- [ ] apply_to_scene() function working with new node paths
- [ ] Caching system working (only recalculates on viewport change)

**Layout Structure:**
- [ ] AspectRatioContainer ratio set to 16:9 (1.777778)
- [ ] Black ColorRect background for letterboxing
- [ ] mainarea HBoxContainer has 8px separation
- [ ] PlayArea width = 66% - 4px gap at all resolutions
- [ ] Menu width = 33% - 4px gap at all resolutions
- [ ] 8px gap visible between play area and menu
- [ ] 8px gap between mainarea and NotificationBar
- [ ] Notification bar height calculated dynamically (fits 3 lines)

**Scaling & Aspect Ratio:**
- [ ] Font scaling: 25px → 37px at 1080p
- [ ] Font scaling capped at 1.5x
- [ ] Scale doesn't go below 1.0x
- [ ] Letterboxing works on non-16:9 displays (e.g., 1920x1200)
- [ ] Pillarboxing works on ultrawide (e.g., 2560x1080)

**Mouse & Interaction:**
- [ ] Mouse filters set correctly (clicks work)
- [ ] Black bars don't interfere with clicks
- [ ] All interactive elements clickable

**Testing:**
- [ ] Test scene created to verify layout
- [ ] Tested at 1280x720 (base, no letterbox)
- [ ] Tested at 1920x1080 (1.5x scale, no letterbox)
- [ ] Tested at 2560x1440 (capped at 1.5x, no letterbox)
- [ ] Tested at 1920x1200 (16:10, shows letterbox bars)
- [ ] Tested at 2560x1080 (ultrawide, shows pillarbox bars)
- [ ] No flash of incorrect sizes when loading

**Documentation:**
- [ ] Typography section added with font sizing constants
- [ ] Button sizing guidelines complete
- [ ] All design decisions documented
- [ ] Code comments clear and accurate

---

**Last Updated**: 2025-12-05
**Maintainer**: Claude + User collaboration
