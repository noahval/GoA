# Currency Display Component

**Goal**: Create reusable currency display component showing icon + amount, usable in any scene (HUD, menu items, tooltips)

**Success Criteria**:
- CurrencyDisplay custom node created (HBoxContainer with TextureRect + Label)
- Displays currency icon + formatted number
- Auto-updates when Level1Vars.currency changes
- Responsive scaling (icons and text scale with ResponsiveLayout)
- Works in any scene (HUD corner, menu items, shop displays)
- Architecture supports silver/gold/platinum icons (added later when unlocked)
- Copper icon loaded from `res://level1/icons/copper.png`

**Prerequisites**:
- 1.x-currencies.md (Level1Vars.currency data structure)
- 1.x-responsive-layout.md (font scaling, layout adaptation)
- 1.x-default-theme.md (label styling, colors)

---

## Overview

CurrencyDisplay is a reusable UI component that shows currency amount with a small icon. It's designed for maximum flexibility: can be placed in HUDs, menu items, or anywhere currency needs to be displayed.

The component updates when Global.refresh_all_currency_displays() is called (typically after currency transactions). For displaying item costs (not player balance), create a separate component in the shop plan.

### Key Design Principles

- **Small icon + text format**: Compact icon on left, number on right (e.g., [copper icon] 123)
- **Auto-updating**: Uses Global.refresh_all_currency_displays() from 1.x-currency-manager.md
- **Reusable**: Drop into any scene, configure currency type, done
- **Responsive**: Scales with ResponsiveLayout (larger at 1080p, smaller at 720p)
- **Future-proof**: Architecture supports multiple currency types (add silver/gold/platinum later)
- **No abbreviations**: Show full numbers (e.g., "1,234" not "1.2k") for clarity
- **Locked currencies hidden**: Don't display locked currency types at all (no greyed icons)

---

## Component Structure

### CurrencyDisplay Node Hierarchy

```
CurrencyDisplay (HBoxContainer) - Root node, contains icon + label
├── Icon (TextureRect) - Currency icon (copper.png)
└── Amount (Label) - Formatted number (e.g., "1,234")
```

**Node Details**:
- **HBoxContainer**: Left-to-right layout, auto-sizes to content
- **TextureRect**:
  - Size: 32x32px (scales with ResponsiveLayout)
  - Expand mode: Keep aspect, centered
  - Texture: `res://level1/icons/copper.png`
- **Label**:
  - Font size: FONT_NORMAL from ResponsiveLayout (25px base, scales to resolution)
  - Text: Formatted number with thousand separators (e.g., "1,234")
  - Theme: Uses default_theme.tres label styling

---

## Implementation Tasks

### 1. Create Custom Node Script

**File Location**: `res://ui/currency_display.gd`

**Script Structure**:
```gdscript
extends HBoxContainer
class_name CurrencyDisplay

# ===== CONFIGURATION =====
# Which currency to display (default: copper)
@export var currency_type: String = "copper"

# Whether to show zero amounts (default: true)
@export var show_zero: bool = true

# ===== NODES =====
@onready var icon: TextureRect = $Icon
@onready var amount_label: Label = $Amount

# ===== ICON PATHS =====
const CURRENCY_ICONS = {
	"copper": "res://level1/icons/copper.png",
	# Add later when currencies unlock:
	# "silver": "res://level1/icons/silver.png",
	# "gold": "res://level1/icons/gold.png",
	# "platinum": "res://level1/icons/platinum.png",
}

# ===== LIFECYCLE =====
func _ready():
	# Add to refresh group for Global.refresh_all_currency_displays()
	add_to_group("currency_displays")

	# Load currency icon
	_load_icon()

	# Apply responsive scaling to icon (ResponsiveLayout doesn't scale TextureRect)
	var scale_factor = ResponsiveLayout.get_auto_scale()
	icon.custom_minimum_size = Vector2(32, 32) * scale_factor

	# Initial display
	refresh()

# ===== ICON LOADING =====
func _load_icon():
	if currency_type not in CURRENCY_ICONS:
		push_error("Unknown currency type: " + currency_type)
		return

	var icon_path = CURRENCY_ICONS[currency_type]

	# Validate file exists before loading
	if not ResourceLoader.exists(icon_path):
		push_error("Icon file missing: " + icon_path)
		return

	var texture = load(icon_path)
	if texture:
		icon.texture = texture
	else:
		push_error("Failed to load currency icon: " + icon_path)

# ===== GROUP-BASED REFRESH =====
# Component is added to "currency_displays" group in _ready()
# Global.refresh_all_currency_displays() calls refresh() on all group members
# This is triggered after any currency transaction

# ===== DISPLAY UPDATE =====
func refresh():
	"""Update display to show current currency amount"""
	var amount = _get_currency_amount()

	# Hide if zero and show_zero is false
	if amount == 0 and not show_zero:
		visible = false
		return

	visible = true
	amount_label.text = _format_number(amount)

# ===== CURRENCY ACCESS =====
func _get_currency_amount() -> float:
	# Simplified using dictionary.get() instead of match statement
	return Level1Vars.currency.get(currency_type, 0.0)

# ===== NUMBER FORMATTING =====
func _format_number(value: float) -> String:
	var int_value = int(value)

	# Custom thousand separator implementation
	# (Godot 4.5 String.format() doesn't support thousand separators)
	var num_str = str(int_value)
	var result = ""
	var count = 0

	# Handle negative numbers
	var is_negative = int_value < 0
	if is_negative:
		num_str = num_str.substr(1)  # Remove minus sign for processing

	# Iterate from right to left, add commas every 3 digits
	for i in range(num_str.length() - 1, -1, -1):
		if count > 0 and count % 3 == 0:
			result = "," + result
		result = num_str[i] + result
		count += 1

	# Re-add minus sign if negative
	if is_negative:
		result = "-" + result

	return result

# ===== PUBLIC API =====
# Change currency type dynamically
func set_currency_type(new_type: String):
	if new_type not in CURRENCY_ICONS:
		push_error("Invalid currency type: " + new_type)
		return
	currency_type = new_type
	_load_icon()
	refresh()

# Check if currency is unlocked
func is_currency_unlocked() -> bool:
	# Integrate with Level1Vars unlock system
	match currency_type:
		"copper":
			return true  # Always unlocked
		"silver":
			return Level1Vars.get("unlocked_silver") if Level1Vars.get("unlocked_silver") != null else false
		"gold":
			return Level1Vars.get("unlocked_gold") if Level1Vars.get("unlocked_gold") != null else false
		"platinum":
			return Level1Vars.get("unlocked_platinum") if Level1Vars.get("unlocked_platinum") != null else false
		_:
			return false
```

**Key Features**:
- @export properties for easy configuration in editor
- Auto-loading of currency icon based on type (with file existence validation)
- Thousand separator formatting with negative number support (1234 → "1,234", -500 → "-500")
- Optional zero-hiding (useful for unlockable currencies)
- Group-based refresh via Global.refresh_all_currency_displays()
- Currency unlock detection (component should not be instantiated for locked currencies)

**IMPORTANT - GDScript get() Syntax**:
GDScript's built-in `get()` method only accepts 1 argument (property name), NOT 2 arguments.
- ❌ WRONG: `Level1Vars.get("property", false)` - Parser error!
- ✅ CORRECT: `Level1Vars.get("property") if Level1Vars.get("property") != null else false`

---

### 2. Create Scene File

**File Location**: `res://ui/currency_display.tscn`

**Scene Setup** (in Godot editor):
1. Create new scene with root node: HBoxContainer
2. Rename root to "CurrencyDisplay"
3. Attach script: `res://ui/currency_display.gd`
4. Add child: TextureRect, rename to "Icon"
5. Add child: Label, rename to "Amount"

**Node Configuration**:

**CurrencyDisplay (HBoxContainer)**:
- Alignment: Center (vertical)
- Separation: 8px (space between icon and text) - Set in Inspector → LayoutContainer → Separation
- Size Flags: Shrink Begin (don't expand, stay compact)

**Icon (TextureRect)**:
- Custom Minimum Size: 32x32
- Expand Mode: Keep Aspect Centered
- Stretch Mode: Scale
- Texture: Leave empty (loaded by script)

**Amount (Label)**:
- Text: "0" (placeholder)
- Horizontal Alignment: Left
- Vertical Alignment: Center
- Autowrap Mode: Off (single line)
- Theme: Inherits from default_theme.tres

**Save as**: `res://ui/currency_display.tscn`

---

### 3. Global Refresh Helper

**IMPORTANT**: Implement this FIRST before creating CurrencyDisplay component

**Purpose**: Refresh all CurrencyDisplay UI components after currency transactions

**File**: Add to `game/v0.1/autoloads/global.gd`

**Implementation**:
```gdscript
# ===== CURRENCY DISPLAY HELPERS =====

## Refresh all CurrencyDisplay instances in the scene tree
## Call this after any currency transaction to update all UI displays
func refresh_all_currency_displays() -> void:
	if not is_instance_valid(get_tree()):
		push_error("Cannot refresh currency displays: scene tree not available")
		return

	get_tree().call_group("currency_displays", "refresh")
```

**How it works**:
1. CurrencyDisplay components add themselves to "currency_displays" group in _ready()
2. Global.refresh_all_currency_displays() calls refresh() on all group members
3. All displays update to show current currency amounts

**Usage pattern**:
```gdscript
# After earning currency
Level1Vars.currency.copper += 50
Global.refresh_all_currency_displays()  # All CurrencyDisplay instances update

# After spending currency
Level1Vars.currency.copper -= 25
Global.refresh_all_currency_displays()

# After currency exchange (when that system is implemented)
# CurrencyManager.exchange_currency() should call this automatically
```

---

### 4. Usage Examples

**Example 1: HUD Corner Display** (always visible):
```gdscript
# In dorm.gd or any scene
func _ready():
	var currency_hud = preload("res://ui/currency_display.tscn").instantiate()
	currency_hud.currency_type = "copper"
	currency_hud.position = Vector2(20, 20)  # Top-left corner
	add_child(currency_hud)
	# Auto-refreshes via Global.refresh_all_currency_displays() after transactions
```

**Example 2: Menu Item** (shows in scene menu):
```gdscript
# In dorm.gd - add to Menu VBoxContainer
func _ready():
	var currency_display = preload("res://ui/currency_display.tscn").instantiate()
	currency_display.currency_type = "copper"

	# Add to menu (e.g., at top of menu before action buttons)
	$AspectContainer/MainContainer/mainarea/Menu.add_child(currency_display)
	$AspectContainer/MainContainer/mainarea/Menu.move_child(currency_display, 0)  # Top of menu
```

**Example 3: Transaction with Refresh** (earning currency):
```gdscript
# In furnace.gd - pay player for work
func _on_shift_complete():
	var earnings = calculate_shift_pay()
	Level1Vars.currency.copper += earnings
	Global.refresh_all_currency_displays()  # All CurrencyDisplay instances update
```

**Note on Shop Item Costs**:
CurrencyDisplay shows player balance, not item costs. For shop item prices, create a separate component in the shop plan that displays a static amount without Level1Vars integration.

---

### 5. Responsive Scaling Integration

**ResponsiveLayout Compatibility**:
- Font size: Amount label uses FONT_NORMAL from ResponsiveLayout (auto-scaled by parent scene)
- Icon size: 32x32px base (does NOT auto-scale - ResponsiveLayout only scales Labels/Buttons/RichTextLabels)
- Spacing: 8px separation (fixed, not scaled)

**Manual Icon Scaling** (implement this):
```gdscript
# In currency_display.gd _ready()
func _ready():
	# ... existing group add, icon load, refresh code ...

	# Apply responsive scaling to icon since ResponsiveLayout doesn't scale TextureRect
	var scale_factor = ResponsiveLayout.get_auto_scale()
	icon.custom_minimum_size = Vector2(32, 32) * scale_factor
```

**Note**: ResponsiveLayout.apply_to_scene() handles font scaling automatically, but TextureRect icons must be scaled manually.

---

## Testing Strategy (TDD)

Following Test-Driven Development methodology per [programming-principles.md#test-driven-development-tdd](.claude/docs/programming-principles.md#test-driven-development-tdd).

### Test File: `res://tests/test_currency_display.gd`

```gdscript
extends GutTest

var display: CurrencyDisplay
var icon: TextureRect
var amount_label: Label

func before_each():
	display = CurrencyDisplay.new()
	# Add child nodes manually since we're not loading the scene
	icon = TextureRect.new()
	icon.name = "Icon"
	display.add_child(icon)

	amount_label = Label.new()
	amount_label.name = "Amount"
	display.add_child(amount_label)

	display._ready()

func after_each():
	display.free()

# RED-GREEN-REFACTOR: Number formatting
func test_format_number_adds_thousand_separators():
	assert_eq(display._format_number(1234), "1,234", "Should add comma for thousands")
	assert_eq(display._format_number(1234567), "1,234,567", "Should add commas for millions")
	assert_eq(display._format_number(100), "100", "No comma for hundreds")

func test_format_number_handles_zero():
	assert_eq(display._format_number(0), "0", "Zero should display as '0'")

func test_format_number_handles_negatives():
	assert_eq(display._format_number(-1234), "-1,234", "Negative formats correctly")
	assert_eq(display._format_number(-500), "-500", "Negative without comma")

# RED-GREEN-REFACTOR: Currency amount reading
func test_get_currency_amount_reads_copper():
	Level1Vars.currency.copper = 500.0
	display.currency_type = "copper"
	assert_eq(display._get_currency_amount(), 500.0, "Should read copper from Level1Vars")

func test_get_currency_amount_handles_invalid_type():
	display.currency_type = "invalid"
	var result = display._get_currency_amount()
	assert_eq(result, 0.0, "Invalid currency type should return 0")

# RED-GREEN-REFACTOR: Refresh behavior
func test_refresh_updates_label_text():
	Level1Vars.currency.copper = 1234.0
	display.currency_type = "copper"
	display.refresh()
	assert_eq(amount_label.text, "1,234", "Label should show formatted amount")

func test_refresh_hides_when_zero_and_show_zero_false():
	Level1Vars.currency.copper = 0.0
	display.currency_type = "copper"
	display.show_zero = false
	display.refresh()
	assert_false(display.visible, "Should hide when amount is zero and show_zero is false")

func test_refresh_shows_when_zero_and_show_zero_true():
	Level1Vars.currency.copper = 0.0
	display.currency_type = "copper"
	display.show_zero = true
	display.refresh()
	assert_true(display.visible, "Should show when amount is zero and show_zero is true")

# RED-GREEN-REFACTOR: Icon loading
func test_load_icon_sets_texture_for_copper():
	display.currency_type = "copper"
	display._load_icon()
	assert_not_null(icon.texture, "Icon texture should be loaded for copper")

func test_load_icon_handles_invalid_type():
	display.currency_type = "nonexistent"
	display._load_icon()
	# Should log error but not crash
	assert_true(true, "Should not crash on invalid currency type")

# RED-GREEN-REFACTOR: Group registration
func test_ready_adds_to_currency_displays_group():
	var test_display = CurrencyDisplay.new()
	add_child_autofree(test_display)
	# Note: Needs scene tree to test groups properly
	# This test verifies the component exists and can be instantiated
	assert_not_null(test_display, "Display should instantiate")

# RED-GREEN-REFACTOR: Currency unlock detection
func test_is_currency_unlocked_returns_true_for_copper():
	display.currency_type = "copper"
	assert_true(display.is_currency_unlocked(), "Copper should always be unlocked")

func test_is_currency_unlocked_returns_false_for_locked():
	# Note: If property doesn't exist on Level1Vars, get() returns null and defaults to false
	display.currency_type = "silver"
	assert_false(display.is_currency_unlocked(), "Silver should be locked initially")

func test_is_currency_unlocked_returns_true_when_unlocked():
	Level1Vars.set("unlocked_silver", true)
	display.currency_type = "silver"
	assert_true(display.is_currency_unlocked(), "Silver should be unlocked when flag set")
```

### TDD Workflow

**Phase 1: Number Formatting (RED-GREEN-REFACTOR)**
1. RED: Write `test_format_number_adds_thousand_separators()` - FAILS (no _format_number yet)
2. GREEN: Implement minimal `_format_number()` to pass
3. REFACTOR: Clean up implementation
4. Repeat for zero/negative tests

**Phase 2: Currency Reading (RED-GREEN-REFACTOR)**
1. RED: Write `test_get_currency_amount_reads_copper()` - FAILS
2. GREEN: Implement `_get_currency_amount()` with match statement
3. REFACTOR: Add error handling
4. Test invalid types

**Phase 3: Refresh Logic (RED-GREEN-REFACTOR)**
1. RED: Write `test_refresh_updates_label_text()` - FAILS
2. GREEN: Implement `refresh()` method
3. REFACTOR: Add show_zero logic
4. Test edge cases

**Phase 4: Icon Loading (RED-GREEN-REFACTOR)**
1. RED: Write `test_load_icon_sets_texture_for_copper()` - FAILS
2. GREEN: Implement `_load_icon()` with ResourceLoader
3. REFACTOR: Add error handling for missing files
4. Test invalid types

**Phase 5: Integration Tests**
1. Test group registration in scene tree
2. Test Global.refresh_all_currency_displays() call
3. Test multiple displays updating together

---

## Files to Create

- `res://tests/test_currency_display.gd` (~100 lines) - TDD test suite
- `res://ui/currency_display.gd` (~150 lines) - Custom node script
- `res://ui/currency_display.tscn` - Scene file (HBoxContainer + Icon + Label)

## Files to Modify

- `res://autoloads/global.gd` (~10 lines added) - Add refresh_all_currency_displays() function

---

## Design Values (Reference)

### Icon Sizing

- **Base size**: 32x32px
- **Scales with resolution**: Multiplied by ResponsiveLayout.get_scale_factor()
- **Minimum size**: 24x24px (for small tooltips or compact displays)
- **Maximum size**: 48x48px (for large HUD elements)

### Spacing

- **Icon-to-text gap**: 8px (HBoxContainer separation)
- **Padding**: None (container auto-sizes to content)

### Currency Icons

| Currency | Icon Path | Status |
|----------|-----------|--------|
| Copper | `res://level1/icons/copper.png` | Exists |
| Silver | `res://level1/icons/silver.png` | Add later (when silver unlocks) |
| Gold | `res://level1/icons/gold.png` | Add later (when gold unlocks) |
| Platinum | `res://level1/icons/platinum.png` | Add later (when platinum unlocks) |

### Number Formatting

- **Thousand separator**: Comma (1,234,567)
- **Decimal places**: 0 (currencies are always whole numbers)
- **Negative sign**: Prefix with "-" (e.g., "-50" for debts)
- **Max display**: No limit (show full number, even if millions)

---

## Integration Points

### Uses Level1Vars

```gdscript
Level1Vars.currency.copper  # Read copper amount
Level1Vars.currency.silver  # Read silver amount (future)
# ... etc
```

### Uses ResponsiveLayout

```gdscript
ResponsiveLayout.FONT_NORMAL  # Font size for amount label (auto-applied)
ResponsiveLayout.get_scale_factor()  # Icon scaling (optional)
```

### Uses Default Theme

```gdscript
# Label inherits from default_theme.tres:
# - Text color: Color(1, 1, 1, 1) (white)
# - Font size: 25px base (scaled by ResponsiveLayout)
```

### Provides APIs For

**Any scene that needs to display player currency balance**:
```gdscript
# Instantiate
var display = preload("res://ui/currency_display.tscn").instantiate()

# Configure
display.currency_type = "copper"  # or "silver", "gold", "platinum"
display.show_zero = true  # Show zero amounts?

# Add to scene
add_child(display)

# Updates automatically when Global.refresh_all_currency_displays() is called
```

**For shop item costs**: Create separate static label component (not this component)

---

## Notes & Decisions

**Decision 1**: Group-based refresh via Global helper
- **Rationale**: Simple, centralized, no manual tracking of display instances
- **Implementation**: Global.refresh_all_currency_displays() calls refresh() on "currency_displays" group
- **Benefit**: All displays update with single function call after transactions

**Decision 2**: Small icon + text layout (not icon-only)
- **Rationale**: Visual clarity with precise information
- **Format**: Compact icon (32x32px) on left, formatted number on right
- **Benefit**: Easy to distinguish copper from silver/gold at a glance

**Decision 3**: Thousand separators always enabled
- **Rationale**: Readability for large numbers (1,234 vs 1234)
- **TODO**: Check if Godot has built-in formatting (e.g., "%,d" % value)
- **Benefit**: Easier to parse amounts at a glance

**Decision 4**: No abbreviations (k, M, B)
- **Rationale**: Full precision, no ambiguity
- **Benefit**: Players always see exact amount
- **Alternative**: Abbreviate large numbers - REJECTED, can add later if needed

**Decision 5**: NO static mode - single responsibility
- **Rationale**: CurrencyDisplay shows player balance only
- **Shop item costs**: Create separate component in shop plan
- **Benefit**: Simpler implementation, clearer purpose, follows Single Responsibility Principle

**Decision 6**: HBoxContainer for layout
- **Rationale**: Auto-sizing, handles icon + text alignment automatically
- **Benefit**: No manual positioning, adapts to content
- **Alternative**: Manual Control node - REJECTED, more complex

**Decision 7**: Locked currencies not displayed
- **Implementation**: is_currency_unlocked() method checks Level1Vars unlock flags
- **Visual**: Don't instantiate CurrencyDisplay components for locked currencies
- **Benefit**: Cleaner UI, currencies appear when unlocked (discovery moment)

**Decision 8**: No negative display in red (WONTFIX v1.0)
**Decision 9**: No count-up animation (WONTFIX v1.0)
**Decision 10**: Negative amounts supported (display "-50" format)

---

## Implementation Checklist

Before marking this phase complete:

### Global Refresh Helper (Implement FIRST)
- [ ] Global.refresh_all_currency_displays() added to global.gd
- [ ] Scene tree validity check implemented
- [ ] Error logging for invalid scene tree
- [ ] Function uses get_tree().call_group() to refresh all displays

### TDD Tests (Write FIRST)
- [ ] `tests/test_currency_display.gd` created
- [ ] test_format_number_adds_thousand_separators() - RED verified
- [ ] test_format_number_handles_zero() - RED verified
- [ ] test_format_number_handles_negatives() - RED verified
- [ ] test_get_currency_amount_reads_copper() - RED verified
- [ ] test_get_currency_amount_handles_invalid_type() - RED verified
- [ ] test_refresh_updates_label_text() - RED verified
- [ ] test_refresh_hides_when_zero_and_show_zero_false() - RED verified
- [ ] test_refresh_shows_when_zero_and_show_zero_true() - RED verified
- [ ] test_load_icon_sets_texture_for_copper() - RED verified
- [ ] test_load_icon_handles_invalid_type() - RED verified
- [ ] test_is_currency_unlocked_returns_true_for_copper() - RED verified
- [ ] test_is_currency_unlocked_returns_false_for_locked() - RED verified
- [ ] test_is_currency_unlocked_returns_true_when_unlocked() - RED verified
- [ ] All tests GREEN (pass)
- [ ] Code REFACTORED (clean, no duplication)

### Implementation (After tests)
- [ ] Copper icon exists at `res://level1/icons/copper.png` (already created)
- [ ] `ui/currency_display.gd` script created
- [ ] class_name CurrencyDisplay registered
- [ ] @export properties defined (currency_type, show_zero)
- [ ] CURRENCY_ICONS dictionary defined (copper icon path)
- [ ] add_to_group("currency_displays") in _ready()
- [ ] Manual icon scaling in _ready() (ResponsiveLayout.get_auto_scale())
- [ ] _load_icon() function implemented with ResourceLoader.exists() check
- [ ] _get_currency_amount() function implemented (simplified with dict.get())
- [ ] _format_number() function with thousand separators and negative number support
- [ ] refresh() function implemented
- [ ] is_currency_unlocked() function implemented with Level1Vars unlock flags
- [ ] set_currency_type() function implemented with validation
- [ ] `ui/currency_display.tscn` scene created
- [ ] Scene structure: HBoxContainer + Icon + Amount
- [ ] HBoxContainer separation set to 8px (Inspector → LayoutContainer → Separation)
- [ ] Icon TextureRect configured (32x32, Keep Aspect Centered)
- [ ] Amount Label configured (FONT_NORMAL, left-aligned)

### Integration
- [ ] Test component in scene menu (VBoxContainer)
- [ ] Test component in HUD corner (absolute position)
- [ ] Test multiple CurrencyDisplays update together
- [ ] Test currency_type change at runtime
- [ ] Responsive scaling verified (720p and 1080p)

---

**Last Updated**: 2025-12-24
**Maintainer**: Claude + User collaboration
**Plan Version**: 2.2 (Fixed GDScript get() syntax - single argument only)
