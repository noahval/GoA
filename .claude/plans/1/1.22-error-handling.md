# Error Handling

## Overview

Simple error handling system that prevents crashes and logs errors properly. Focus: keep the game running, log what went wrong, don't crash.

**Philosophy**: Fail gracefully, log everything, never crash.

---

## Component 1: ErrorHandler Autoload

**File**: `game/v0.1/autoloads/error_handler.gd`

**Purpose**: Wrap risky operations to catch errors before they crash the game.

**Core Functions**:
```gdscript
extends Node

enum Severity {
	MINOR,      # Log and continue silently
	MODERATE,   # Log and show notification
	MAJOR       # Log, show notification, attempt recovery
}

# Execute a function safely, catch errors
func safe_call(callable: Callable, context: String = "") -> Dictionary:
	var result = {"success": false, "value": null, "error": ""}

	# Try to execute
	var error_occurred = false
	var return_value = null

	# GDScript doesn't have try/catch, so we validate before calling
	if not callable.is_valid():
		result.error = "Invalid callable"
		handle_error(context, "Invalid callable provided", Severity.MODERATE)
		return result

	# Call the function
	return_value = callable.call()

	# If we got here, it succeeded
	result.success = true
	result.value = return_value
	return result

# Log error with appropriate severity
func handle_error(context: String, error_msg: String, severity: Severity) -> void:
	# Log to debug system
	match severity:
		Severity.MINOR:
			DebugLogger.warn("[%s] %s" % [context, error_msg], "ERROR")
		Severity.MODERATE:
			DebugLogger.error("[%s] %s" % [context, error_msg], "ERROR")
			Global.show_stat_notification("Something went wrong: " + context, "warning")
		Severity.MAJOR:
			DebugLogger.error("[%s] CRITICAL: %s" % [context, error_msg], "ERROR")
			Global.show_stat_notification("Error occurred - check logs", "error")

# Safe node access - never crashes
func safe_get_node(root: Node, path: String) -> Node:
	if not root:
		return null
	return root.get_node_or_null(path)

# Safe scene loading
func safe_load_scene(scene_path: String) -> PackedScene:
	if not ResourceLoader.exists(scene_path):
		handle_error("SceneLoad", "Scene not found: " + scene_path, Severity.MAJOR)
		return null

	var scene = load(scene_path)
	if not scene:
		handle_error("SceneLoad", "Failed to load scene: " + scene_path, Severity.MAJOR)
		return null

	return scene

# Safe scene change with fallback
func safe_change_scene(tree: SceneTree, scene_path: String, fallback_path: String = "res://level1/loading_screen.tscn") -> bool:
	var scene = safe_load_scene(scene_path)

	if not scene:
		# Try fallback
		scene = safe_load_scene(fallback_path)
		if not scene:
			handle_error("SceneChange", "Both scene and fallback failed", Severity.MAJOR)
			return false

	var result = tree.change_scene_to_packed(scene)
	return result == OK
```

**That's it.** No UI management, no connection monitoring, no recovery actions. Just error catching and logging.

---

## Component 2: Data Validation (CloudSaveValidator)

**File**: `game/v0.1/autoloads/cloud_save_validator.gd`

**Purpose**: Validate loaded save data, clamp to valid ranges.

```gdscript
class_name CloudSaveValidator
extends RefCounted

# Validate loaded save data - clamp to valid ranges
static func validate_save_data(data: Dictionary) -> Dictionary:
	if not is_valid_structure(data):
		return {}

	var validated = data.duplicate(true)

	# Validate Global stats (>= 1.0)
	if validated.has("global"):
		validated.global = _validate_stats(validated.global)

	# Validate Level1Vars currency (>= 0)
	if validated.has("level1_vars"):
		validated.level1_vars = _validate_level1(validated.level1_vars)

	return validated

# Check if save structure is valid
static func is_valid_structure(data: Dictionary) -> bool:
	if not data.has("global"):
		DebugLogger.error("Save missing 'global' key", "VALIDATOR")
		return false
	if not data.has("level1_vars"):
		DebugLogger.error("Save missing 'level1_vars' key", "VALIDATOR")
		return false
	return true

static func _validate_stats(global_data: Dictionary) -> Dictionary:
	# Define stat fields
	var stats = ["strength", "constitution", "dexterity", "wisdom", "intelligence", "charisma"]
	var exp_stats = ["strength_exp", "constitution_exp", "dexterity_exp", "wisdom_exp", "intelligence_exp", "charisma_exp"]

	# Clamp stats to >= 1.0
	for stat in stats:
		if global_data.has(stat):
			global_data[stat] = max(global_data[stat], 1.0)
		else:
			global_data[stat] = 1.0

	# Clamp experience to >= 0
	for exp in exp_stats:
		if global_data.has(exp):
			global_data[exp] = max(global_data[exp], 0.0)
		else:
			global_data[exp] = 0.0

	return global_data

static func _validate_level1(level1_data: Dictionary) -> Dictionary:
	# Validate currency
	if level1_data.has("currency"):
		var currency = level1_data.currency
		currency.copper = max(currency.get("copper", 0.0), 0.0)
		currency.silver = max(currency.get("silver", 0.0), 0.0)
		currency.gold = max(currency.get("gold", 0.0), 0.0)
		currency.platinum = max(currency.get("platinum", 0.0), 0.0)

	# Validate resources
	level1_data.coal = max(level1_data.get("coal", 0.0), 0.0)
	level1_data.shovel_lvl = max(level1_data.get("shovel_lvl", 0), 0)
	level1_data.plow_lvl = max(level1_data.get("plow_lvl", 0), 0)

	return level1_data
```

---

## Integration Steps

### Step 1: Add ErrorHandler Autoload

**Modify**: `game/v0.1/project.godot`

```ini
[autoload]
ErrorHandler="*res://autoloads/error_handler.gd"
```

### Step 2: Use in NakamaClient

**Modify**: `game/v0.1/autoloads/nakama_client.gd`

Update `load_game()`:
```gdscript
func load_game() -> bool:
	if not is_authenticated:
		DebugLogger.error("Cannot load: Not authenticated", "NAKAMA")
		return false

	var save_data = await read_storage("player_data", "game_save")

	if not save_data:
		DebugLogger.info("No cloud save found - starting fresh", "NAKAMA")
		return false

	# Validate save data
	save_data = CloudSaveValidator.validate_save_data(save_data)

	if save_data.is_empty():
		DebugLogger.error("Save data invalid - starting fresh", "NAKAMA")
		Global.show_stat_notification("Save corrupted - starting fresh", "warning")
		return false

	# Apply validated data
	_set_global_data(save_data.global)
	_set_level1_vars_data(save_data.level1_vars)

	DebugLogger.info("Game loaded from cloud", "NAKAMA")
	return true
```

### Step 3: Use in Global

**Modify**: `game/v0.1/autoloads/global.gd`

Update `change_scene_with_check()`:
```gdscript
func change_scene_with_check(scene_tree: SceneTree, scene_path: String):
	# Save before scene change
	if NakamaClient.is_authenticated:
		await NakamaClient.save_game()

	# Check victory
	if check_victory_conditions():
		ErrorHandler.safe_change_scene(scene_tree, "res://victory.tscn")
		return

	# Check caught
	if not check_get_caught():
		ErrorHandler.safe_change_scene(scene_tree, scene_path)
```

---

## Usage Examples

### Safe Node Access
```gdscript
# Old (crashes if node missing):
var label = $HBoxContainer/Label

# New (returns null if missing):
var label = ErrorHandler.safe_get_node(self, "HBoxContainer/Label")
if label:
	label.text = "Hello"
```

### Safe Function Call
```gdscript
# Wrap risky operation
var result = ErrorHandler.safe_call(func():
	# Do something that might fail
	return expensive_calculation()
, "MyScript.expensive_calculation")

if result.success:
	print("Result: ", result.value)
else:
	print("Failed: ", result.error)
```

### Currency Operations
```gdscript
# In currency_manager.gd - validate inputs
func add_currency(currency_type: int, amount: float) -> void:
	if amount < 0:
		ErrorHandler.handle_error("CurrencyManager", "Negative amount: " + str(amount), ErrorHandler.Severity.MODERATE)
		return

	# Proceed with add...
```

---

## Testing

### Manual Tests

1. **Missing Node Test**:
   - Remove UI node from scene
   - Try to access it with `safe_get_node()`
   - Expected: Returns null, logs warning, no crash

2. **Invalid Scene Test**:
   - Try to change to non-existent scene
   - Expected: Falls back to loading screen, logs error

3. **Corrupted Save Test**:
   - Manually set negative currency in cloud save
   - Load game
   - Expected: Values clamped to 0, notification shown

4. **Missing Save Structure Test**:
   - Remove "global" key from cloud save
   - Load game
   - Expected: Starts fresh, notification shown

---

## Files to Create

1. `game/v0.1/autoloads/error_handler.gd` - Error handling autoload (~150 lines)
2. `game/v0.1/autoloads/cloud_save_validator.gd` - Save validation (~100 lines)

## Files to Modify

1. `game/v0.1/project.godot` - Add ErrorHandler autoload
2. `game/v0.1/autoloads/nakama_client.gd` - Add validation to load_game()
3. `game/v0.1/autoloads/global.gd` - Use safe_change_scene()
4. `game/v0.1/autoloads/currency_manager.gd` - Add input validation

---

## Dependencies

**Before This**:
- 1.x-simple-logging.md - DebugLogger must exist
- 1.x-nakama-server.md - NakamaClient save/load
- 1.x-global-autoload.md - Global.gd

**After This**:
- All future systems can use ErrorHandler for safety

---

## Success Criteria

- [ ] ErrorHandler autoload exists and loads
- [ ] `safe_call()` wraps function execution
- [ ] `safe_get_node()` returns null instead of crashing
- [ ] `safe_load_scene()` validates scene paths
- [ ] `safe_change_scene()` falls back on failure
- [ ] `CloudSaveValidator` validates save structure
- [ ] `CloudSaveValidator` clamps stats to >= 1.0
- [ ] `CloudSaveValidator` clamps currency to >= 0
- [ ] Invalid saves get validated on load
- [ ] Missing saves start fresh with notification
- [ ] Errors logged with appropriate severity
- [ ] No crashes from null references

---

## Notes

**Simplified Approach**:
- No error UI panels - use existing notification system
- No connection monitoring - that's in NakamaClient (see 1.x-nakama-server.md)
- No bug reporting integration - that's in 1.x-advanced-logging.md
- No recovery actions - just log and continue
- No error boundaries - just validate inputs where needed

**GDScript Limitations**:
- No try/catch in GDScript
- `safe_call()` can't catch runtime errors
- Focus on prevention: validate before operations
- Use `get_node_or_null()`, check for null
- Validate data bounds before processing

**Connection Status**:
- Moved to 1.x-nakama-server.md where it belongs
- NakamaClient tracks connection state
- Settings panel shows connection indicator
- See 1.x-nakama-server.md for implementation

---
