# Notifications System

**Goal**: Create unified notification system for displaying temporary messages with queueing and stat level-up feedback with variety

**Success Criteria**:
- `Global.show_notification(message, type)` API works
- Max 3 notifications visible simultaneously
- Queue system for 4+ notifications (FIFO, max 20 queued)
- Dynamic auto-removal timer (1 sec + 45ms per character)
- Stat level-up notifications with message variety (5 variants per stat)
- Works in both landscape and portrait orientations
- No animations (instant appear/disappear for performance)
- Type parameter stored for future visual differentiation

**Prerequisites**:
- Phase 1.3 (Global Autoload) - Global.gd exists
- Phase 1.11 (Responsive Layout) - NotificationBar defined, ResponsiveLayout.get_scaled_font_size() available

---

## Overview

Provides a centralized system for displaying temporary translucent notifications at the bottom of the screen (landscape) or between top menu and play area (portrait). Handles automatic stacking (max 3 visible), queueing for overflow, dynamic duration based on message length, and stat level-up feedback with variety. Designed for minimal performance impact with instant appearance/removal and clean memory management.

### Key Design Principles

- **Unified API**: Single function for all notification types
- **Performance first**: No animations, instant appear/disappear
- **Smart queueing**: Max 3 visible, max 20 queued (FIFO with overflow drop)
- **Orientation-aware**: Works in both landscape and portrait modes
- **Extensible**: Type parameter stored for future visual differentiation
- **Stat variety**: 5 message variants per stat to reduce repetition

---

## Architecture Overview

### Data Flow

```
Gameplay Event/Stat Level-Up
    |
    v
show_notification(message, type)
    |
    v
Check queue size (drop oldest if > 20)
    |
    v
Check visible count
    |
    v
If < 3: Display immediately
If >= 3: Add to notification_queue
    |
    v
Create Panel + Label + Timer
    |
    v
Add to NotificationBar (auto-stacks via VBoxContainer)
    |
    v
Timer expires -> Remove -> Check queue -> Display next
```

### Component Separation

- **This Plan (1.15)**: Notification display, queueing, stat variety
- **Plan 1.x-notification-history-panel**: History panel UI (future, optional)
- **Plan 1.8**: Stat system that triggers notifications on level-up
- **Plan 1.11**: Layout defines NotificationBar positioning and scaling

---

## Implementation Tasks

### 1. Notification Data Structures

**File**: `res://autoloads/global.gd`

**Variables needed**:
```gdscript
# ===== NOTIFICATION SYSTEM =====

# Currently visible notifications (max 3)
var active_notifications: Array[Dictionary] = []

# Queue for overflow (max 20, FIFO)
var notification_queue: Array[Dictionary] = []
const MAX_NOTIFICATION_QUEUE = 20

# Notification types (stored for future visual differentiation)
const NOTIFICATION_TYPE_INFO = "info"       # General messages
const NOTIFICATION_TYPE_STAT = "stat"       # Stat level-ups
const NOTIFICATION_TYPE_WARNING = "warning" # Warnings/errors
const NOTIFICATION_TYPE_SUCCESS = "success" # Achievements/milestones
```

**Dictionary Structure**:
```gdscript
# Active notification entry:
{
    "message": String,       # Text to display
    "type": String,          # Notification type constant
    "panel": Panel,          # UI panel node (null after scene change)
    "label": Label,          # Text label node
    "timer": Timer           # Auto-removal timer (child of Global)
}

# Queue entry (before displayed):
{
    "message": String,
    "type": String
}
```

---

### 2. Core Notification API

**Function**: `show_notification(message: String, type: String = NOTIFICATION_TYPE_INFO)`

```gdscript
func show_notification(message: String, type: String = NOTIFICATION_TYPE_INFO) -> void:
    # Create notification data
    var notification_data = {
        "message": message,
        "type": type
    }

    # Check if we can display immediately
    if active_notifications.size() < 3:
        _display_notification(notification_data)
    else:
        # Queue for later display (with overflow protection)
        if notification_queue.size() >= MAX_NOTIFICATION_QUEUE:
            notification_queue.pop_front()  # Drop oldest
        notification_queue.append(notification_data)
```

**Usage Examples**:
```gdscript
# General message (default type)
Global.show_notification("You've been caught!")

# Stat level-up (called from stat setters)
Global.show_notification("You feel stronger", Global.NOTIFICATION_TYPE_STAT)

# Warning
Global.show_notification("Low stamina!", Global.NOTIFICATION_TYPE_WARNING)

# Success
Global.show_notification("Achievement unlocked!", Global.NOTIFICATION_TYPE_SUCCESS)
```

---

### 3. Display Notification (Internal)

**Function**: `_display_notification(notification_data: Dictionary)`

```gdscript
func _display_notification(notification_data: Dictionary) -> void:
    # Find NotificationBar container (handles both orientations)
    var notification_bar = _find_notification_bar()
    if not notification_bar:
        push_warning("No NotificationBar found in current scene")
        return

    # Create panel
    var notification_panel = Panel.new()
    notification_panel.custom_minimum_size = Vector2(0, 40)  # Base height

    # Style panel (translucent dark background)
    var style_box = StyleBoxFlat.new()
    style_box.bg_color = Color(0.15, 0.15, 0.15, 0.4)  # Dark grey, 40% opacity
    style_box.corner_radius_top_left = 8
    style_box.corner_radius_top_right = 8
    style_box.corner_radius_bottom_left = 8
    style_box.corner_radius_bottom_right = 8
    style_box.content_margin_top = 5
    style_box.content_margin_bottom = 5
    style_box.content_margin_left = 10
    style_box.content_margin_right = 10
    style_box.expand_margin_top = 3  # Spacing between stacked notifications
    style_box.expand_margin_bottom = 3
    notification_panel.add_theme_stylebox_override("panel", style_box)

    # Create label
    var notification_label = Label.new()
    notification_label.text = notification_data.message
    notification_label.horizontal_alignment = HORIZONTAL_ALIGNMENT_CENTER
    notification_label.vertical_alignment = VERTICAL_ALIGNMENT_CENTER
    notification_label.add_theme_color_override("font_color", Color(1, 1, 1, 1))  # White
    notification_label.autowrap_mode = TextServer.AUTOWRAP_WORD_SMART

    # Fill panel (anchor to all edges)
    notification_label.anchor_left = 0
    notification_label.anchor_right = 1
    notification_label.anchor_top = 0
    notification_label.anchor_bottom = 1

    notification_panel.add_child(notification_label)

    # Create timer (dynamic duration: 1 sec base + 45ms per character)
    var notification_timer = Timer.new()
    notification_timer.one_shot = true
    notification_timer.wait_time = 1.0 + (notification_data.message.length() * 0.045)
    add_child(notification_timer)  # Child of Global (persists across scenes)

    # Update notification_data with UI references
    notification_data["panel"] = notification_panel
    notification_data["label"] = notification_label
    notification_data["timer"] = notification_timer

    # Add to active list
    active_notifications.append(notification_data)

    # Connect timer to removal
    notification_timer.timeout.connect(_remove_notification.bind(notification_data))

    # Add to scene
    notification_bar.add_child(notification_panel)

    # Apply responsive scaling (font size based on resolution and orientation)
    var scaled_font_size = ResponsiveLayout.get_scaled_font_size(get_viewport(), 25)
    notification_label.add_theme_font_size_override("font_size", scaled_font_size)

    # Scale panel height for portrait mode
    if ResponsiveLayout.is_portrait_mode(get_viewport()):
        var scaled_height = 40 * ResponsiveLayout.PORTRAIT_FONT_SCALE
        notification_panel.custom_minimum_size = Vector2(0, scaled_height)

    # Start timer
    notification_timer.start()
```

---

### 4. Remove Notification & Process Queue

**Function**: `_remove_notification(notification_data: Dictionary)`

```gdscript
func _remove_notification(notification_data: Dictionary) -> void:
    # Guard against invalid data or double-removal
    if not notification_data:
        return

    # Remove from active list
    var index = active_notifications.find(notification_data)
    if index != -1:
        active_notifications.remove_at(index)

    # Free UI nodes (with validity checks for scene changes)
    if notification_data.has("panel") and is_instance_valid(notification_data.panel):
        notification_data.panel.queue_free()
    if notification_data.has("timer") and is_instance_valid(notification_data.timer):
        notification_data.timer.queue_free()

    # Process queue if notifications waiting
    if notification_queue.size() > 0:
        var next_notification = notification_queue.pop_front()
        _display_notification(next_notification)
```

**Queue Logic**:
- FIFO (first in, first out)
- Max 20 queued (oldest dropped on overflow)
- When notification removed -> check queue -> display next
- `is_instance_valid()` handles scene changes gracefully

---

### 5. Find NotificationBar (Helper)

**Function**: `_find_notification_bar() -> Node`

```gdscript
func _find_notification_bar() -> Node:
    var current_scene = get_tree().current_scene
    if not current_scene:
        return null

    # Try landscape location (direct child of root)
    var notification_bar = current_scene.get_node_or_null("NotificationBar")
    if notification_bar:
        return notification_bar

    # Try portrait location (reparented by ResponsiveLayout into VBoxContainer)
    notification_bar = current_scene.get_node_or_null("VBoxContainer/NotificationBar")
    if notification_bar:
        return notification_bar

    return null
```

**Handles Both Orientations**:
- Landscape: `SceneRoot/NotificationBar` (direct child)
- Portrait: `SceneRoot/VBoxContainer/NotificationBar` (reparented by ResponsiveLayout)

---

### 6. Stat Notification Variants

**Stat Messages with Variety**:

```gdscript
# Stat message pools (3-5 variants each)
const STAT_MESSAGES = {
    "strength": [
        "You feel stronger",
        "Your muscles harden",
        "Power surges through you",
        "You can lift more weight",
        "Raw strength flows into your limbs"
    ],
    "dexterity": [
        "You feel more precise",
        "Your movements sharpen",
        "Agility comes naturally",
        "Your hands move with grace",
        "Reflexes quicken"
    ],
    "constitution": [
        "You feel more resilient",
        "Your body toughens",
        "Endurance wells up within",
        "You can withstand more",
        "Vitality courses through you"
    ],
    "intelligence": [
        "You feel smarter",
        "Clarity fills your mind",
        "Understanding deepens",
        "Patterns become clear",
        "Knowledge expands"
    ],
    "wisdom": [
        "You feel more introspective",
        "Insight dawns upon you",
        "Perception sharpens",
        "The world makes more sense",
        "Wisdom settles in"
    ],
    "charisma": [
        "You understand people better",
        "Social grace comes easier",
        "Others seem drawn to you",
        "Words flow more smoothly",
        "Presence strengthens"
    ]
}

func _get_stat_message(stat_name: String) -> String:
    """
    Get random message variant for stat level-up.
    Returns consistent message if stat not in pool.
    """
    var messages = STAT_MESSAGES.get(stat_name.to_lower(), [])
    if messages.is_empty():
        return "You feel improved"  # Fallback

    # Pick random variant
    return messages[randi() % messages.size()]
```

---

### 7. Stat Notification Integration

**Update stat setters in global.gd**:

```gdscript
# Example: Strength setter (update all six stats similarly)
var strength: int = 1:
    set(value):
        # Only notify on actual level-up (not fractional increases)
        if is_node_ready() and floor(value) > floor(strength):
            var message = _get_stat_message("strength")
            show_notification(message, NOTIFICATION_TYPE_STAT)
        strength = value

# Apply same pattern to: dexterity, constitution, intelligence, wisdom, charisma
```

**Key Change**: Use `floor(value) > floor(strength)` to only trigger on level-up, not every fractional XP increase.

**Before**: Simple hardcoded message on any increase
**After**: Random variant from pool, only on level-up, proper type parameter

---

## Testing Strategy

### Unit Tests

Create `tests/test_notifications.gd`:

```gdscript
extends GutTest

func before_each():
    Global.active_notifications.clear()
    Global.notification_queue.clear()

# Test: Show notification under max (< 3)
func test_show_notification_immediate():
    Global.show_notification("Test message")
    assert_eq(Global.active_notifications.size(), 1, "Notification added to active")

# Test: Queue overflow (4+ notifications)
func test_notification_queueing():
    Global.show_notification("Message 1")
    Global.show_notification("Message 2")
    Global.show_notification("Message 3")
    Global.show_notification("Message 4")  # Should queue

    assert_eq(Global.active_notifications.size(), 3, "Max 3 active")
    assert_eq(Global.notification_queue.size(), 1, "4th queued")

# Test: Queue overflow limit (max 20)
func test_queue_overflow_limit():
    # Fill active (3) + queue (20) + 5 more
    for i in range(28):
        Global.show_notification("Message %d" % i)

    assert_eq(Global.active_notifications.size(), 3, "Max 3 active")
    assert_eq(Global.notification_queue.size(), 20, "Queue capped at 20")

# Test: Timer duration calculation
func test_dynamic_duration():
    Global.show_notification("Short")
    var timer1 = Global.active_notifications[0].timer

    Global.show_notification("This is a much longer message with many characters")
    var timer2 = Global.active_notifications[1].timer

    assert_gt(timer2.wait_time, timer1.wait_time, "Longer message = longer duration")

# Test: Stat message variety
func test_stat_message_variety():
    var messages_seen = {}

    # Trigger 20 strength notifications
    for i in range(20):
        var msg = Global._get_stat_message("strength")
        messages_seen[msg] = true

    assert_gt(messages_seen.size(), 1, "Multiple message variants used")

# Test: Notification types
func test_notification_types():
    Global.show_notification("Info", Global.NOTIFICATION_TYPE_INFO)
    Global.show_notification("Stat", Global.NOTIFICATION_TYPE_STAT)

    assert_eq(Global.active_notifications[0].type, Global.NOTIFICATION_TYPE_INFO)
    assert_eq(Global.active_notifications[1].type, Global.NOTIFICATION_TYPE_STAT)
```

### Integration Tests

| Scenario | Setup | Action | Expected Result |
|----------|-------|--------|-----------------|
| Normal notification flow | 0 active | Show 1 notification | Appears immediately, timer starts |
| Queue processing | 3 active | Show 4th notification | 4th queued, appears after 1st expires |
| Queue overflow | 3 active, 20 queued | Show 25th notification | Oldest queued dropped, newest added |
| Stat level-up | STR=1, 0 XP | Add 100 XP | Random strength message appears |
| Portrait mode | Portrait orientation | Show notification | Panel height 70px, font scaled |

### Manual Test Criteria

- [ ] Show notification via console: `Global.show_notification("Test")`
- [ ] Notification appears at bottom (landscape) or between menus (portrait)
- [ ] Dark translucent background visible
- [ ] Auto-removes after ~1-2 seconds (based on length)
- [ ] Show 4 notifications rapidly: max 3 visible, 4th queued
- [ ] When 1st expires, 4th appears automatically
- [ ] Level up a stat: random message variant appears
- [ ] Level up same stat multiple times: see different messages
- [ ] Font scales correctly in landscape at 1080p (25px -> 37px)
- [ ] Font scales correctly in portrait (25px -> 44px)

---

## Files to Create

- None (uses existing global.gd and scene_template.tscn)

## Files to Modify

- `autoloads/global.gd` (~150 lines added)
  - Notification data structures (arrays, constants)
  - show_notification() API
  - _display_notification() internal
  - _remove_notification() and queue processing
  - _find_notification_bar() helper
  - STAT_MESSAGES constant pool
  - _get_stat_message() randomizer
  - Update all six stat setters to use floor() check and show_notification()

- `autoloads/responsive_layout.gd` (add helper function)
  - Add get_scaled_font_size() static function

---

## Design Values (Reference)

### Notification Dimensions

| Property | Value | Formula |
|----------|-------|---------|
| Panel height (base) | 40px | Set in code |
| Panel spacing | 6px | 3px expand top + 3px expand bottom |
| Corner radius | 8px | Rounded corners |
| Content margin | 5/10px | Top/bottom: 5px, Left/right: 10px |

**Scales with resolution** (via ResponsiveLayout):
- 1280x720: 40px panels, 25px font
- 1920x1080: 60px panels, 37px font (1.5x)

### Timing

| Parameter | Value | Rationale |
|-----------|-------|-----------|
| Base duration | 1 second | Minimum display time |
| Per-character duration | 0.045 seconds (45ms) | Longer messages stay longer |
| Max visible | 3 notifications | Fits in 120px bar (3×40px + spacing) |

**Examples**:
- "You feel stronger" (17 chars): 1 + (17 × 0.045) = 1.765 seconds
- "Achievement unlocked!" (22 chars): 1 + (22 × 0.045) = 1.99 seconds
- "Very long message..." (50 chars): 1 + (50 × 0.045) = 3.25 seconds

### Colors

| Element | Color | Opacity | Hex |
|---------|-------|---------|-----|
| Background | Dark grey | 40% | rgba(38, 38, 38, 0.4) |
| Text | White | 100% | #FFFFFF |

**Future types** (not implemented yet):
- INFO: Dark grey background (current)
- STAT: Could add blue tint
- WARNING: Could add orange tint
- SUCCESS: Could add green tint

### Stat Message Pools

Each stat has **5 variants** to reduce repetition:
- Strength: 5 messages
- Dexterity: 5 messages
- Constitution: 5 messages
- Intelligence: 5 messages
- Wisdom: 5 messages
- Charisma: 5 messages

**Random selection**: `randi() % messages.size()`

---

## Dependencies & Integration

### Depends On:
- Phase 1.3 (Global Autoload) - Global.gd exists
- Phase 1.11 (Responsive Layout) - NotificationBar positioning, ResponsiveLayout.get_scaled_font_size()

### Used By:
- **Plan 1.8** (Stats & Experience) - Stat setters call show_notification()
- **All gameplay features** - Generic notification API for events

### Provides APIs For:

**Gameplay Code**:
```gdscript
Global.show_notification(message, type)  # Display notification
```

**Stat System** (internal):
```gdscript
Global._get_stat_message(stat_name)  # Random variant for level-ups
```

---

## Notes & Decisions

**Decision 1**: Max 3 visible notifications
- **Rationale**: Fits perfectly in notification bar (3×40px + spacing = ~130px < 120px scaled bar)
- **Benefit**: Clean UI, no overflow outside designated area

**Decision 2**: Queue system (not replacement)
- **Rationale**: Don't lose notifications, show all eventually
- **Benefit**: User sees all messages in order
- **Alternative considered**: Replace oldest with newest (rejected - losing information is bad)

**Decision 3**: Stat message variety (5 variants each)
- **Rationale**: Reduces repetition without overwhelming content creation
- **Benefit**: Feels less robotic, more game-like
- **Alternative considered**: Single message (rejected - too repetitive), 10+ variants (rejected - diminishing returns)

**Decision 4**: No animations
- **Rationale**: Performance, simplicity, instant feedback
- **Benefit**: Zero performance overhead, crisp appearance
- **Alternative considered**: Fade in/out (rejected - adds complexity, requires tweens)

**Decision 5**: Type parameter stored as String constant
- **Rationale**: Easy to add visual differences later (colors, icons)
- **Implementation**: String constants now, visual styling deferred
- **Benefit**: Simple, no enum complexity, easy to extend

**Decision 6**: Queue overflow protection (max 20)
- **Rationale**: Prevents unbounded memory growth if notifications spam
- **Implementation**: Drop oldest queued when limit exceeded
- **Benefit**: Memory safety without losing recent notifications

**Decision 7**: Scene change safety with is_instance_valid()
- **Rationale**: Panels destroyed on scene change, timers persist in Global
- **Implementation**: Check node validity before queue_free()
- **Benefit**: No errors when timer fires after scene change

---

## Implementation Checklist

Before marking this phase complete:

- [ ] Notification data structures added (active, queue, constants)
- [ ] show_notification() API implemented with queue overflow protection
- [ ] _display_notification() creates panels and labels
- [ ] _remove_notification() cleans up with is_instance_valid() checks
- [ ] Max 3 visible enforced
- [ ] Max 20 queued enforced (FIFO with overflow drop)
- [ ] _find_notification_bar() handles both orientations
- [ ] STAT_MESSAGES pool created (5 variants per stat)
- [ ] _get_stat_message() randomizer implemented
- [ ] All six stat setters updated with floor() check and show_notification()
- [ ] Dynamic timer works (1 sec + 45ms per char)
- [ ] Portrait mode scaling works (panel height 70px, font 44px)
- [ ] Landscape font scaling works (25px -> 37px at 1080p)
- [ ] ResponsiveLayout.get_scaled_font_size() helper added
- [ ] Unit tests written and passing
- [ ] Integration tests verified
- [ ] Manual tests completed
- [ ] No memory leaks (queue_free() called correctly)

---

**Last Updated**: 2026-01-01
