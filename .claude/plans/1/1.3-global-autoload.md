# Global Autoload

**Goal**: Establish Global.gd as the core autoload with stats system, experience tracking, scene management, and foundational game state

**Success Criteria**:
- Global.gd autoload created and registered in project.godot
- Six-stat system implemented (STR, DEX, CON, INT, WIS, CHA)
- Experience system with configurable leveling curve
- Scene management with transition validation
- Version management for save compatibility
- Global error handling system
- Settings persistence (audio, graphics) separate from game saves
- All systems testable via unit tests

**Prerequisites**:
- Phase 1.1: Project Setup (Godot 4.5 project exists)
- Phase 1.2: Project Architecture (folder structure established)

---

## Overview

**IMPORTANT: Complete Rewrite Context**
This plan is part of a complete game rewrite. Legacy files (current global.gd, level_1_vars.gd) will be replaced with a new clean architecture. Do not worry about maintaining backward compatibility with old save files or systems.

The Global autoload serves as the foundational singleton for core game systems that persist across all scenes and levels. This phase establishes the essential systems that every other feature will depend on.

### Key Design Principles

- **Separation of Concerns**: Global handles core state, not game-specific logic
- **Extensible Architecture**: Easy to add new stats or systems later
- **Clean Dependencies**: Other autoloads can depend on Global, but Global depends on nothing
- **Developer-Friendly**: Clear APIs, good logging, easy to debug
- **Modular Systems**: Each major system (stats, experience, scenes) is self-contained

---

## Architecture Decision: Multiple Autoloads

### Recommended Structure

Instead of one massive Global.gd file (668 lines in legacy), split into focused autoloads:

1. **Global.gd** (~200-250 lines)
   - Six-stat system
   - Experience system
   - Scene management
   - Version management
   - Basic notification interface

2. **SettingsManager.gd** (~150-200 lines)
   - Audio settings (music, SFX volumes)
   - Graphics settings (fullscreen, resolution, quality)
   - Settings persistence (separate from game saves)

3. **ErrorHandler.gd** (~100-150 lines)
   - Global error catching
   - Error logging to file
   - User-friendly error messages
   - Crash recovery

4. **DevTools.gd** (~100-150 lines, dev-mode only)
   - Performance monitoring (FPS, memory)
   - Debug overlay
   - Cheat codes
   - Developer utilities

### Autoload Registration Order (project.godot)

```ini
[autoload]

ErrorHandler="*res://autoloads/error_handler.gd"      # First - catches all errors
Global="*res://autoloads/global.gd"                   # Second - core game state
SettingsManager="*res://autoloads/settings_manager.gd" # Third - player preferences
DevTools="*res://autoloads/dev_tools.gd"              # Last - development utilities
```

**Rationale**: ErrorHandler loads first to catch errors during other autoloads' initialization. Global loads second so all other systems can depend on it. SettingsManager and DevTools load last.

---

## Implementation Tasks

### 1. Global.gd - Core Game State

The heart of the game's persistent state system.

**File Location**: `res://autoloads/global.gd`

**Variables needed**:
```gdscript
extends Node

# ===== VERSION MANAGEMENT =====
const GAME_VERSION = "2.0.0"  # Semantic versioning: MAJOR.MINOR.PATCH
const SAVE_VERSION = 1         # Increment when save structure changes

# ===== SIX-STAT SYSTEM =====
# Stats with setters to detect changes
var strength: int = 1:
	set(value):
		if is_node_ready() and value > strength:
			show_notification("You feel stronger")
		strength = value

var dexterity: int = 1:
	set(value):
		if is_node_ready() and value > dexterity:
			show_notification("You feel more precise")
		dexterity = value

var constitution: int = 1:
	set(value):
		if is_node_ready() and value > constitution:
			show_notification("You feel more resilient")
		constitution = value

var intelligence: int = 1:
	set(value):
		if is_node_ready() and value > intelligence:
			show_notification("You feel smarter")
		intelligence = value

var wisdom: int = 1:
	set(value):
		if is_node_ready() and value > wisdom:
			show_notification("You feel more introspective")
		wisdom = value

var charisma: int = 1:
	set(value):
		if is_node_ready() and value > charisma:
			show_notification("You understand people better")
		charisma = value

# ===== EXPERIENCE SYSTEM =====
# Experience tracking per stat
var strength_exp: float = 0.0
var dexterity_exp: float = 0.0
var constitution_exp: float = 0.0
var intelligence_exp: float = 0.0
var wisdom_exp: float = 0.0
var charisma_exp: float = 0.0

# Experience curve configuration
const BASE_XP_FOR_LEVEL = 100.0
const EXP_SCALING = 1.8  # 1.5 = gentle, 2.0 = balanced, 2.5 = steep

# ===== SCENE MANAGEMENT =====
var current_scene_path: String = ""
var previous_scene_path: String = ""
var scene_transition_in_progress: bool = false

# ===== UI SETTINGS =====
var ui_scale: float = 1.0  # User preference for UI scaling (used by ResponsiveLayout)
```

**Core Functions**:

```gdscript
# ===== VERSION MANAGEMENT =====

func get_version_string() -> String:
	return GAME_VERSION

func get_save_version() -> int:
	return SAVE_VERSION

func is_save_compatible(save_version: int) -> bool:
	# Same save version = compatible
	# Future versions: add migration logic here
	return save_version == SAVE_VERSION

# ===== EXPERIENCE SYSTEM =====

# Calculate XP needed for a specific level
func get_xp_for_level(level: int) -> float:
	if level <= 1:
		return 0.0
	return BASE_XP_FOR_LEVEL * pow(level - 1, EXP_SCALING)

# Add experience to a stat and handle level-ups
func add_stat_exp(stat_name: String, amount: float) -> void:
	var stat_data = _get_stat_data(stat_name)
	if not stat_data:
		push_error("Invalid stat name: " + stat_name)
		return

	# Add experience
	set(stat_data.exp_var, get(stat_data.exp_var) + amount)

	# Check for level up(s)
	_check_level_up(stat_name)

# Check if stat should level up (can level multiple times)
func _check_level_up(stat_name: String) -> void:
	var stat_data = _get_stat_data(stat_name)
	if not stat_data:
		return

	var current_level = get(stat_data.stat_var)
	var current_exp = get(stat_data.exp_var)

	# Keep leveling up while we have enough XP
	while current_exp >= get_xp_for_level(current_level + 1):
		current_level += 1
		set(stat_data.stat_var, current_level)
		# Setter will trigger notification automatically

# Get progress toward next level (0.0 to 1.0)
func get_stat_level_progress(stat_name: String) -> float:
	var stat_data = _get_stat_data(stat_name)
	if not stat_data:
		return 0.0

	var current_level = get(stat_data.stat_var)
	var current_exp = get(stat_data.exp_var)
	var xp_for_current = get_xp_for_level(current_level)
	var xp_for_next = get_xp_for_level(current_level + 1)
	var xp_in_level = current_exp - xp_for_current
	var xp_needed_in_level = xp_for_next - xp_for_current

	if xp_needed_in_level <= 0:
		return 1.0

	return clamp(xp_in_level / xp_needed_in_level, 0.0, 1.0)

# Helper: Get stat variable names for dynamic access
func _get_stat_data(stat_name: String) -> Dictionary:
	var stat_map = {
		"strength": {"stat_var": "strength", "exp_var": "strength_exp"},
		"dexterity": {"stat_var": "dexterity", "exp_var": "dexterity_exp"},
		"constitution": {"stat_var": "constitution", "exp_var": "constitution_exp"},
		"intelligence": {"stat_var": "intelligence", "exp_var": "intelligence_exp"},
		"wisdom": {"stat_var": "wisdom", "exp_var": "wisdom_exp"},
		"charisma": {"stat_var": "charisma", "exp_var": "charisma_exp"}
	}
	return stat_map.get(stat_name.to_lower(), {})

# ===== SCENE MANAGEMENT =====

# Change scene with validation and tracking
func change_scene(scene_path: String) -> void:
	if scene_transition_in_progress:
		push_warning("Scene transition already in progress")
		return

	if not ResourceLoader.exists(scene_path):
		push_error("Scene does not exist: " + scene_path)
		return

	scene_transition_in_progress = true
	previous_scene_path = current_scene_path
	current_scene_path = scene_path

	get_tree().change_scene_to_file(scene_path)

	# Reset flag after scene loads
	await get_tree().process_frame
	scene_transition_in_progress = false

# Return to previous scene
func go_back() -> void:
	if previous_scene_path.is_empty():
		push_warning("No previous scene to return to")
		return

	change_scene(previous_scene_path)

# ===== NOTIFICATION SYSTEM =====
# Note: Basic interface only - full implementation in separate Notification plan

func show_notification(message: String) -> void:
	# Temporary implementation: print to console
	# Will be replaced with visual notification system in Phase 1.X
	print("[NOTIFICATION] " + message)

	# TODO: Phase 1.X - Implement visual notification panels
	# - Create notification UI
	# - Add to notification queue
	# - Auto-dismiss after duration

# ===== RESET & INITIALIZATION =====

func reset_stats() -> void:
	strength = 1
	dexterity = 1
	constitution = 1
	intelligence = 1
	wisdom = 1
	charisma = 1

	strength_exp = 0.0
	dexterity_exp = 0.0
	constitution_exp = 0.0
	intelligence_exp = 0.0
	wisdom_exp = 0.0
	charisma_exp = 0.0

func _ready() -> void:
	print("Global autoload initialized (v%s)" % GAME_VERSION)
```

---

### 2. SettingsManager.gd - Player Preferences

Handles player settings separate from game save data.

**File Location**: `res://autoloads/settings_manager.gd`

**Variables needed**:
```gdscript
extends Node

# ===== AUDIO SETTINGS =====
var music_volume: float = 0.8:  # 0.0 to 1.0
	set(value):
		music_volume = clamp(value, 0.0, 1.0)
		_apply_audio_settings()

var sfx_volume: float = 1.0:  # 0.0 to 1.0
	set(value):
		sfx_volume = clamp(value, 0.0, 1.0)
		_apply_audio_settings()

var music_muted: bool = false:
	set(value):
		music_muted = value
		_apply_audio_settings()

var sfx_muted: bool = false:
	set(value):
		sfx_muted = value
		_apply_audio_settings()

# ===== GRAPHICS SETTINGS =====
var fullscreen: bool = false:
	set(value):
		fullscreen = value
		_apply_graphics_settings()

var vsync_enabled: bool = true:
	set(value):
		vsync_enabled = value
		_apply_graphics_settings()

var quality_preset: String = "medium":  # "low", "medium", "high"
	set(value):
		if value in ["low", "medium", "high"]:
			quality_preset = value
			_apply_graphics_settings()

# ===== SETTINGS FILE =====
const SETTINGS_PATH = "user://settings.json"
```

**Core Functions**:
```gdscript
func _ready() -> void:
	load_settings()
	_apply_audio_settings()
	_apply_graphics_settings()

# Apply audio settings to audio buses
func _apply_audio_settings() -> void:
	var music_bus = AudioServer.get_bus_index("Music")
	var sfx_bus = AudioServer.get_bus_index("SFX")

	if music_bus >= 0:
		AudioServer.set_bus_mute(music_bus, music_muted)
		AudioServer.set_bus_volume_db(music_bus, linear_to_db(music_volume))

	if sfx_bus >= 0:
		AudioServer.set_bus_mute(sfx_bus, sfx_muted)
		AudioServer.set_bus_volume_db(sfx_bus, linear_to_db(sfx_volume))

# Apply graphics settings
func _apply_graphics_settings() -> void:
	# Fullscreen
	if fullscreen:
		DisplayServer.window_set_mode(DisplayServer.WINDOW_MODE_FULLSCREEN)
	else:
		DisplayServer.window_set_mode(DisplayServer.WINDOW_MODE_WINDOWED)

	# VSync
	if vsync_enabled:
		DisplayServer.window_set_vsync_mode(DisplayServer.VSYNC_ENABLED)
	else:
		DisplayServer.window_set_vsync_mode(DisplayServer.VSYNC_DISABLED)

	# Quality presets
	match quality_preset:
		"low":
			# Disable shadows, reduce effects
			pass
		"medium":
			# Balanced settings
			pass
		"high":
			# Max quality
			pass

# Save settings to file
func save_settings() -> void:
	var settings_data = {
		"music_volume": music_volume,
		"sfx_volume": sfx_volume,
		"music_muted": music_muted,
		"sfx_muted": sfx_muted,
		"fullscreen": fullscreen,
		"vsync_enabled": vsync_enabled,
		"quality_preset": quality_preset
	}

	var file = FileAccess.open(SETTINGS_PATH, FileAccess.WRITE)
	if file:
		file.store_string(JSON.stringify(settings_data, "\t"))
		file.close()

# Load settings from file
func load_settings() -> void:
	if not FileAccess.file_exists(SETTINGS_PATH):
		return  # Use defaults

	var file = FileAccess.open(SETTINGS_PATH, FileAccess.READ)
	if file:
		var json_string = file.get_as_text()
		file.close()

		var json = JSON.new()
		var parse_result = json.parse(json_string)

		if parse_result == OK:
			var data = json.data
			music_volume = data.get("music_volume", 0.8)
			sfx_volume = data.get("sfx_volume", 1.0)
			music_muted = data.get("music_muted", false)
			sfx_muted = data.get("sfx_muted", false)
			fullscreen = data.get("fullscreen", false)
			vsync_enabled = data.get("vsync_enabled", true)
			quality_preset = data.get("quality_preset", "medium")
```

---

### 3. ErrorHandler.gd - Global Error Management

Catches and logs all errors, provides graceful degradation.

**File Location**: `res://autoloads/error_handler.gd`

**Variables needed**:
```gdscript
extends Node

const ERROR_LOG_PATH = "user://error_log.txt"
const MAX_LOG_SIZE = 1024 * 100  # 100 KB

var errors_logged: int = 0
var last_error_time: int = 0
```

**Core Functions**:
```gdscript
func _ready() -> void:
	# Connect to Godot's error handler
	# Note: Can't fully override engine errors, but can catch script errors
	print("ErrorHandler initialized - logging to " + ERROR_LOG_PATH)

# Log an error to file
func log_error(error_message: String, stack_trace: String = "") -> void:
	errors_logged += 1
	last_error_time = Time.get_unix_time_from_system()

	var timestamp = Time.get_datetime_string_from_system()
	var log_entry = "[%s] ERROR #%d: %s\n" % [timestamp, errors_logged, error_message]

	if not stack_trace.is_empty():
		log_entry += "Stack trace:\n%s\n" % stack_trace

	log_entry += "---\n"

	_append_to_log(log_entry)

	# Also print to console
	push_error(error_message)

# Log a warning (non-critical)
func log_warning(warning_message: String) -> void:
	var timestamp = Time.get_datetime_string_from_system()
	var log_entry = "[%s] WARNING: %s\n" % [timestamp, warning_message]

	_append_to_log(log_entry)
	push_warning(warning_message)

# Append to error log file
func _append_to_log(entry: String) -> void:
	# Check file size, rotate if too large
	if FileAccess.file_exists(ERROR_LOG_PATH):
		var file_size = FileAccess.get_file_as_string(ERROR_LOG_PATH).length()
		if file_size > MAX_LOG_SIZE:
			_rotate_log()

	var file = FileAccess.open(ERROR_LOG_PATH, FileAccess.READ_WRITE)
	if file:
		file.seek_end()
		file.store_string(entry)
		file.close()

# Rotate log file when it gets too large
func _rotate_log() -> void:
	var old_log = ERROR_LOG_PATH.replace(".txt", "_old.txt")

	# Delete old backup if exists
	if FileAccess.file_exists(old_log):
		DirAccess.remove_absolute(old_log)

	# Rename current to old
	DirAccess.rename_absolute(ERROR_LOG_PATH, old_log)

# Get recent errors (for debug UI)
func get_recent_errors(count: int = 10) -> Array:
	if not FileAccess.file_exists(ERROR_LOG_PATH):
		return []

	var file = FileAccess.open(ERROR_LOG_PATH, FileAccess.READ)
	if not file:
		return []

	var lines = file.get_as_text().split("\n")
	file.close()

	# Get last N errors (each error is multiple lines, so this is approximate)
	var recent = []
	for i in range(max(0, lines.size() - count * 5), lines.size()):
		recent.append(lines[i])

	return recent
```

---

### 4. DevTools.gd - Development Utilities

Debug overlay, performance monitoring, cheat codes.

**File Location**: `res://autoloads/dev_tools.gd`

**Variables needed**:
```gdscript
extends Node

# ===== DEV MODE =====
var dev_mode_enabled: bool = OS.is_debug_build()  # Auto-enable in debug builds

# ===== PERFORMANCE MONITORING =====
var show_performance_overlay: bool = false
var fps_history: Array[float] = []
const FPS_HISTORY_SIZE = 60

var performance_overlay: Control = null

# ===== CHEAT CODES =====
var cheats_enabled: bool = false
```

**Core Functions**:
```gdscript
func _ready() -> void:
	if not dev_mode_enabled:
		return  # Don't load dev tools in production

	print("DevTools initialized (dev mode)")

	# Create performance overlay
	_create_performance_overlay()

func _process(_delta: float) -> void:
	if not dev_mode_enabled:
		return

	# Update FPS tracking
	var current_fps = Engine.get_frames_per_second()
	fps_history.append(current_fps)
	if fps_history.size() > FPS_HISTORY_SIZE:
		fps_history.pop_front()

	# Update overlay if visible
	if show_performance_overlay and performance_overlay:
		_update_performance_overlay()

# Toggle performance overlay
func toggle_performance_overlay() -> void:
	show_performance_overlay = not show_performance_overlay
	if performance_overlay:
		performance_overlay.visible = show_performance_overlay

# Create performance overlay UI
func _create_performance_overlay() -> void:
	performance_overlay = Control.new()
	performance_overlay.name = "PerformanceOverlay"
	performance_overlay.visible = show_performance_overlay

	# Position in top-left corner
	performance_overlay.anchor_right = 0
	performance_overlay.anchor_bottom = 0
	performance_overlay.offset_right = 200
	performance_overlay.offset_bottom = 150

	var label = Label.new()
	label.name = "StatsLabel"
	performance_overlay.add_child(label)

	# Add to root (so it appears over all scenes)
	# Use call_deferred to avoid "parent busy setting up children" error
	get_tree().root.call_deferred("add_child", performance_overlay)

# Update performance overlay text
func _update_performance_overlay() -> void:
	var label = performance_overlay.get_node("StatsLabel")
	if not label:
		return

	var avg_fps = 0.0
	for fps in fps_history:
		avg_fps += fps
	avg_fps /= fps_history.size()

	var memory_usage = OS.get_static_memory_usage() / 1024.0 / 1024.0  # MB

	label.text = "FPS: %d (avg: %.1f)\n" % [Engine.get_frames_per_second(), avg_fps]
	label.text += "Memory: %.1f MB\n" % memory_usage
	label.text += "Objects: %d\n" % Performance.get_monitor(Performance.OBJECT_COUNT)

# Give experience to stat (cheat)
func cheat_add_stat_exp(stat_name: String, amount: float) -> void:
	if not cheats_enabled:
		return

	Global.add_stat_exp(stat_name, amount)
	print("CHEAT: Added %d XP to %s" % [amount, stat_name])

# Set stat to specific level (cheat)
func cheat_set_stat_level(stat_name: String, level: int) -> void:
	if not cheats_enabled:
		return

	var stat_data = Global._get_stat_data(stat_name)
	if stat_data:
		Global.set(stat_data.stat_var, level)
		print("CHEAT: Set %s to level %d" % [stat_name, level])
```

---

## Testing Strategy

### Unit Tests (Headless)

Create `tests/test_phase_1_3_global.gd`:

```gdscript
extends GutTest

# Test: Experience system calculates XP correctly
func test_xp_calculation():
	# Level 1 -> 2 should need BASE_XP
	assert_eq(Global.get_xp_for_level(2), Global.BASE_XP_FOR_LEVEL)

	# Level 2 -> 3 should scale
	var xp_level_3 = Global.BASE_XP_FOR_LEVEL * pow(2, Global.EXP_SCALING)
	assert_almost_eq(Global.get_xp_for_level(3), xp_level_3, 0.1)

# Test: Adding experience levels up stat
func test_stat_level_up():
	Global.reset_stats()

	# Add enough XP to level up
	var xp_needed = Global.get_xp_for_level(2)
	Global.add_stat_exp("strength", xp_needed)

	assert_eq(Global.strength, 2)

# Test: Progress calculation works
func test_level_progress():
	Global.reset_stats()

	# Add half the XP needed for level 2
	var half_xp = Global.get_xp_for_level(2) / 2.0
	Global.add_stat_exp("dexterity", half_xp)

	var progress = Global.get_stat_level_progress("dexterity")
	assert_almost_eq(progress, 0.5, 0.1)

# Test: Scene management tracks paths
func test_scene_tracking():
	Global.current_scene_path = "res://test_scene_a.tscn"
	Global.change_scene("res://test_scene_b.tscn")

	assert_eq(Global.previous_scene_path, "res://test_scene_a.tscn")
	assert_eq(Global.current_scene_path, "res://test_scene_b.tscn")

# Test: Settings save and load
func test_settings_persistence():
	SettingsManager.music_volume = 0.5
	SettingsManager.fullscreen = true
	SettingsManager.save_settings()

	# Reset values
	SettingsManager.music_volume = 1.0
	SettingsManager.fullscreen = false

	# Load should restore
	SettingsManager.load_settings()
	assert_eq(SettingsManager.music_volume, 0.5)
	assert_eq(SettingsManager.fullscreen, true)
```

**Run tests:**
```bash
godot --headless --script res://addons/gut/gut_cmdln.gd -gtest=tests/test_phase_1_3_global.gd
```

### Integration Tests

| Scenario | Setup | Action | Expected Result |
|----------|-------|--------|-----------------|
| Stat level up notification | strength = 1 | Add 100 XP to strength | Notification "You feel stronger" shown |
| Multiple level ups | strength = 1 | Add 500 XP | Strength = 3+ (multiple levels) |
| Settings persist across sessions | Set music to 0.3 | Save, restart, load | Music volume = 0.3 |
| Error logging works | Trigger script error | Check error_log.txt | Error logged with timestamp |
| Scene transitions | In scene A | change_scene(B) | Previous = A, Current = B |

### Manual Test Criteria

- [ ] Stats display correctly in UI (when UI created)
- [ ] Stat level up notifications appear and auto-dismiss
- [ ] Audio settings immediately affect game audio
- [ ] Fullscreen toggle works smoothly
- [ ] Performance overlay shows accurate FPS
- [ ] Cheat codes work in dev mode only
- [ ] Error log file created on first error
- [ ] Settings file created in user:// directory

---

## Files to Create

- `res://autoloads/global.gd` - Core game state autoload
- `res://autoloads/settings_manager.gd` - Player preferences autoload
- `res://autoloads/error_handler.gd` - Error management autoload
- `res://autoloads/dev_tools.gd` - Development utilities autoload
- `tests/test_phase_1_3_global.gd` - Unit test suite

## Files to Modify

- `project.godot` - Add autoload registrations:
  ```ini
  [autoload]

  ErrorHandler="*res://autoloads/error_handler.gd"
  Global="*res://autoloads/global.gd"
  SettingsManager="*res://autoloads/settings_manager.gd"
  DevTools="*res://autoloads/dev_tools.gd"
  ```

- `default_bus_layout.tres` - Add audio buses:
  - Master bus (default)
  - Music bus (child of Master)
  - SFX bus (child of Master)

---

## Design Values (Reference)

### Experience System

- **Base XP for Level 2**: 100 XP
- **Scaling Factor**: 1.8 (balanced curve)
  - Level 1→2: 100 XP
  - Level 2→3: 180 XP
  - Level 3→4: 324 XP
  - Level 4→5: 583 XP
  - Level 5→6: 1,050 XP
  - Level 10: ~5,000 XP total
  - Level 20: ~50,000 XP total

**Rationale**: Gentle enough for early progression, steep enough to feel meaningful

### Audio Settings

- **Default Music Volume**: 80% (0.8)
- **Default SFX Volume**: 100% (1.0)
- **Volume Range**: 0.0 to 1.0 (0% to 100%)

### Graphics Settings

- **Quality Presets**:
  - Low: Minimal effects, performance priority
  - Medium: Balanced (default)
  - High: Maximum quality
- **Default VSync**: Enabled (prevent screen tearing)
- **Default Fullscreen**: Disabled (windowed mode)

### Performance Monitoring

- **FPS History**: 60 frames (1 second at 60 FPS)
- **Log Rotation Size**: 100 KB
- **Performance Overlay Position**: Top-left corner

---

## Dependencies & Integration

### Depends On:
- Phase 1.1 (Project Setup) - Godot project must exist
- Phase 1.2 (Project Architecture) - Folder structure must be established

### Used By:
- Phase 1.4+ (All future features) - Everything depends on Global stats
- Save System - Serializes Global state
- UI Systems - Display stats, settings
- Gameplay Systems - Award experience, check stat levels

### Provides APIs For:
- `Global.add_stat_exp(stat_name, amount)` - Award experience
- `Global.get_stat_level_progress(stat_name)` - Get XP progress
- `Global.change_scene(path)` - Navigate between scenes
- `Global.show_notification(message)` - Display notifications
- `SettingsManager.save_settings()` - Persist player preferences
- `ErrorHandler.log_error(message)` - Log errors to file

---

## Extension Points (Future Features)

This architecture is designed to be extended easily:

### Stat-Related Extensions
- **Stat Bonuses**: Add temporary/permanent modifiers
- **Stat Caps**: Maximum stat levels per phase
- **Stat Synergies**: Bonuses when multiple stats are high
- **Alternative XP Curves**: Different scaling per stat

### Scene Management Extensions
- **Scene Network Map**: Valid transitions graph
- **Transition Effects**: Fade, wipe, custom animations
- **Loading Screens**: For heavy scenes
- **Scene History Stack**: Navigate back through history

### Settings Extensions
- **Keybindings**: Custom input mapping
- **Language Selection**: Localization support
- **Accessibility**: Colorblind modes, text size
- **Cloud Settings Sync**: Sync settings across devices

### Error Handling Extensions
- **Crash Reports**: Send to server for analytics
- **Auto-Recovery**: Restore from backup saves
- **Error Categories**: Gameplay vs system errors
- **User Reporting**: In-game bug report tool

---

## Balance Tuning Notes

### Experience Curve Tuning

**Tuneable Parameters:**
- `BASE_XP_FOR_LEVEL` in global.gd - Affects overall leveling speed
- `EXP_SCALING` in global.gd - Affects curve steepness

**Expected Player Progression:**
- **First 5 minutes**: Reach level 2-3 in primary stat (quick feedback)
- **First 30 minutes**: Level 5-6 in primary stat
- **First 2 hours**: Level 10+ in primary stat, 3-5 in secondary stats

**Warning Signs:**
- If players hit level 10 in < 30 minutes → increase BASE_XP or SCALING
- If players stuck at level 2-3 for > 10 minutes → decrease BASE_XP or SCALING
- If late-game levels feel impossible → decrease SCALING

### Stat Balance

Each stat should feel valuable:
- **Strength**: Physical power, carrying capacity
- **Dexterity**: Precision, speed, evasion
- **Constitution**: Health, stamina, resilience
- **Intelligence**: Learning, crafting, problem-solving
- **Wisdom**: Insight, perception, judgment
- **Charisma**: Persuasion, pricing, social interactions

**Balance Goal**: No "dump stat" - all should have meaningful gameplay impact

---

## Notes & Decisions

**Decision 1**: Split Global into 4 autoloads instead of 1 monolithic file
- **Rationale**: Separation of concerns, easier to maintain and test
- **Trade-off**: More files, but each has clear purpose
- **Benefit**: Can load ErrorHandler first to catch initialization errors

**Decision 2**: Settings separate from game saves
- **Rationale**: Player preferences shouldn't reset when game resets
- **Benefit**: QoL - audio/graphics persist across save deletions
- **Implementation**: Separate `user://settings.json` file

**Decision 3**: Dev tools only active in debug builds
- **Rationale**: Performance overhead minimal but unnecessary in production
- **Benefit**: Cleaner production builds, no cheat code exposure
- **Check**: `OS.is_debug_build()` determines availability

**Decision 4**: Experience curve uses power function
- **Rationale**: Flexible tuning, common in RPGs, feels natural
- **Formula**: `BASE_XP * (level - 1) ^ SCALING`
- **Alternative considered**: Linear (too flat), exponential (too steep)

**Decision 5**: Notification system placeholder in Global
- **Rationale**: Full system deserves dedicated plan (Phase 1.X)
- **Current**: Basic print() implementation
- **Future**: Visual panels with queuing, priority, categories

**Decision 6**: Version management from day one
- **Rationale**: Easier to add now than retrofit later
- **Benefit**: Save migration support as game evolves
- **Cost**: Minimal - just two constants and one check function

---

## Open Questions

- [ ] Should stats have a maximum level cap? (If so, what and why?)
- [ ] Should experience curve be different for different stats?
- [ ] Do we need stat reset/respec functionality?
- [ ] Should settings sync to cloud (if player has account)?
- [ ] Should error logs be sent to analytics server?
- [ ] Do we want player-facing "stats" screen showing XP progress?

---

## Implementation Checklist

Before marking this phase complete:

- [ ] `autoloads/` folder created
- [ ] Global.gd implemented with all stat functions
- [ ] SettingsManager.gd implemented with save/load
- [ ] ErrorHandler.gd implemented with file logging
- [ ] DevTools.gd implemented with performance overlay
- [ ] All autoloads registered in project.godot
- [ ] Audio buses created (Master, Music, SFX)
- [ ] Unit tests written and passing
- [ ] Integration tests completed
- [ ] Manual tests verified
- [ ] Settings file saves to user:// correctly
- [ ] Error log file created on first error
- [ ] Performance overlay toggles with F3 (or chosen key)
- [ ] Code reviewed for clarity and maintainability
- [ ] Documentation updated (if applicable)

---

**Last Updated**: 2025-11-28
**Maintainer**: Claude + User collaboration
**Plan Version**: 1.0 (Initial complete rewrite)
