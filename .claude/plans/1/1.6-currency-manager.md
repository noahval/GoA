# Currency Manager

**Goal**: Implement currency exchange mechanics, transaction fees, purse capacity system, and market rate hooks (static initially, dynamic in Phase 3.1)

**Success Criteria**:
- CurrencyManager autoload created and registered
- Exchange functions work with market rate modifiers
- Transaction fee calculation (8% → 1% curve) implemented
- Purse capacity system enforces coin count limits
- Market rate modifiers exist (set to 1.0, ready for Phase 3.1)
- Charisma integration reduces fees
- All exchanges logged and grant charisma XP

**Prerequisites**:
- Phase 1.3: Global Autoload (stats, notifications, error handling)
- Phase 1.5: Currencies (data structures, unlock flags)

---

## Overview

**IMPORTANT: Write-Once Architecture**
This phase implements the **complete** currency exchange system with full support for market rates and fees. Initially, market rate modifiers are static (1.0), but the architecture is built to handle dynamic rates when Phase 3.1 adds volatility. **No rewrites needed later.**

The Currency Manager handles all currency operations beyond basic add/subtract: exchanges, fees, capacity limits, and market rate application.

### Key Design Principles

- **Market-Ready**: Built for dynamic rates from day one
- **Static Initially**: Modifiers set to 1.0 until Phase 3.1 activates
- **Complete Fee System**: Full 8% → 1% curve with charisma integration
- **Coin Count Capacity**: Purse limits based on total coins, not value
- **No UI**: Pure backend - ATM Scene (1.7) handles all UI

---

## Architecture Overview

### Data Flow

```
Player exchanges currency:
1. ATM calls preview_exchange() → shows what player will receive
2. Player confirms
3. ATM calls exchange_currency() → executes transaction
4. CurrencyManager:
   - Calculates fee (8% → 1%, charisma reduction)
   - Applies market rate modifiers (1.0 initially, dynamic later)
   - Deducts from source currency
   - Adds to target currency (with capacity check)
   - Awards charisma XP
   - Logs transaction
```

### Separation of Concerns

- **Phase 1.x-currencies (Currencies)**: Data storage (currency dictionaries, unlocks)
- **This phase (1.6)**: Operations (exchange, fees, capacity, market hooks)
- **Phase 1.x-atm-scene (ATM Scene)**: UI (display, user input, visual feedback)
- **Phase 3.x-market-volatility (Market Volatility)**: Dynamics (updates modifiers in _process)

---

## Implementation Tasks

### 1. CurrencyManager Autoload Structure

**File Location**: `res://autoloads/currency_manager.gd`

**Core variables**:
```gdscript
extends Node

# ===== CURRENCY TYPE ENUM =====
enum CurrencyType {
	COPPER = 0,
	SILVER = 1,
	GOLD = 2,
	PLATINUM = 3
}

# ===== CONVERSION RATES (Base 1000:1 ratios) =====
const CONVERSION_RATES = {
	CurrencyType.COPPER: 1.0,      # 1 copper = 1 copper value
	CurrencyType.SILVER: 1000.0,   # 1 silver = 1000 copper value
	CurrencyType.GOLD: 1000000.0,  # 1 gold = 1,000,000 copper value
	CurrencyType.PLATINUM: 1000000000.0  # 1 platinum = 1 billion copper value
}

# ===== MARKET RATE MODIFIERS =====
# These modify conversion rates (1.0 = standard, 1.3 = 30% stronger, 0.7 = 30% weaker)
# Set to 1.0 initially - Phase 3.1 will update these dynamically
var conversion_rate_modifiers = {
	CurrencyType.COPPER: 1.0,
	CurrencyType.SILVER: 1.0,
	CurrencyType.GOLD: 1.0,
	CurrencyType.PLATINUM: 1.0  # Platinum always 1.0 (stable anchor)
}

# ===== CURRENCY NAME CONSTANTS =====
const CURRENCY_NAMES = {
	CurrencyType.COPPER: "Copper",
	CurrencyType.SILVER: "Silver",
	CurrencyType.GOLD: "Gold",
	CurrencyType.PLATINUM: "Platinum"
}

const CURRENCY_NAMES_PLURAL = {
	CurrencyType.COPPER: "Copper pieces",
	CurrencyType.SILVER: "Silver coins",
	CurrencyType.GOLD: "Gold coins",
	CurrencyType.PLATINUM: "Platinum bonds"
}

# ===== TRANSACTION FEE CONFIGURATION =====
const BASE_FEE_PERCENT = 0.08  # 8% base fee
const MIN_FEE_PERCENT = 0.01   # 1% floor (never go below)
const FEE_SCALING_DIVISOR = 100000.0  # Controls how fast fees scale down

# ===== CHARISMA FEE REDUCTION =====
const FEE_REDUCTION_PER_CHARISMA = 0.0025  # 0.25% reduction per charisma level
```

**Key Design Notes:**
- Conversion rates are base multipliers (1000:1 ratio)
- Market modifiers are **separate** - multiply conversion rates
- Modifiers default to 1.0 (no effect) until Phase 3.1
- Platinum modifier always 1.0 (stable anchor currency)

---

### 2. Transaction Fee System

**Fee calculation with volume scaling and charisma**:

```gdscript
# Calculate transaction fee for an exchange
# Returns fee amount in the source currency
func calculate_transaction_fee(amount: float, from_type: CurrencyType) -> float:
	if amount <= 0:
		return 0.0

	# Convert to copper value for consistent scaling
	var copper_value = amount * CONVERSION_RATES[from_type]

	# Logarithmic scaling: large transactions get lower fees
	var scaling_factor = log(copper_value + 1) / FEE_SCALING_DIVISOR
	var fee_percent = BASE_FEE_PERCENT - (scaling_factor * (BASE_FEE_PERCENT - MIN_FEE_PERCENT))

	# Clamp to valid range (1% to 8%)
	fee_percent = clamp(fee_percent, MIN_FEE_PERCENT, BASE_FEE_PERCENT)

	# Apply charisma reduction
	if Global.charisma > 1:
		var charisma_levels = Global.charisma - 1
		var reduction = charisma_levels * FEE_REDUCTION_PER_CHARISMA
		fee_percent *= (1.0 - reduction)
		fee_percent = max(fee_percent, MIN_FEE_PERCENT)  # Still respect floor

	# Calculate final fee amount
	var fee = amount * fee_percent

	DebugLogger.log_info("FeeCalc", "Amount: %.2f, Fee%%: %.2f%%, Fee: %.2f" % [
		amount, fee_percent * 100, fee
	])

	return fee
```

**Fee examples:**
- 10 copper: ~8% fee = 0.8 copper
- 100 copper: ~8% fee = 8 copper
- 10,000 copper: ~4% fee = 400 copper
- 100,000 copper: ~1.5% fee = 1,500 copper
- 1,000,000 copper: ~1% fee (floor) = 10,000 copper

**Charisma impact:**
- Charisma 5: 1% reduction (0.25% × 4 levels)
- Reduces 8% fee to ~7.92%
- Reduces 1% fee to... still 1% (respects floor)

---

### 3. Exchange Preview System

**Preview without executing** (for UI):

```gdscript
# Preview an exchange without executing it
# Returns dict with all calculation details
func preview_exchange(from_type: CurrencyType, to_type: CurrencyType, amount: float) -> Dictionary:
	# Validation
	if amount <= 0:
		return {"valid": false, "error": "invalid_amount"}

	if from_type == to_type:
		return {"valid": false, "error": "same_currency"}

	# Check player has enough
	var player_amount = _get_player_currency(from_type)
	if player_amount < amount:
		return {"valid": false, "error": "insufficient_funds"}

	# Check target currency is unlocked
	if not _is_currency_unlocked_internal(to_type):
		return {"valid": false, "error": "currency_locked"}

	# Calculate fee
	var fee = calculate_transaction_fee(amount, from_type)
	var net_amount = amount - fee

	# Calculate exchange rate with market modifiers
	var from_rate = CONVERSION_RATES[from_type] * conversion_rate_modifiers[from_type]
	var to_rate = CONVERSION_RATES[to_type] * conversion_rate_modifiers[to_type]

	# Calculate received amount
	var received = (net_amount * from_rate) / to_rate

	# Calculate copper value (for charisma XP award)
	var copper_value_of_fee = fee * CONVERSION_RATES[from_type]

	return {
		"valid": true,
		"from_type": from_type,
		"to_type": to_type,
		"amount": amount,
		"fee": fee,
		"fee_percent": (fee / amount) * 100.0,
		"net_after_fee": net_amount,
		"received": received,
		"from_modifier": conversion_rate_modifiers[from_type],
		"to_modifier": conversion_rate_modifiers[to_type],
		"charisma_xp": copper_value_of_fee
	}
```

**Usage by ATM:**
```gdscript
# In atm.gd
var preview = CurrencyManager.preview_exchange(COPPER, SILVER, 100.0)
if preview.valid:
	label.text = "%.0f copper → %.2f silver\n(broker takes %.0f copper)" % [
		preview.amount, preview.received, preview.fee
	]
```

---

### 4. Exchange Execution System

**Execute the exchange** (with all side effects):

```gdscript
# Execute a currency exchange with fee
# Returns dict with success status and details
func exchange_currency(from_type: CurrencyType, to_type: CurrencyType, amount: float) -> Dictionary:
	# Get preview (validates everything)
	var preview = preview_exchange(from_type, to_type, amount)

	if not preview.valid:
		return {"success": false, "error": preview.error}

	# Deduct source currency (full amount including fee)
	if not _deduct_currency_internal(from_type, amount):
		return {"success": false, "error": "deduction_failed"}

	# Add target currency (check capacity)
	var actually_added = _add_currency_with_capacity_check(to_type, preview.received)

	# Award charisma XP based on fee paid
	Global.add_stat_exp("charisma", preview.charisma_xp)

	# Log transaction
	DebugLogger.log_info("Exchange", "%s→%s: %.2f→%.2f (fee %.2f)" % [
		CURRENCY_NAMES[from_type],
		CURRENCY_NAMES[to_type],
		amount,
		actually_added,
		preview.fee
	])

	# Notify player
	Global.show_notification("Exchanged %.0f %s for %.2f %s" % [
		amount,
		CURRENCY_NAMES[from_type].to_lower(),
		actually_added,
		CURRENCY_NAMES[to_type].to_lower()
	])

	return {
		"success": true,
		"fee": preview.fee,
		"received": actually_added,  # Actual amount (may be less if capacity full)
		"from_modifier": preview.from_modifier,
		"to_modifier": preview.to_modifier
	}
```

---

### 5. Purse Capacity System

**Capacity based on COIN COUNT (not value)**:

```gdscript
# ===== PURSE CAPACITY CONSTANTS =====
# Purse tiers with costs and capacity
const PURSE_TIERS = [
	# Copper-priced tiers (0-6)
	{"name": "Torn Pocket", "cap": 150, "cost_copper": 0},
	{"name": "Small Pouch", "cap": 300, "cost_copper": 135},
	{"name": "Leather Purse", "cap": 500, "cost_copper": 285},
	{"name": "Sturdy Purse", "cap": 700, "cost_copper": 650},
	{"name": "Money Belt", "cap": 900, "cost_copper": 850},
	{"name": "Secure Pouch", "cap": 1100, "cost_copper": 1050},
	{"name": "Lockbox", "cap": 1400, "cost_copper": 1350},

	# Silver-priced tiers (7-10)
	{"name": "Iron Strongbox", "cap": 2000, "cost_silver": 2.0},
	{"name": "Merchant's Safe", "cap": 3000, "cost_silver": 4.5},
	{"name": "Reinforced Vault", "cap": 5000, "cost_silver": 8.0},
	{"name": "Noble's Treasury", "cap": 10000, "cost_silver": 15.0}
]

# Calculate total coin count (NOT value)
func get_total_coin_count() -> int:
	var total = 0
	total += int(Level1Vars.currency.copper)
	total += int(Level1Vars.currency.silver)
	total += int(Level1Vars.currency.gold)
	total += int(Level1Vars.currency.platinum)
	return total

# Get current purse capacity
func get_current_capacity() -> int:
	var level = Level1Vars.purse_level
	if level >= PURSE_TIERS.size():
		level = PURSE_TIERS.size() - 1
	return PURSE_TIERS[level]["cap"]

# Get capacity info for UI
func get_capacity_info() -> Dictionary:
	var coin_count = get_total_coin_count()
	var cap = get_current_capacity()
	var percent = (float(coin_count) / float(cap)) * 100.0 if cap > 0 else 0.0

	var warning_level = 0
	if percent >= 100.0:
		warning_level = 3  # Full
	elif percent >= 90.0:
		warning_level = 2  # 90%+ warning
	elif percent >= 80.0:
		warning_level = 1  # 80%+ caution

	return {
		"current_coins": coin_count,
		"max_capacity": cap,
		"percent_full": percent,
		"warning_level": warning_level,
		"space_remaining": cap - coin_count
	}
```

**Add with capacity check**:

```gdscript
# Add currency with capacity enforcement
# Returns actual amount added (may be less than requested)
func _add_currency_with_capacity_check(currency_type: CurrencyType, amount: float) -> float:
	var capacity_info = get_capacity_info()
	var adding_coins = int(amount)  # Coin count, not value

	if capacity_info.current_coins + adding_coins > capacity_info.max_capacity:
		# Calculate how many coins can fit
		var space = capacity_info.space_remaining

		if space > 0:
			# Partial add
			var actual_added = float(space)
			_add_currency_to_level1vars(currency_type, actual_added)

			Global.show_notification("Purse full: %d %s spill to the ground!" % [
				adding_coins - space,
				CURRENCY_NAMES[currency_type].to_lower()
			])

			DebugLogger.log_warning("Capacity overflow: %d coins lost" % (adding_coins - space))
			return actual_added
		else:
			# No space at all
			Global.show_notification("Purse completely full! Upgrade needed!")
			DebugLogger.log_warning("Capacity full: cannot add %d coins" % adding_coins)
			return 0.0
	else:
		# Full amount fits
		_add_currency_to_level1vars(currency_type, amount)

		# Check for warnings
		var new_info = get_capacity_info()
		if new_info.warning_level == 2 and capacity_info.warning_level < 2:
			Global.show_notification("Purse nearly full: consider exchange or upgrade")

		return amount
```

---

### 6. Purse Upgrade System

**Purse upgrade operations** (in Level1Vars):

```gdscript
# In level_1_vars.gd (additional functions)

# Purse level tracking
var purse_level: int = 0

# Check if player can afford next purse upgrade
func can_afford_purse_upgrade() -> bool:
	if purse_level >= CurrencyManager.PURSE_TIERS.size() - 1:
		return false  # Already max tier

	var next_tier = CurrencyManager.PURSE_TIERS[purse_level + 1]

	if "cost_copper" in next_tier:
		return currency.copper >= next_tier.cost_copper
	elif "cost_silver" in next_tier:
		return currency.silver >= next_tier.cost_silver
	else:
		return false

# Get info about next purse upgrade
func get_purse_upgrade_info() -> Dictionary:
	if purse_level >= CurrencyManager.PURSE_TIERS.size() - 1:
		return {"can_upgrade": false, "at_max": true}

	var current_tier = CurrencyManager.PURSE_TIERS[purse_level]
	var next_tier = CurrencyManager.PURSE_TIERS[purse_level + 1]

	var result = {
		"can_upgrade": true,
		"at_max": false,
		"current_name": current_tier.name,
		"current_cap": current_tier.cap,
		"next_name": next_tier.name,
		"next_cap": next_tier.cap,
		"capacity_increase": next_tier.cap - current_tier.cap
	}

	if "cost_copper" in next_tier:
		result["currency_type"] = "copper"
		result["cost"] = next_tier.cost_copper
		result["can_afford"] = currency.copper >= next_tier.cost_copper
	elif "cost_silver" in next_tier:
		result["currency_type"] = "silver"
		result["cost"] = next_tier.cost_silver
		result["can_afford"] = currency.silver >= next_tier.cost_silver

	return result

# Purchase purse upgrade
func purchase_purse_upgrade() -> bool:
	var info = get_purse_upgrade_info()
	if not info.can_upgrade or not info.can_afford:
		return false

	# Deduct cost
	if info.currency_type == "copper":
		currency.copper -= info.cost
	elif info.currency_type == "silver":
		currency.silver -= info.cost
	else:
		return false

	# Upgrade purse
	purse_level += 1

	Global.show_notification("Purse upgraded: %s (capacity %d coins)" % [
		info.next_name, info.next_cap
	])

	DebugLogger.log_milestone("Purse upgraded to level %d: %s" % [purse_level, info.next_name])

	return true
```

---

### 7. Internal Helper Functions

**Currency access helpers**:

```gdscript
# Get player's current amount of a currency type
func _get_player_currency(currency_type: CurrencyType) -> float:
	match currency_type:
		CurrencyType.COPPER:
			return Level1Vars.currency.copper
		CurrencyType.SILVER:
			return Level1Vars.currency.silver
		CurrencyType.GOLD:
			return Level1Vars.currency.gold
		CurrencyType.PLATINUM:
			return Level1Vars.currency.platinum
		_:
			return 0.0

# Deduct currency from player (internal)
func _deduct_currency_internal(currency_type: CurrencyType, amount: float) -> bool:
	var type_name = _currency_type_to_string(currency_type)
	return Level1Vars.deduct_currency(type_name, amount)

# Add currency to player (internal)
func _add_currency_to_level1vars(currency_type: CurrencyType, amount: float) -> void:
	var type_name = _currency_type_to_string(currency_type)
	Level1Vars.add_currency(type_name, amount)

# Check if currency is unlocked (internal)
func _is_currency_unlocked_internal(currency_type: CurrencyType) -> bool:
	var type_name = _currency_type_to_string(currency_type)
	return Level1Vars.is_currency_unlocked(type_name)

# Convert enum to string
func _currency_type_to_string(currency_type: CurrencyType) -> String:
	match currency_type:
		CurrencyType.COPPER: return "copper"
		CurrencyType.SILVER: return "silver"
		CurrencyType.GOLD: return "gold"
		CurrencyType.PLATINUM: return "platinum"
		_: return ""
```

---

### 8. Market Rate Display API

**For ATM UI to show current rates**:

```gdscript
# Get current market rates in inverted display format
# Returns: "1 silver = X copper" (easier to understand)
func get_market_rates_display() -> Array[Dictionary]:
	var rates = []

	# Copper to Silver rate
	var copper_mod = conversion_rate_modifiers[CurrencyType.COPPER]
	var silver_mod = conversion_rate_modifiers[CurrencyType.SILVER]
	var copper_per_silver = (1000.0 * copper_mod) / silver_mod
	rates.append({
		"from": "silver",
		"to": "copper",
		"display": "1 silver = %.0f copper" % copper_per_silver,
		"rate": copper_per_silver
	})

	# Silver to Gold rate (if gold unlocked)
	if Level1Vars.unlocked_gold:
		var gold_mod = conversion_rate_modifiers[CurrencyType.GOLD]
		var silver_per_gold = (1000.0 * silver_mod) / gold_mod
		rates.append({
			"from": "gold",
			"to": "silver",
			"display": "1 gold = %.0f silver" % silver_per_gold,
			"rate": silver_per_gold
		})

	# Gold to Platinum rate (if platinum unlocked)
	if Level1Vars.unlocked_platinum:
		var platinum_mod = conversion_rate_modifiers[CurrencyType.PLATINUM]  # Always 1.0
		var gold_per_platinum = (1000.0 * gold_mod) / platinum_mod
		rates.append({
			"from": "platinum",
			"to": "gold",
			"display": "1 platinum = %.0f gold" % gold_per_platinum,
			"rate": gold_per_platinum
		})

	return rates
```

**Usage by ATM:**
```gdscript
# In atm.gd
var rates = CurrencyManager.get_market_rates_display()
for rate in rates:
	label.text += rate.display + "\n"
```

---

## Testing Strategy

### Unit Tests

Create `tests/test_currency_manager.gd`:

```gdscript
extends GutTest

func before_each():
	# Reset to known state
	CurrencyManager.conversion_rate_modifiers[CurrencyManager.CurrencyType.COPPER] = 1.0
	CurrencyManager.conversion_rate_modifiers[CurrencyManager.CurrencyType.SILVER] = 1.0
	Level1Vars.currency.copper = 1000.0
	Level1Vars.currency.silver = 10.0
	Global.charisma = 1

func test_fee_calculation_small():
	var fee = CurrencyManager.calculate_transaction_fee(10.0, CurrencyManager.CurrencyType.COPPER)
	assert_almost_eq(fee, 0.8, 0.1, "Small transaction ~8% fee")

func test_fee_calculation_large():
	var fee = CurrencyManager.calculate_transaction_fee(100000.0, CurrencyManager.CurrencyType.COPPER)
	var fee_percent = (fee / 100000.0) * 100.0
	assert_true(fee_percent < 2.0, "Large transaction < 2% fee")
	assert_true(fee_percent >= 1.0, "Fee never below 1%")

func test_charisma_fee_reduction():
	Global.charisma = 5
	var fee = CurrencyManager.calculate_transaction_fee(100.0, CurrencyManager.CurrencyType.COPPER)
	var fee_no_charisma = 100.0 * 0.08  # 8%

	assert_true(fee < fee_no_charisma, "Charisma reduces fee")

func test_preview_exchange():
	var preview = CurrencyManager.preview_exchange(
		CurrencyManager.CurrencyType.COPPER,
		CurrencyManager.CurrencyType.SILVER,
		100.0
	)

	assert_true(preview.valid, "Preview succeeded")
	assert_almost_eq(preview.fee, 8.0, 0.5, "Fee ~8 copper")
	assert_almost_eq(preview.received, 0.92, 0.05, "Received ~0.92 silver")

func test_exchange_execution():
	var initial_copper = Level1Vars.currency.copper
	var initial_silver = Level1Vars.currency.silver

	var result = CurrencyManager.exchange_currency(
		CurrencyManager.CurrencyType.COPPER,
		CurrencyManager.CurrencyType.SILVER,
		100.0
	)

	assert_true(result.success, "Exchange succeeded")
	assert_eq(Level1Vars.currency.copper, initial_copper - 100.0, "Copper deducted")
	assert_true(Level1Vars.currency.silver > initial_silver, "Silver increased")

func test_market_modifiers():
	# Test high copper rate (copper valuable)
	CurrencyManager.conversion_rate_modifiers[CurrencyManager.CurrencyType.COPPER] = 1.3

	var preview = CurrencyManager.preview_exchange(
		CurrencyManager.CurrencyType.COPPER,
		CurrencyManager.CurrencyType.SILVER,
		100.0
	)

	# Should get MORE silver when copper is valuable
	assert_true(preview.received > 0.92, "High copper modifier increases silver received")

func test_capacity_enforcement():
	Level1Vars.purse_level = 0  # Cap = 150 coins
	Level1Vars.currency.copper = 140.0
	Level1Vars.currency.silver = 0.0

	# Try to add 20 copper (would exceed 150)
	var added = CurrencyManager._add_currency_with_capacity_check(
		CurrencyManager.CurrencyType.COPPER,
		20.0
	)

	assert_eq(added, 10.0, "Only 10 coins fit")
	assert_eq(Level1Vars.currency.copper, 150.0, "Capped at 150")

func test_purse_upgrade():
	Level1Vars.purse_level = 0
	Level1Vars.currency.copper = 200.0

	var info = Level1Vars.get_purse_upgrade_info()
	assert_true(info.can_afford, "Can afford upgrade")

	var success = Level1Vars.purchase_purse_upgrade()
	assert_true(success, "Upgrade succeeded")
	assert_eq(Level1Vars.purse_level, 1, "Level increased")

func test_market_rates_display():
	var rates = CurrencyManager.get_market_rates_display()

	assert_eq(rates.size(), 1, "Only copper-silver shown initially")
	assert_true(rates[0].display.contains("silver"), "Shows silver rate")
```

**Run tests:**
```bash
godot --headless --script res://addons/gut/gut_cmdln.gd -gtest=tests/test_currency_manager.gd
```

### Manual Test Criteria

- [ ] Exchange 100 copper for silver via console
- [ ] Verify fee calculation (~8 copper)
- [ ] Verify received amount (~0.92 silver)
- [ ] Verify charisma XP awarded
- [ ] Test large exchange (10,000 copper) has lower fee%
- [ ] Set charisma to 5, verify fee reduction
- [ ] Fill purse to capacity, verify overflow warning
- [ ] Purchase purse upgrade, verify capacity increase
- [ ] Test market rate display shows "1 silver = 1000 copper"

---

## Files to Create

**autoloads/currency_manager.gd** (~600 lines new)
- Enum and constants
- Market rate modifier system
- Fee calculation
- Preview exchange
- Execute exchange
- Capacity enforcement
- Purse tier constants
- Helper functions
- Market rate display API

**tests/test_currency_manager.gd** (~300 lines new)
- Fee calculation tests
- Exchange tests
- Capacity tests
- Market modifier tests
- Purse upgrade tests

## Files to Modify

**level1/level_1_vars.gd** (~100 lines added)
- purse_level variable
- can_afford_purse_upgrade()
- get_purse_upgrade_info()
- purchase_purse_upgrade()
- Save/load purse_level

**project.godot** (autoload registration)
```ini
[autoload]
CurrencyManager="*res://autoloads/currency_manager.gd"
```

---

## Design Values (Reference)

### Transaction Fee Curve

| Amount (copper) | Fee % | Fee Amount |
|-----------------|-------|------------|
| 10              | 8.0%  | 0.8        |
| 100             | 8.0%  | 8.0        |
| 1,000           | 6.5%  | 65         |
| 10,000          | 4.0%  | 400        |
| 100,000         | 1.5%  | 1,500      |
| 1,000,000       | 1.0%  | 10,000     |

### Purse Capacity Tiers

**Copper-priced (levels 0-6):**
- Level 0: Torn Pocket (150 coins) - FREE
- Level 1: Small Pouch (300 coins) - 135 copper
- Level 2: Leather Purse (500 coins) - 285 copper
- Level 3: Sturdy Purse (700 coins) - 650 copper
- Level 4: Money Belt (900 coins) - 850 copper
- Level 5: Secure Pouch (1100 coins) - 1050 copper
- Level 6: Lockbox (1400 coins) - 1350 copper

**Silver-priced (levels 7-10):**
- Level 7: Iron Strongbox (2000 coins) - 2 silver
- Level 8: Merchant's Safe (3000 coins) - 4.5 silver
- Level 9: Reinforced Vault (5000 coins) - 8 silver
- Level 10: Noble's Treasury (10000 coins) - 15 silver

### Market Rate Modifiers

**Static values (Phase 1.6-1.7):**
- All modifiers = 1.0 (standard rate)
- Platinum always = 1.0 (stable anchor)

**Dynamic values (Phase 3.1+):**
- Copper: 0.7 to 1.3 (±30% range)
- Silver: 0.7 to 1.3 (±30% range)
- Gold: 0.7 to 1.3 (±30% range)
- Platinum: 1.0 (never changes)

---

## Integration Points

### Uses Global APIs

```gdscript
Global.add_stat_exp("charisma", xp_amount)  # Charisma from fees
Global.show_notification(message)  # Player feedback
Global.charisma  # Fee reduction calculation
```

### Uses Level1Vars

```gdscript
Level1Vars.currency  # Read/write currency amounts
Level1Vars.unlocked_gold  # Check unlocks for rate display
Level1Vars.unlocked_platinum  # Check unlocks
Level1Vars.purse_level  # Capacity calculations
Level1Vars.add_currency()  # Internal operations
Level1Vars.deduct_currency()  # Internal operations
```

### Uses DebugLogger

```gdscript
DebugLogger.log_info("Exchange", details)
DebugLogger.log_warning("Capacity overflow")
DebugLogger.log_milestone("Purse upgraded")
```

### Provides APIs For

**ATM Scene (1.7):**
- `preview_exchange()` - Show what player will receive
- `exchange_currency()` - Execute exchange
- `get_market_rates_display()` - Show current rates
- `get_capacity_info()` - Display capacity bar

**Market Volatility (3.1):**
- `conversion_rate_modifiers` - Update these in _process()

**Gameplay Systems:**
- All currency operations go through this manager

---

## Notes & Decisions

**Decision 1**: Market rate modifiers as separate variables
- **Rationale**: Clean separation - rates are base, modifiers are dynamic
- **Benefit**: Phase 3.1 just updates modifiers, no other changes needed
- **Implementation**: Multiply base rate by modifier in calculations

**Decision 2**: Capacity based on coin count, not value
- **Rationale**: User requirement - "A coin is a coin"
- **Thematic**: Physical purse size, not value vault
- **Benefit**: Simple mental model (1000 cap = 1000 coins any mix)

**Decision 3**: Complete fee system from day one
- **Rationale**: Write once, no rewrites
- **Implementation**: Full 8%→1% curve with charisma integration
- **Works**: With static OR dynamic rates (no changes needed)

**Decision 4**: Purse upgrades in Level1Vars, capacity logic in Manager
- **Rationale**: Data vs operations separation
- **Level1Vars**: purse_level, purchase logic (data)
- **CurrencyManager**: capacity enforcement (operations)

**Decision 5**: Charisma XP from fees
- **Rationale**: Economic activity teaches charisma
- **Formula**: Copper value of fee = XP awarded
- **Balancing**: Encourages large exchanges, not spam

**Decision 6**: Preview function returns full details
- **Rationale**: UI needs to show complete breakdown
- **Includes**: Fee, fee%, received, modifiers, XP
- **Benefit**: One call gets all info for display

---

## Open Questions

- [ ] Should there be a daily/session exchange limit?
- [ ] Should exchanges track history for statistics?
- [ ] Do we want "quick convert" functions (e.g., convert_all_copper)?
- [ ] Should capacity overflow be more punishing (lose coins permanently)?
- [ ] Do purse upgrades persist through prestige?

---

## Implementation Checklist

Before marking this phase complete:

- [ ] CurrencyManager autoload created
- [ ] Enum and constants defined
- [ ] conversion_rate_modifiers dictionary created (all set to 1.0)
- [ ] calculate_transaction_fee() implemented
- [ ] Charisma fee reduction working
- [ ] preview_exchange() implemented
- [ ] exchange_currency() implemented
- [ ] Capacity enforcement working
- [ ] PURSE_TIERS constant defined
- [ ] get_capacity_info() implemented
- [ ] Purse upgrade functions in Level1Vars
- [ ] get_market_rates_display() implemented
- [ ] Helper functions implemented
- [ ] Autoload registered in project.godot
- [ ] Unit tests written and passing
- [ ] Manual tests completed
- [ ] DebugLogger integration verified
- [ ] Ready for ATM Scene (Phase 1.7)

---

**Last Updated**: 2025-11-28
**Maintainer**: Claude + User collaboration
**Plan Version**: 1.0 (Write-once architecture - no rewrites needed)
