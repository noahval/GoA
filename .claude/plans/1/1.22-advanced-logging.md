# Advanced Logging: Bug Reports Plan

## Overview
Bug report UI for external playtesters. Captures screenshots, recent logs, and player descriptions, then submits to Nakama storage with local backup for failed submissions.

## Core Goals
1. In-game bug report UI accessible from settings
2. Screenshot capture with compression
3. Submit to Nakama with player context
4. Local backup for offline/failed submissions
5. Privacy consent for data collection
6. Session correlation with log files

---

## Part 1: Bug Reporter Backend

### What It Does
- Generates unique report IDs
- Saves local backup before cloud submission
- Submits to Nakama storage
- Tracks submission success/failure
- No automatic retry (manual review of local backups)

### File: bug_reporter.gd (Autoload)

```gdscript
extends Node

const LOCAL_BACKUP_DIR = "user://bug_reports/"
const MAX_SCREENSHOT_SIZE = 1920  # Max width/height for screenshots
const MAX_PAYLOAD_SIZE = 900 * 1024  # 900KB (under Nakama's 1MB limit)

func _ready():
	_setup_backup_directory()
	_rotate_old_backups()

func _setup_backup_directory():
	var dir = DirAccess.open("user://")
	if not dir:
		DebugLogger.error("Failed to access user:// directory", "BUG_REPORT")
		return

	if not dir.dir_exists("bug_reports"):
		var err = dir.make_dir("bug_reports")
		if err != OK:
			DebugLogger.error("Failed to create bug_reports directory: " + str(err), "BUG_REPORT")

func _rotate_old_backups():
	# Keep only last 20 local bug report backups
	var dir = DirAccess.open(LOCAL_BACKUP_DIR)
	if not dir:
		return

	var backup_files: Array[Dictionary] = []
	dir.list_dir_begin()
	var file_name = dir.get_next()

	while file_name != "":
		if file_name.begins_with("bug_") and file_name.ends_with(".json"):
			var file_path = LOCAL_BACKUP_DIR + file_name
			var mod_time = FileAccess.get_modified_time(file_path)
			backup_files.append({"name": file_name, "modified": mod_time})
		file_name = dir.get_next()

	dir.list_dir_end()

	# Sort by modification time (oldest first)
	backup_files.sort_custom(func(a, b): return a.modified < b.modified)

	# Delete oldest if more than 20
	while backup_files.size() > 20:
		var oldest = backup_files.pop_front()
		dir.remove(oldest.name)
		DebugLogger.info("Deleted old bug report backup: " + oldest.name, "BUG_REPORT")

# Submit bug report with local backup
func submit_bug_report(report_data: Dictionary) -> bool:
	# Generate unique report ID
	var report_id = _generate_report_id()
	report_data["report_id"] = report_id

	# Validate payload size before submission
	var estimated_size = _estimate_payload_size(report_data)
	if estimated_size > MAX_PAYLOAD_SIZE:
		DebugLogger.warn("Bug report payload too large: " + str(estimated_size) + " bytes", "BUG_REPORT")
		# Truncate logs if needed
		report_data["recent_logs"] = report_data["recent_logs"].slice(-50)  # Keep last 50 only
		report_data["error_logs"] = report_data["error_logs"].slice(-25)  # Keep last 25 only

	# Save local backup first (always succeeds)
	_save_local_backup(report_id, report_data)

	# Check if authenticated
	if not NakamaClient.is_authenticated:
		DebugLogger.warn("Cannot submit bug report: Not authenticated", "BUG_REPORT")
		DebugLogger.info("Bug report saved locally: " + report_id, "BUG_REPORT")
		return false

	# Add user metadata
	report_data["user_id"] = NakamaClient.user_id
	report_data["username"] = NakamaClient.username
	report_data["platform"] = OS.get_name()

	# Submit to Nakama
	var result = await NakamaClient.write_storage("bug_reports", report_id, report_data)

	if result:
		DebugLogger.info("Bug report submitted to cloud: " + report_id, "BUG_REPORT")
		return true
	else:
		DebugLogger.error("Cloud submission failed, local backup saved", "BUG_REPORT")
		return false

func _generate_report_id() -> String:
	var timestamp = Time.get_unix_time_from_system()
	var session = DebugLogger.get_session_id()
	return "bug_%d_%s" % [timestamp, session]

func _estimate_payload_size(data: Dictionary) -> int:
	# Rough estimate of JSON size
	var json_string = JSON.stringify(data)
	return json_string.length()

func _save_local_backup(report_id: String, report_data: Dictionary):
	var file_path = LOCAL_BACKUP_DIR + report_id + ".json"
	var file = FileAccess.open(file_path, FileAccess.WRITE)

	if file:
		file.store_string(JSON.stringify(report_data, "\t"))
		file.close()
		DebugLogger.info("Bug report backed up locally: " + file_path, "BUG_REPORT")
	else:
		DebugLogger.error("Failed to save local backup for: " + report_id, "BUG_REPORT")
```

### Add to project.godot Autoload
```ini
[autoload]
BugReporter="*res://bug_reporter.gd"
```

---

## Part 2: Bug Report UI

### What It Does
- Captures screenshot BEFORE showing panel (not after)
- Displays recent errors to give context
- Collects player description
- Shows privacy consent checkbox
- Submits to BugReporter with all context

### File: debug_panel.tscn (Scene Layout)

**Simplified Layout** (fullscreen overlay):
```
Panel (fullscreen, semi-transparent background)
├── MarginContainer (20px margins)
    └── VBoxContainer (spacing: 10)
        ├── Label "Bug Report" (title)
        ├── HSeparator
        ├── Label "Recent Errors:"
        ├── ScrollContainer (expand, min_size 150px)
        │   └── Label (error_display)
        ├── HSeparator
        ├── Label "Screenshot Preview:"
        ├── TextureRect (screenshot_preview, expand, max_height 300px)
        ├── HSeparator
        ├── Label "What were you doing when this happened?"
        ├── TextEdit (description_box, expand, min_size 100px)
        ├── CheckBox (consent_checkbox) "I agree to send diagnostic data"
        ├── HBoxContainer (buttons)
        │   ├── Button (submit_button) "Submit Bug Report"
        │   ├── Control (spacer, expand)
        │   └── Button (close_button) "Close"
        └── Label (status_label, small text for feedback)
```

### File: debug_panel.gd

```gdscript
extends Control

@onready var error_display: Label = $MarginContainer/VBoxContainer/ScrollContainer/ErrorDisplay
@onready var screenshot_preview: TextureRect = $MarginContainer/VBoxContainer/ScreenshotPreview
@onready var description_box: TextEdit = $MarginContainer/VBoxContainer/DescriptionBox
@onready var consent_checkbox: CheckBox = $MarginContainer/VBoxContainer/ConsentCheckbox
@onready var submit_button: Button = $MarginContainer/VBoxContainer/Buttons/SubmitButton
@onready var close_button: Button = $MarginContainer/VBoxContainer/Buttons/CloseButton
@onready var status_label: Label = $MarginContainer/VBoxContainer/StatusLabel

var captured_screenshot: Image = null

func _ready():
	submit_button.pressed.connect(_on_submit_pressed)
	close_button.pressed.connect(_on_close_pressed)
	visible = false

func show_panel():
	# Capture screenshot BEFORE showing panel
	_capture_screenshot()

	# Load recent errors
	_refresh_error_display()

	# Reset form
	description_box.text = ""
	consent_checkbox.button_pressed = false
	status_label.text = ""
	submit_button.disabled = false

	show()

func _capture_screenshot():
	# Wait for current frame to finish rendering
	await RenderingServer.frame_post_draw

	# Capture viewport
	var viewport_texture = get_viewport().get_texture()
	captured_screenshot = viewport_texture.get_image()

	# Downscale if too large
	var width = captured_screenshot.get_width()
	var height = captured_screenshot.get_height()
	var max_dimension = max(width, height)

	if max_dimension > BugReporter.MAX_SCREENSHOT_SIZE:
		var scale_factor = float(BugReporter.MAX_SCREENSHOT_SIZE) / float(max_dimension)
		var new_width = int(width * scale_factor)
		var new_height = int(height * scale_factor)
		captured_screenshot.resize(new_width, new_height, Image.INTERPOLATE_LANCZOS)
		DebugLogger.info("Screenshot downscaled to: " + str(new_width) + "x" + str(new_height), "BUG_REPORT")

	# Show preview
	var texture = ImageTexture.create_from_image(captured_screenshot)
	screenshot_preview.texture = texture
	screenshot_preview.expand_mode = TextureRect.EXPAND_FIT_WIDTH_PROPORTIONAL

func _refresh_error_display():
	var errors = DebugLogger.get_error_logs(10)

	error_display.text = ""

	if errors.is_empty():
		error_display.text = "No recent errors or warnings."
	else:
		for log in errors:
			# Extract just the time portion (HH:MM:SS)
			var time_parts = log.timestamp.split(" ")
			var time = time_parts[1] if time_parts.size() > 1 else log.timestamp
			error_display.text += "[%s] %s: %s\n" % [time, log.level, log.message]

func _on_submit_pressed():
	var description = description_box.text.strip_edges()

	# Validate description
	if description.is_empty():
		status_label.text = "Please describe what happened."
		status_label.add_theme_color_override("font_color", Color.ORANGE_RED)
		return

	# Validate consent
	if not consent_checkbox.button_pressed:
		status_label.text = "Please agree to send diagnostic data."
		status_label.add_theme_color_override("font_color", Color.ORANGE_RED)
		return

	submit_button.disabled = true
	submit_button.text = "Submitting..."
	status_label.text = "Preparing report..."
	status_label.add_theme_color_override("font_color", Color.WHITE)

	# Prepare bug report
	var bug_report = {
		"description": description,
		"timestamp": Time.get_datetime_string_from_system(),
		"session_id": DebugLogger.get_session_id(),
		"game_version": ProjectSettings.get_setting("application/config/version", "1.0"),
		"recent_logs": DebugLogger.get_recent_logs(150),
		"error_logs": DebugLogger.get_error_logs(50),
		"system_info": _get_system_info(),
		"player_stats": _get_player_stats(),
		"player_progress": _get_player_progress(),
		"screenshot": _screenshot_to_base64()
	}

	# Submit to BugReporter (with local backup)
	status_label.text = "Uploading..."
	var success = await BugReporter.submit_bug_report(bug_report)

	if success:
		submit_button.text = "Submitted!"
		status_label.text = "Thank you! Report ID: " + bug_report["report_id"]
		status_label.add_theme_color_override("font_color", Color.GREEN)
		await get_tree().create_timer(3.0).timeout
		hide()
	else:
		submit_button.text = "Failed"
		status_label.text = "Submission failed - saved locally for manual review"
		status_label.add_theme_color_override("font_color", Color.ORANGE_RED)
		await get_tree().create_timer(3.0).timeout

	submit_button.disabled = false
	submit_button.text = "Submit Bug Report"

func _get_system_info() -> Dictionary:
	return {
		"os": OS.get_name(),
		"os_version": OS.get_version(),
		"godot_version": Engine.get_version_info().string,
		"viewport_size": str(get_viewport().size),
		"current_scene": get_tree().current_scene.scene_file_path if get_tree().current_scene else "unknown"
	}

func _get_player_stats() -> Dictionary:
	# TODO: Update when Global.gd stats are implemented
	return {
		"strength": 0,
		"constitution": 0,
		"dexterity": 0,
		"wisdom": 0,
		"intelligence": 0,
		"charisma": 0
	}

func _get_player_progress() -> Dictionary:
	# TODO: Update when Level1Vars is implemented
	return {
		"copper": 0,
		"silver": 0,
		"gold": 0,
		"platinum": 0,
		"shovel_lvl": 1
	}

func _screenshot_to_base64() -> String:
	if not captured_screenshot:
		return ""

	# Compress as PNG
	var png_buffer = captured_screenshot.save_png_to_buffer()

	# Check size
	var size_kb = png_buffer.size() / 1024
	DebugLogger.info("Screenshot PNG size: " + str(size_kb) + " KB", "BUG_REPORT")

	# Convert to base64
	return Marshalls.raw_to_base64(png_buffer)

func _on_close_pressed():
	hide()
```

---

## Part 3: Integration with Settings

### Add to Settings Menu

In your settings scene/script, add a "Report Bug" button:

```gdscript
# In settings_menu.gd or similar

@onready var bug_report_panel = preload("res://debug_panel.tscn").instantiate()

func _ready():
	# Add bug report panel to scene tree (hidden)
	add_child(bug_report_panel)

	# Connect "Report Bug" button
	report_bug_button.pressed.connect(_on_report_bug_pressed)

func _on_report_bug_pressed():
	bug_report_panel.show_panel()
```

---

## Part 4: Reviewing Bug Reports

### Manual Review Workflow

#### Option 1: Nakama Console Export
1. Log into Nakama console (http://localhost:7351 or your server)
2. Navigate to Storage > bug_reports
3. Export reports as JSON
4. Share JSON with Claude for analysis

#### Option 2: API Query
```gdscript
# Query all bug reports for a specific user
var reports = await NakamaClient.read_storage_objects("bug_reports")

# Print report IDs and descriptions
for report in reports:
	print("Report: " + report.report_id)
	print("Description: " + report.description)
	print("Session: " + report.session_id)
	print("---")
```

#### Option 3: Local Backups
- Check `user://bug_reports/` folder
- Open JSON files directly
- Correlate with log files using session_id

### What I'll Analyze
When you share a bug report with me, I'll review:
1. Player description (what they were doing)
2. Recent error logs (what failed)
3. System info (platform, version)
4. Player stats/progress (game state)
5. Session ID to find full log file
6. Screenshot (visual context)

---

## Part 5: Implementation Workflow

### Prerequisites
- [ ] 1.21-simple-logging.md completed (DebugLogger exists)
- [ ] Nakama integration completed (1.18-1.20)
- [ ] NakamaClient has write_storage() method

### Tasks
- [ ] Create bug_reporter.gd autoload
- [ ] Add to project.godot autoload
- [ ] Test local backup creation
- [ ] Test backup rotation (create 25 dummy backups, verify only 20 remain)
- [ ] Create debug_panel.tscn scene with layout
- [ ] Create debug_panel.gd script
- [ ] Test screenshot capture and downscaling
- [ ] Test base64 encoding size
- [ ] Test payload size validation
- [ ] Add "Report Bug" button to settings menu
- [ ] Test full submission flow (authenticated)
- [ ] Test offline submission (local backup only)
- [ ] Test privacy consent validation
- [ ] Document review workflow for yourself

---

## Success Criteria

- [ ] Screenshot captured BEFORE panel appears (no UI in screenshot)
- [ ] Screenshots downscaled to max 1920px (prevents huge payloads)
- [ ] Local backup always succeeds (even if offline)
- [ ] Payload size validated before submission (prevents Nakama errors)
- [ ] Privacy consent required before submission
- [ ] Session ID correlates bug report with log file
- [ ] Failed submissions stay in local backups for manual review
- [ ] Old backups rotated automatically (keeps last 20)
- [ ] Bug reports successfully stored in Nakama
- [ ] Can manually retrieve and review reports

---

## Notes

### Privacy Compliance (Canada - PIPEDA)
- Explicit consent checkbox required before data collection
- Player must be informed what data is being sent:
  - Game logs (errors, events)
  - System information (OS, version)
  - Player progress (stats, currency)
  - Screenshot of game state
- Data used only for debugging purposes
- Consider adding privacy policy link in consent text

### Payload Size Management
- Max Nakama storage object: 1MB (1,048,576 bytes)
- Target: 900KB to leave buffer
- Screenshot downscaling: Max 1920px reduces size by ~70%
- PNG compression is efficient for UI screenshots
- Log truncation if needed: Keep most recent entries

### Screenshot Capture Timing
**CRITICAL**: Capture BEFORE `show()` is called, otherwise the bug report panel appears in the screenshot. Use `await RenderingServer.frame_post_draw` to ensure current frame is rendered first.

### Session Correlation Example
```
Log file: goa_2025-12-09_14-30-45_abc123.log
Bug report ID: bug_1733767845_abc123
Session ID: abc123 (links them together)
```

This makes it easy to find the full session log when reviewing a bug report.

### No Automatic Retry
Deliberately no automatic retry mechanism. If submission fails:
1. Local backup is saved
2. User is notified
3. You manually review `user://bug_reports/` later
4. If needed, manually re-submit via Nakama console

This keeps code simple and prevents background network spam.

---

## Dependencies

**Before This**:
- 1.21-simple-logging.md (DebugLogger autoload with memory buffer and session ID)
- 1.18-1.20 Nakama integration (NakamaClient with write_storage())

**After This**:
- None (bug reporting is leaf feature)

---

## Files to Create

- `bug_reporter.gd` - Bug submission backend with local backup
- `debug_panel.gd` - Bug report UI script
- `debug_panel.tscn` - Bug report UI scene

---

## Quick Reference: Bug Report Workflow

### Player Side:
1. Press "Report Bug" in settings
2. See screenshot preview and recent errors
3. Describe what happened
4. Check privacy consent
5. Submit

### Your Side:
1. Check Nakama console or local backups
2. Share bug report JSON with me
3. I analyze logs, screenshot, and context
4. I propose fix
5. You approve and I implement
