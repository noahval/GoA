# Scene Management

**Goal**: Extend Global.gd scene system with validation framework, async loading, error recovery, and advanced navigation features

**Success Criteria**:
- Scene validation framework with priority system
- Enhanced error handling and recovery
- Async scene loading support
- Scene history navigation
- User-friendly validation error messages
- Save/load integration on scene transitions
- Debug logging for all scene changes
- Unit tests for scene changing logic
- Transition metadata for future visual effects
- Removed coupling to victory/caught systems (being deprecated)

**Prerequisites**:
- Phase 1.3: Global Autoload (Global.gd exists with basic scene management)
- Phase 1.21: Logging Debug System (DebugLogger.gd exists)
- Phase 1.19: Save System Cloud (NakamaManager exists)
- Phase 1.x: Local Save Manager (LocalSaveManager exists) [TODO: Create plan if doesn't exist]

---

## Overview

**IMPORTANT: Extension, Not Duplication**
This plan **extends** the basic scene management system defined in Phase 1.3 (Global Autoload). Phase 1.3 establishes basic `change_scene()`, scene tracking variables, and the `go_back()` function. This plan adds:
- **Validation framework** with priority system
- **Error recovery** for failed scene loads
- **Async loading** for smoother transitions
- **Scene history stack** for multi-level navigation
- **Transition metadata** structure for future visual effects
- **Enhanced error messaging** for validation failures

The scene management system provides the core infrastructure for navigating between game scenes. This plan focuses on **advanced features**: validation hooks, error recovery, async loading, and navigation history. The actual **scene network** (which scenes connect to which, unlocks, prerequisites) is handled per-level in feature plans (e.g., 2.1-scene-network.md for copper era).

### Key Design Principles

- **Generic & Reusable**: Works for any scene in any level
- **Validation Hooks**: Extensible framework with priority system
- **Robust Error Handling**: Graceful degradation on failures
- **Decoupled**: No specific game mechanic dependencies (no victory, caught, etc.)
- **Save Before Transition**: Always persist state before scene changes
- **Comprehensive Logging**: Track all transitions for debugging
- **Async-First**: Non-blocking scene loads
- **User-Friendly Errors**: Clear messages when transitions blocked
- **Future-Proof Metadata**: Structure for transition effects (deferred to future plan)

---

## Architecture Overview

### Data Flow

```
Scene Change Request
  -> Check if transition in progress
  -> Validate (priority-ordered validators with reason tracking)
  -> Show user-friendly error if blocked
  -> Save game state (cloud or local)
  -> Log transition (debug)
  -> Store transition metadata
  -> Execute async scene load (with error recovery)
  -> Update scene history stack
  -> (future: apply transition effects from metadata)
```

### Component Separation

- **Phase 1.3 (Global.gd)**: Basic scene changing, scene tracking variables, go_back()
- **This Plan (1.8)**: Validation framework, async loading, error recovery, history stack
- **Level Plans (2.x, 3.x, etc.)**: Scene networks, specific navigation rules
- **Future Plans**: Transition effects (fade, wipe, etc.) using metadata

---

## Implementation Tasks

### 1. Enhanced Scene Variables (Add to Global.gd)

**Note**: Phase 1.3 already defines basic scene tracking:
```gdscript
var current_scene_path: String = ""
var previous_scene_path: String = ""
var scene_transition_in_progress: bool = false
```

**Additional variables for this plan**:
```gdscript
# Scene history navigation (extends Phase 1.3 previous_scene_path)
var scene_history: Array[String] = []
const MAX_SCENE_HISTORY = 10

# Validation framework
var scene_validators: Array[Dictionary] = []  # {validator: Callable, priority: int, name: String}

# Async loading
var scene_loader: ResourceLoader.ThreadLoadStatus = null
var load_progress: Array = []
var is_loading_async: bool = false

# Transition metadata (for future visual effects)
var transition_metadata: Dictionary = {}

# Error recovery
const FALLBACK_SCENE = "res://scenes/main_menu.tscn"  # Safe scene to load on errors
var last_successful_scene: String = ""

# Preloaded scenes cache
var preloaded_scenes: Dictionary = {}  # {scene_path: Resource}
const MAX_PRELOADED_SCENES = 3
```

---

### 2. Enhanced Scene Changing Function

**File Location**: `res://autoloads/global.gd`

**Enhanced function signature** (replaces/extends Phase 1.3 version):
```gdscript
# Change to a new scene with validation, async loading, and error recovery
func change_scene(scene_path: String, skip_validation: bool = false, transition_type: String = "default") -> void:
	# Prevent concurrent transitions
	if scene_transition_in_progress:
		push_warning("Scene transition already in progress, ignoring request")
		return

	scene_transition_in_progress = true

	# Validate scene transition (with reason tracking)
	if not skip_validation:
		var block_reason = ""
		if not can_change_to_scene(scene_path, block_reason):
			# Show user-friendly error message
			if not block_reason.is_empty():
				show_notification(block_reason)
			push_warning("Scene transition blocked: " + block_reason)
			scene_transition_in_progress = false
			return

	# Get current scene for logging
	var from_scene = get_current_scene_path()

	# Save game state before transition
	_save_before_transition()

	# Store transition metadata (for future visual effects)
	transition_metadata = {
		"type": transition_type,  # "fade", "wipe", "instant", "default"
		"from": from_scene,
		"to": scene_path,
		"timestamp": Time.get_ticks_msec(),
		"skip_validation": skip_validation
	}

	# Log the transition
	DebugLogger.log_scene_change(from_scene, scene_path, "Scene transition (%s)" % transition_type)

	# Update scene history stack (before the change)
	_update_scene_history(from_scene, scene_path)

	# Execute async scene change with error recovery
	await _change_scene_async(scene_path)

	# Track last successful scene
	last_successful_scene = scene_path

	# Reset flag after scene loads
	scene_transition_in_progress = false

# Helper: Save before transition
func _save_before_transition() -> void:
	if NakamaManager and NakamaManager.is_authenticated:
		NakamaManager.save_game()
		DebugLogger.log_info("SceneChange", "Cloud save before scene transition")
	elif LocalSaveManager:
		LocalSaveManager.save_game()
		DebugLogger.log_info("SceneChange", "Local save before scene transition")
	else:
		push_warning("No save manager available for pre-transition save")

# Async scene loading with error recovery
func _change_scene_async(scene_path: String) -> void:
	# Check if scene is already preloaded
	if scene_path in preloaded_scenes:
		var packed_scene = preloaded_scenes[scene_path]
		var error = get_tree().change_scene_to_packed(packed_scene)
		if error != OK:
			_handle_scene_load_error(scene_path, error)
		else:
			# Remove from cache after use
			preloaded_scenes.erase(scene_path)
		return

	# Use async loading for non-preloaded scenes
	is_loading_async = true
	var error = ResourceLoader.load_threaded_request(scene_path)

	if error != OK:
		_handle_scene_load_error(scene_path, error)
		is_loading_async = false
		return

	# Poll loading progress
	while true:
		var status = ResourceLoader.load_threaded_get_status(scene_path, load_progress)

		match status:
			ResourceLoader.THREAD_LOAD_LOADED:
				# Scene loaded successfully
				var packed_scene = ResourceLoader.load_threaded_get(scene_path)
				error = get_tree().change_scene_to_packed(packed_scene)
				if error != OK:
					_handle_scene_load_error(scene_path, error)
				break

			ResourceLoader.THREAD_LOAD_IN_PROGRESS:
				# Still loading, wait a frame
				await get_tree().process_frame

			ResourceLoader.THREAD_LOAD_FAILED, ResourceLoader.THREAD_LOAD_INVALID_RESOURCE:
				# Load failed
				_handle_scene_load_error(scene_path, ERR_FILE_CANT_OPEN)
				break

	is_loading_async = false

# Handle scene loading errors with fallback
func _handle_scene_load_error(scene_path: String, error_code: int) -> void:
	var error_msg = "Failed to load scene '%s' (error %d)" % [scene_path, error_code]
	ErrorHandler.log_error(error_msg)
	push_error(error_msg)

	# Show user-friendly error
	show_notification("Failed to load scene. Returning to safe location...")

	# Try to load fallback scene
	var fallback = FALLBACK_SCENE if last_successful_scene.is_empty() else last_successful_scene

	if fallback != scene_path:  # Avoid infinite loop
		push_warning("Attempting to load fallback scene: " + fallback)
		var fallback_error = get_tree().change_scene_to_file(fallback)
		if fallback_error != OK:
			push_error("CRITICAL: Fallback scene also failed to load!")
			# Last resort: try to return to previous scene from history
			if scene_history.size() > 0:
				get_tree().change_scene_to_file(scene_history[-1])
	else:
		push_error("CRITICAL: Cannot load fallback scene (it's the scene that failed!)")
```

**Implementation Details**:
- Extends Phase 1.3 basic `change_scene()` with validation, async loading, error recovery
- Prevents concurrent transitions with in_progress flag
- Tracks block reasons for user-friendly error messages
- Uses async loading via `ResourceLoader.load_threaded_request()`
- Handles loading errors gracefully with fallback scene
- Stores transition metadata for future visual effects
- Updates scene history for multi-level navigation

---

### 3. Validation Framework with Priority System

**Variables**: Already defined in section 1 as:
```gdscript
var scene_validators: Array[Dictionary] = []  # {validator: Callable, priority: int, name: String}
```

**Core validation functions**:
```gdscript
# Register a custom scene validator with priority and name
# Higher priority validators run first (e.g., priority 100 before priority 0)
# Name is used for debugging and error messages
func register_scene_validator(validator: Callable, priority: int = 0, validator_name: String = "") -> void:
	# Check if validator already registered
	for v in scene_validators:
		if v.validator == validator:
			push_warning("Validator already registered: " + validator_name)
			return

	# Add validator with metadata
	var validator_data = {
		"validator": validator,
		"priority": priority,
		"name": validator_name if not validator_name.is_empty() else "Unnamed validator"
	}
	scene_validators.append(validator_data)

	# Sort by priority (highest first)
	scene_validators.sort_custom(func(a, b): return a.priority > b.priority)

	DebugLogger.log_info("Validators", "Registered scene validator: %s (priority %d)" % [validator_data.name, priority])

# Remove a scene validator
func unregister_scene_validator(validator: Callable) -> void:
	for i in range(scene_validators.size()):
		if scene_validators[i].validator == validator:
			var name = scene_validators[i].name
			scene_validators.remove_at(i)
			DebugLogger.log_info("Validators", "Unregistered scene validator: " + name)
			return

# Check if scene transition is allowed (with reason tracking)
# block_reason is an output parameter that gets set to why the transition was blocked
func can_change_to_scene(scene_path: String, block_reason: String = "") -> bool:
	# Built-in validation: Scene file must exist
	if not scene_exists(scene_path):
		block_reason = "Scene file does not exist: " + scene_path
		push_error(block_reason)
		return false

	# Built-in validation: Don't transition to same scene
	if is_current_scene(scene_path):
		block_reason = "Already in this scene"
		push_warning(block_reason)
		return false

	# Run custom validators in priority order
	for validator_data in scene_validators:
		var validator = validator_data.validator
		var validator_name = validator_data.name

		# Call validator (can return bool or Dictionary)
		var result = validator.call(scene_path)

		# Handle bool return (backward compatible)
		if result is bool:
			if not result:
				block_reason = "Blocked by validator: " + validator_name
				DebugLogger.log_info("Validators", "Scene transition blocked by: " + validator_name)
				return false

		# Handle Dictionary return {allowed: bool, reason: String}
		elif result is Dictionary:
			if not result.get("allowed", false):
				block_reason = result.get("reason", "Blocked by " + validator_name)
				DebugLogger.log_info("Validators", "Scene transition blocked: " + block_reason)
				return false
		else:
			push_error("Validator returned invalid type: " + validator_name)

	return true  # All validators passed
```

**Usage Examples** (from future level plans):

**Simple bool validator (backward compatible)**:
```gdscript
# In copper era scene network plan
func _ready():
	# Register with priority and name
	Global.register_scene_validator(_validate_copper_scene, 10, "Copper era unlock validator")

func _validate_copper_scene(scene_path: String) -> bool:
	var scene_id = _path_to_id(scene_path)
	if scene_id in locked_scenes:
		return false  # Block without custom message
	return true
```

**Dictionary validator with custom message (recommended)**:
```gdscript
func _validate_copper_scene(scene_path: String) -> Dictionary:
	var scene_id = _path_to_id(scene_path)
	if scene_id in locked_scenes:
		return {
			"allowed": false,
			"reason": "That area is locked. Complete previous tasks to unlock."
		}
	return {"allowed": true}
```

**Priority examples**:
- **Priority 100**: Critical validators (scene exists, not in transition) - built-in
- **Priority 50**: Level-wide validators (unlock gates, prerequisites)
- **Priority 10**: Feature-specific validators (quest requirements)
- **Priority 0**: Optional validators (warnings, recommendations)

**Implementation Details**:
- Validators return `bool` (simple) or `Dictionary` with reason (recommended)
- Multiple validators can be registered (level-specific, feature-specific)
- Validators run in priority order (highest first); first failure blocks transition
- Clean separation: core system provides framework, levels provide rules
- Validators can provide custom error messages via Dictionary return

---

### 4. Scene History Navigation

**Update scene history stack**:
```gdscript
# Update scene history when changing scenes
func _update_scene_history(from_scene: String, to_scene: String) -> void:
	# Don't add empty scenes
	if from_scene.is_empty():
		return

	# Add current scene to history
	scene_history.append(from_scene)

	# Limit history size
	if scene_history.size() > MAX_SCENE_HISTORY:
		scene_history.pop_front()  # Remove oldest

	DebugLogger.log_info("SceneHistory", "History size: %d, Last: %s" % [scene_history.size(), from_scene])
```

**Enhanced go_back() function** (extends Phase 1.3 version):
```gdscript
# Go back to previous scene (from Phase 1.3, but enhanced)
func go_back() -> void:
	if scene_history.is_empty():
		push_warning("No scene history to go back to")
		return

	var previous = scene_history.pop_back()  # Get and remove last scene
	change_scene(previous, false, "back")  # Don't skip validation

# Go back multiple steps in history
func go_back_steps(steps: int = 1) -> void:
	if steps < 1:
		push_warning("Invalid step count: " + str(steps))
		return

	if scene_history.size() < steps:
		push_warning("Not enough scene history (want %d, have %d)" % [steps, scene_history.size()])
		return

	# Remove intermediate scenes
	for i in range(steps - 1):
		scene_history.pop_back()

	# Navigate to target scene
	var target = scene_history.pop_back()
	change_scene(target, false, "back_%d" % steps)

# Clear scene history (useful for "return to main menu")
func clear_scene_history() -> void:
	scene_history.clear()
	DebugLogger.log_info("SceneHistory", "Scene history cleared")
```

---

### 5. Scene Preloading

**Preload commonly accessed scenes**:
```gdscript
# Preload a scene for instant access
func preload_scene(scene_path: String) -> void:
	if scene_path in preloaded_scenes:
		push_warning("Scene already preloaded: " + scene_path)
		return

	if not ResourceLoader.exists(scene_path):
		push_error("Cannot preload non-existent scene: " + scene_path)
		return

	# Limit cache size
	if preloaded_scenes.size() >= MAX_PRELOADED_SCENES:
		# Remove oldest entry (FIFO)
		var oldest_key = preloaded_scenes.keys()[0]
		preloaded_scenes.erase(oldest_key)
		DebugLogger.log_info("ScenePreload", "Evicted oldest preloaded scene: " + oldest_key)

	# Load scene into cache
	var packed_scene = load(scene_path)
	if packed_scene:
		preloaded_scenes[scene_path] = packed_scene
		DebugLogger.log_info("ScenePreload", "Preloaded scene: " + scene_path)
	else:
		push_error("Failed to preload scene: " + scene_path)

# Unload a preloaded scene
func unload_preloaded_scene(scene_path: String) -> void:
	if scene_path in preloaded_scenes:
		preloaded_scenes.erase(scene_path)
		DebugLogger.log_info("ScenePreload", "Unloaded preloaded scene: " + scene_path)

# Clear all preloaded scenes
func clear_preloaded_scenes() -> void:
	preloaded_scenes.clear()
	DebugLogger.log_info("ScenePreload", "Cleared all preloaded scenes")
```

---

### 6. Helper Functions

**These are already defined in Phase 1.3**, but documented here for completeness:
```gdscript
# Validate that a scene file exists
func scene_exists(scene_path: String) -> bool:
	return ResourceLoader.exists(scene_path)

# Get current scene path (from Phase 1.3, enhanced in change_scene())
func get_current_scene_path() -> String:
	if get_tree() and get_tree().current_scene:
		return get_tree().current_scene.scene_file_path
	return ""

# Check if transitioning to same scene
func is_current_scene(scene_path: String) -> bool:
	return get_current_scene_path() == scene_path

# Get loading progress (0.0 to 1.0) during async load
func get_scene_load_progress() -> float:
	if not is_loading_async or load_progress.is_empty():
		return 0.0
	return load_progress[0] if load_progress.size() > 0 else 0.0
```

---

### 7. Debug Logging Integration

**Already exists in Phase 1.21** `debug_logger.gd`, referenced throughout this plan:

```gdscript
# In DebugLogger (existing from Phase 1.21)
func log_scene_change(from_scene: String, to_scene: String, reason: String) -> void:
	var message = "Scene: %s -> %s (%s)" % [
		_get_scene_name(from_scene),
		_get_scene_name(to_scene),
		reason
	]
	log_info("SCENE", message)

func log_info(category: String, message: String) -> void:
	# Implementation in Phase 1.21
	pass
```

**Integration points throughout this plan**:
- Scene transitions logged in `change_scene()`
- Validator registration/unregistration logged
- Scene history updates logged
- Scene preloading logged
- Error recovery logged
- All logs include category for filtering

---

### 8. Backward Compatibility & Migration

**Deprecate old function**:
```gdscript
# DEPRECATED: Use change_scene() instead
# Kept temporarily for backward compatibility during rewrite
func change_scene_with_check(scene_tree: SceneTree, scene_path: String) -> void:
	push_warning("change_scene_with_check() is deprecated. Use Global.change_scene() instead.")
	change_scene(scene_path)
```

**Migration path**:
1. Keep `change_scene_with_check()` as wrapper during rewrite
2. Update all scene transition calls to use `change_scene()`
3. Remove `change_scene_with_check()` once migration complete
4. Remove victory/caught coupling

---

## Code Examples

### Basic Scene Change

```gdscript
# From any scene script
func _on_bar_button_pressed():
	Global.change_scene("res://level1/bar.tscn")
```

### Scene Change with Custom Validation

```gdscript
# Copper era validator (in 2.2-scene-network.md)
func _validate_secret_passage(scene_path: String) -> bool:
	if scene_path == "res://level1/secret_passage.tscn":
		if not Level1Vars.found_secret_door:
			Global.show_stat_notification("You haven't discovered this location yet")
			return false
	return true

# Register on ready
func _ready():
	Global.register_scene_validator(_validate_secret_passage)
```

### Skip Validation (Debug/Testing)

```gdscript
# For debug menu or testing
func _on_debug_warp_pressed():
	Global.change_scene("res://level1/secret_passage.tscn", true)  # Skip validation
```

---

## Testing Strategy

### Unit Tests

Create `tests/test_scene_management.gd`:

```gdscript
extends GutTest

func before_each():
	Global.scene_validators.clear()

# Test: Scene change with no validators
func test_scene_change_no_validators():
	var can_change = Global.can_change_to_scene("res://level1/bar.tscn")
	assert_true(can_change, "Should allow scene change with no validators")

# Test: Scene validation blocked
func test_scene_validation_blocks():
	# Register a validator that always blocks
	Global.register_scene_validator(func(path): return false)

	var can_change = Global.can_change_to_scene("res://level1/bar.tscn")
	assert_false(can_change, "Validator should block scene change")

# Test: Multiple validators
func test_multiple_validators():
	# Validator 1: allows all
	Global.register_scene_validator(func(path): return true)
	# Validator 2: blocks secret passage
	Global.register_scene_validator(func(path): return path != "res://level1/secret_passage.tscn")

	assert_true(Global.can_change_to_scene("res://level1/bar.tscn"), "Bar should be allowed")
	assert_false(Global.can_change_to_scene("res://level1/secret_passage.tscn"), "Secret passage should be blocked")

# Test: Validator registration/unregistration
func test_validator_registration():
	var validator = func(path): return false

	Global.register_scene_validator(validator)
	assert_eq(Global.scene_validators.size(), 1, "Validator registered")

	Global.unregister_scene_validator(validator)
	assert_eq(Global.scene_validators.size(), 0, "Validator unregistered")

# Test: Scene exists validation
func test_scene_exists():
	assert_false(Global.scene_exists("res://nonexistent.tscn"), "Nonexistent scene returns false")
	# Note: Testing existing scene requires actual scene file

# Test: Same scene validation
func test_same_scene_blocked():
	# Create a mock scene tree test
	# Set current scene path
	Global.current_scene_path = "res://level1/furnace.tscn"

	# Try to change to same scene
	var block_reason = ""
	var can_change = Global.can_change_to_scene("res://level1/furnace.tscn", block_reason)

	assert_false(can_change, "Should block transition to same scene")
	assert_true(block_reason.contains("Already in this scene"), "Should provide reason")

# Test: Validator priority ordering
func test_validator_priority():
	var call_order = []

	# Register validators with different priorities
	Global.register_scene_validator(
		func(path): call_order.append("low"); return true,
		0,
		"Low priority"
	)
	Global.register_scene_validator(
		func(path): call_order.append("high"); return true,
		100,
		"High priority"
	)
	Global.register_scene_validator(
		func(path): call_order.append("medium"); return true,
		50,
		"Medium priority"
	)

	# Run validation
	Global.can_change_to_scene("res://test.tscn")

	# Check call order
	assert_eq(call_order, ["high", "medium", "low"], "Validators should run in priority order")

# Test: Dictionary validator with reason
func test_validator_with_reason():
	var test_reason = "Custom block message"
	Global.register_scene_validator(
		func(path): return {"allowed": false, "reason": test_reason},
		0,
		"Reason validator"
	)

	var block_reason = ""
	var can_change = Global.can_change_to_scene("res://test.tscn", block_reason)

	assert_false(can_change, "Should block")
	assert_eq(block_reason, test_reason, "Should return custom reason")

# Test: Scene history navigation
func test_scene_history():
	Global.scene_history.clear()

	# Simulate scene changes
	Global._update_scene_history("res://scene1.tscn", "res://scene2.tscn")
	Global._update_scene_history("res://scene2.tscn", "res://scene3.tscn")

	assert_eq(Global.scene_history.size(), 2, "Should have 2 scenes in history")
	assert_eq(Global.scene_history[0], "res://scene1.tscn", "First entry should be scene1")
	assert_eq(Global.scene_history[1], "res://scene2.tscn", "Second entry should be scene2")

# Test: Scene history max size
func test_scene_history_limit():
	Global.scene_history.clear()

	# Add more scenes than MAX_SCENE_HISTORY
	for i in range(Global.MAX_SCENE_HISTORY + 5):
		Global._update_scene_history("res://scene%d.tscn" % i, "res://scene%d.tscn" % (i+1))

	assert_eq(Global.scene_history.size(), Global.MAX_SCENE_HISTORY, "History should be capped at MAX_SCENE_HISTORY")

# Test: Scene preloading
func test_scene_preload():
	# Note: Requires actual scene file to test fully
	# This tests the cache management logic
	Global.preloaded_scenes.clear()

	# This would work with a real scene file:
	# Global.preload_scene("res://level1/bar.tscn")
	# assert_true("res://level1/bar.tscn" in Global.preloaded_scenes)
	pass  # TODO: Create test scene file for integration tests
```

**Run tests:**
```bash
godot --headless --script res://addons/gut/gut_cmdln.gd -gtest=tests/test_scene_management.gd
```

### Integration Tests

| Scenario | Setup | Action | Expected Result |
|----------|-------|--------|-----------------|
| Basic scene change | In furnace | Change to bar | Saves, logs, switches scene async |
| Blocked by validator | Locked scene | Try to change | Validator blocks, shows user message |
| Skip validation | Locked scene | Change with skip=true | Changes anyway (debug) |
| Save before change | Modified stats | Change scene | Stats saved before transition |
| Nonexistent scene | Any scene | Change to invalid path | Error logged, fallback scene loaded |
| Scene load failure | Any scene | Corrupt scene file | Error recovery loads fallback |
| Async loading | Heavy scene | Change scene | Non-blocking load with progress tracking |
| Go back navigation | Scene A->B->C | Call go_back() | Returns to B, removes C from history |
| Multi-step back | Scene A->B->C->D | go_back_steps(2) | Returns to B, skips C |
| Scene history limit | 15 scene changes | Check history size | Capped at MAX_SCENE_HISTORY (10) |
| Preloaded scene | Preload bar | Change to bar | Instant transition (no async load) |
| Validator priority | 3 validators (0, 50, 100) | Trigger validation | Run in order: 100, 50, 0 |
| Dictionary validator | Custom reason validator | Block transition | Shows custom user message |
| Concurrent transitions | Scene change in progress | Try another change | Second blocked with warning |
| Transition metadata | Change with type "fade" | Check metadata | Type stored for future effects |

### Manual Test Criteria

**Basic Functionality**:
- [ ] Navigate between multiple scenes (furnace, bar, shop)
- [ ] Verify save occurs before each transition
- [ ] Check DebugLogger shows all scene transitions with metadata
- [ ] Verify async loading doesn't freeze UI
- [ ] Check loading progress displayed during heavy scene loads

**Validation Framework**:
- [ ] Register custom validator with priority, verify it blocks transitions
- [ ] Validator shows custom error message to user
- [ ] Unregister validator, verify transitions work again
- [ ] Multiple validators run in priority order
- [ ] Skip validation in debug mode, verify bypass works

**Navigation & History**:
- [ ] Use back button to return to previous scene
- [ ] Go back multiple steps with go_back_steps()
- [ ] Scene history limited to 10 scenes
- [ ] Clear history and verify go_back() shows warning

**Error Recovery**:
- [ ] Try changing to nonexistent scene, verify fallback loads
- [ ] Simulate scene load failure, verify recovery
- [ ] Check ErrorHandler logs the failure
- [ ] Verify user sees friendly error message

**Preloading**:
- [ ] Preload a scene, verify instant transition
- [ ] Preload cache limited to 3 scenes
- [ ] Oldest scene evicted when cache full
- [ ] Unload preloaded scene manually

**Edge Cases**:
- [ ] Try transition while one in progress (should block)
- [ ] Transition to same scene (should block)
- [ ] Clear scene history mid-game
- [ ] Fallback scene itself fails (last resort: use history)

---

## Files to Modify

**res://autoloads/global.gd** (~300 lines added/modified)
- Add scene management variables (history, validators, preload cache, metadata)
- **Enhance** `change_scene()` function (from Phase 1.3) with validation, async loading, error recovery
- **Enhance** `go_back()` function (from Phase 1.3) with history stack
- Add `register_scene_validator()` with priority and naming
- Add `unregister_scene_validator()`
- Add `can_change_to_scene()` with reason tracking
- Add `_change_scene_async()` for async loading
- Add `_handle_scene_load_error()` for error recovery
- Add `_save_before_transition()` helper
- Add `_update_scene_history()` for history management
- Add `go_back_steps()` for multi-level navigation
- Add `clear_scene_history()`
- Add `preload_scene()`, `unload_preloaded_scene()`, `clear_preloaded_scenes()`
- Add `get_scene_load_progress()` helper
- Deprecate `change_scene_with_check()` (keep as wrapper temporarily)
- Remove victory/caught coupling from scene changes

**tests/test_scene_management.gd** (~200 lines new)
- Unit tests for validation framework
- Test validator registration/unregistration with priority
- Test validator priority ordering
- Test Dictionary validator with custom reasons
- Test scene existence checks
- Test same-scene blocking
- Test scene history navigation
- Test scene history size limits
- Test scene preloading cache management

**res://scenes/main_menu.tscn** (create if doesn't exist)
- Fallback scene for error recovery
- Simple safe scene that always loads

**res://scenes/error_scene.tscn** (create if doesn't exist, optional)
- Dedicated error recovery scene
- Shows user-friendly error message

---

## Design Values (Reference)

### Validation Behavior

- **Multiple validators**: All must pass (AND logic)
- **Validator order**: Priority-based (highest priority first), then registration order
- **Validator return types**: `bool` (simple) or `Dictionary` with reason (recommended)
- **Built-in validations**: Always run first (scene exists, not same scene)
- **Skip validation**: Debug/testing only, not for normal gameplay
- **Priority ranges**:
  - 100+: Critical system validators
  - 50-99: Level-wide validators
  - 10-49: Feature-specific validators
  - 0-9: Optional validators

### Scene History

- **Max history size**: 10 scenes (configurable via MAX_SCENE_HISTORY)
- **Storage method**: FIFO queue (oldest removed when full)
- **Empty scenes**: Not added to history
- **Clear on**: Level transitions, return to main menu
- **Purpose**: Multi-level back navigation, breadcrumb trails

### Async Loading

- **Method**: `ResourceLoader.load_threaded_request()`
- **Progress tracking**: Available via `load_progress` array
- **UI impact**: Non-blocking (game responsive during load)
- **Fallback**: Instant load for preloaded scenes
- **Error handling**: Graceful degradation to fallback scene

### Scene Preloading

- **Cache size**: 3 scenes maximum (configurable via MAX_PRELOADED_SCENES)
- **Eviction policy**: FIFO (oldest evicted first)
- **Use case**: Frequently accessed scenes (main menu, hub areas)
- **Memory trade-off**: Faster transitions vs memory usage
- **Auto-removal**: Scene removed from cache after use

### Error Recovery

- **Fallback scene**: `res://scenes/main_menu.tscn`
- **Secondary fallback**: Last successful scene
- **Last resort**: Previous scene from history
- **User notification**: Friendly error message shown
- **Logging**: All errors logged to ErrorHandler

### Save Behavior

- **When**: Before every scene change (prevents data loss)
- **Where**: Cloud if authenticated (NakamaManager), local otherwise
- **What**: Full game state (stats, currency, level vars, etc.)
- **Skip scenarios**: None (always save to prevent data loss)

### Transition Metadata

- **Purpose**: Future visual effects system
- **Stored data**: type, from, to, timestamp, skip_validation
- **Transition types**: "default", "fade", "wipe", "instant", "back", etc.
- **Access**: Via `transition_metadata` Dictionary
- **Usage**: Reserved for future plan (transition effects)

### Logging

- **Format**: "Scene: [from] -> [to] ([reason])"
- **Category**: "SCENE" for transitions, "Validators" for validation, "SceneHistory" for nav
- **Level**: INFO for normal operations, WARNING for blocks, ERROR for failures
- **Always logged**: Yes (all transitions, validator actions, errors tracked)
- **Debug info**: Includes transition type, validator names, error codes

---

## Dependencies & Integration

### Depends On:
- **Phase 1.3 (Global Autoload)** - Global.gd exists with basic scene management
- **Phase 1.21 (DebugLogger)** - Scene change logging, validator logging
- **Phase 1.22 (ErrorHandler)** - Error logging for scene load failures
- **Phase 1.19 (NakamaManager)** - Cloud save integration (optional)
- **Phase 1.x (LocalSaveManager)** - Local save integration [TODO: verify plan exists]

### Used By:
- **All scene scripts** - Call `Global.change_scene()`
- **Level plans (2.1, 2.x, 3.x, etc.)** - Register scene validators
- **Debug systems** - Skip validation for testing, use preloading
- **UI navigation** - Back buttons, scene menus, history navigation
- **Loading screens (future)** - Monitor `get_scene_load_progress()`
- **Transition effects (future)** - Use `transition_metadata`

### Provides APIs For:

**Scene Changing (Enhanced from Phase 1.3)**:
```gdscript
Global.change_scene(scene_path, skip_validation, transition_type)  # Async scene change
Global.go_back()                              # Back to previous (enhanced)
Global.go_back_steps(steps)                   # Back multiple scenes
Global.clear_scene_history()                  # Reset navigation history
```

**Validation Framework (New)**:
```gdscript
Global.register_scene_validator(validator, priority, name)  # Add custom rule
Global.unregister_scene_validator(validator)                # Remove custom rule
Global.can_change_to_scene(scene_path, block_reason)        # Check if allowed
```

**Scene Preloading (New)**:
```gdscript
Global.preload_scene(scene_path)              # Cache scene for instant load
Global.unload_preloaded_scene(scene_path)     # Remove from cache
Global.clear_preloaded_scenes()               # Clear entire cache
```

**Helpers**:
```gdscript
Global.scene_exists(scene_path)               # Check if scene file exists
Global.get_current_scene_path()               # Get current scene (Phase 1.3)
Global.is_current_scene(scene_path)           # Check if in scene
Global.get_scene_load_progress()              # Get async load progress (0.0-1.0)
```

**Read-Only Data Access**:
```gdscript
Global.scene_history                          # Array[String] of past scenes
Global.transition_metadata                    # Dictionary with transition info
Global.is_loading_async                       # bool - is async load in progress
Global.scene_transition_in_progress           # bool - is any transition active
```

---

## Notes & Decisions

**Decision 1**: Extend Phase 1.3, don't duplicate
- **Rationale**: Phase 1.3 already defines basic scene management
- **Benefit**: Avoids code duplication, maintains single source of truth
- **Implementation**: Enhance existing functions, add new capabilities
- **Clarification**: This plan documents enhancements clearly

**Decision 2**: Priority-based validation framework
- **Rationale**: Some validators more critical than others (existence check vs optional warnings)
- **Benefit**: Predictable execution order, efficient short-circuiting
- **Alternative considered**: FIFO only - rejected as inflexible
- **Priority ranges**: 100+ (system), 50-99 (level), 10-49 (feature), 0-9 (optional)

**Decision 3**: Dictionary validator return for custom messages
- **Rationale**: User needs to know WHY transition blocked
- **Benefit**: Better UX, clearer error messages
- **Backward compatible**: Still supports simple `bool` return
- **Recommended**: Use Dictionary format for new validators

**Decision 4**: Async loading by default
- **Rationale**: Large scenes can freeze UI with synchronous loading
- **Benefit**: Responsive UI, better user experience
- **Cost**: Slightly more complex implementation
- **Optimization**: Preloaded scenes bypass async (instant load)

**Decision 5**: Robust error recovery system
- **Rationale**: Scene loading can fail (corrupt files, missing resources)
- **Benefit**: Game doesn't crash, user sees helpful message
- **Fallback chain**: Requested scene -> Fallback scene -> Last successful -> History
- **User notification**: Friendly error message, not technical details

**Decision 6**: Scene history stack (10 scenes max)
- **Rationale**: Users expect "back" navigation, especially on mobile
- **Benefit**: Natural navigation patterns, multi-level back support
- **Limit**: 10 scenes prevents memory bloat
- **Use case**: Breadcrumb navigation, return to hub

**Decision 7**: Scene preloading cache (3 scenes max)
- **Rationale**: Frequently accessed scenes should load instantly
- **Benefit**: Perceived performance improvement
- **Trade-off**: Memory usage vs speed
- **Limit**: 3 scenes balances benefit vs cost
- **Eviction**: FIFO (oldest removed first)

**Decision 8**: Transition metadata structure
- **Rationale**: Future transition effects plan needs context
- **Benefit**: Can add visual effects without changing scene management
- **Current use**: Store type, from, to, timestamp
- **Future use**: Transition effects read this metadata

**Decision 9**: Always save before scene change
- **Rationale**: Prevents data loss if scene load fails or crashes
- **Benefit**: Player progress never lost on transition
- **Cost**: Minimal (save is fast, already implemented from Phase 1.19/1.x)

**Decision 10**: Remove victory/caught coupling
- **Rationale**: These systems are being deprecated/redesigned
- **Benefit**: Clean base system, game-agnostic
- **Note**: Caught/victory logic can be re-added as validators if needed later

**Decision 11**: Scene network deferred to level plans
- **Rationale**: Each level has different scenes/rules
- **Benefit**: Centralized per-level (copper era map in 2.1, not scattered)
- **Scalability**: Level 2 gets its own network plan, etc.

**Decision 12**: No transition effects implementation yet
- **Rationale**: Backend first, visuals later
- **Benefit**: Can test mechanics without animation dependencies
- **Future**: Separate plan for fade/wipe effects (reads transition_metadata)
- **Prepared**: Metadata structure in place for future use

---

## Implementation Checklist

Before marking Phase 1.8 complete:

**Core Variables & Setup**:
- [ ] All scene management variables added to global.gd (history, validators, cache, metadata)
- [ ] Fallback scene created (`res://scenes/main_menu.tscn`)
- [ ] Optional error scene created (`res://scenes/error_scene.tscn`)

**Enhanced Scene Changing**:
- [ ] `change_scene()` function enhanced with async loading and error recovery
- [ ] `_change_scene_async()` implemented for background loading
- [ ] `_handle_scene_load_error()` implemented with fallback chain
- [ ] `_save_before_transition()` helper implemented
- [ ] Transition metadata stored on each scene change
- [ ] Save integration verified (cloud and local)

**Validation Framework**:
- [ ] `scene_validators` array structure (Dictionary with priority) implemented
- [ ] `register_scene_validator()` with priority and naming implemented
- [ ] `unregister_scene_validator()` implemented
- [ ] `can_change_to_scene()` enhanced with reason tracking
- [ ] Validators support both `bool` and `Dictionary` return types
- [ ] Priority-based sorting verified

**Scene History Navigation**:
- [ ] `scene_history` array and MAX_SCENE_HISTORY implemented
- [ ] `_update_scene_history()` called on scene changes
- [ ] `go_back()` enhanced to use history stack
- [ ] `go_back_steps()` implemented for multi-level navigation
- [ ] `clear_scene_history()` implemented
- [ ] History size limiting works correctly

**Scene Preloading**:
- [ ] `preloaded_scenes` cache and MAX_PRELOADED_SCENES implemented
- [ ] `preload_scene()` implemented with FIFO eviction
- [ ] `unload_preloaded_scene()` implemented
- [ ] `clear_preloaded_scenes()` implemented
- [ ] Preloaded scenes used in async loading (instant transition)

**Helpers & Utilities**:
- [ ] `get_scene_load_progress()` implemented
- [ ] Helper functions verified (scene_exists, get_current_scene_path, is_current_scene)
- [ ] All helpers work with async loading

**Logging & Debugging**:
- [ ] DebugLogger integration verified for all scene operations
- [ ] Validator registration/unregistration logged
- [ ] Scene history updates logged
- [ ] Error recovery logged
- [ ] All logs include appropriate categories

**Backward Compatibility**:
- [ ] `change_scene_with_check()` deprecated (kept as wrapper)
- [ ] Victory/caught coupling removed from scene changes
- [ ] Existing scene transitions work with new API

**Testing**:
- [ ] Unit tests written and passing (10+ tests covering all features)
- [ ] Validator priority ordering tested
- [ ] Dictionary validator with custom reason tested
- [ ] Scene history navigation tested
- [ ] Scene history size limit tested
- [ ] Scene preloading cache tested
- [ ] Same scene blocking tested
- [ ] Integration tests completed (15+ scenarios)
- [ ] Manual tests verified (all categories: basic, validation, navigation, error, preloading, edge cases)

**Documentation**:
- [ ] Code comments added to all new functions
- [ ] API usage examples verified
- [ ] This plan updated with any implementation changes

---

**Last Updated**: 2025-12-07
**Maintainer**: Claude + User collaboration
**Plan Version**: 2.0 (Enhanced scene management - async loading, validation framework, error recovery)
