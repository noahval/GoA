# 1.21 Auth Screen Plan

## Overview
Create authentication/loading screen with two-stage UX: (1) click-to-start overlay showing begin.jpg, (2) auth panel with title.webm video background. Handles player login while preloading game assets. The auth screen IS the loading screen - authentication happens during initial load, then transitions directly to the first game scene (furnace.tscn). Provides three login methods: Google OAuth, username/password, and guest play (device ID). Designed to reference existing design guidelines for visual cohesion.

## Purpose
- Two-stage UX: begin.jpg click-to-start overlay, then auth panel with video background
- Authenticate players via NakamaClient (from [1.19-nakama-server.md](c:\GoA\.claude\plans\1.19-nakama-server.md))
- Background load first scene (furnace.tscn) during both stages (begin.jpg display + auth selection)
- Satisfy browser autoplay policies via click-to-start interaction
- Provide guest option for players who don't want persistent accounts
- Use design system from guideline docs for consistent look and feel
- Clean rebuild - no reuse of v1 spaghetti code

---

## Design Philosophy

**Reference Guidelines, Don't Rebuild**
This plan references design values from:
- [1.10-default-theme.md](c:\GoA\.claude\plans\1.10-default-theme.md) - Colors, button styles, typography
- [1.13-scene-template.md](c:\GoA\.claude\plans\1.13-scene-template.md) - ResponsiveLayout patterns
- [1.14-button-hierarchy.md](c:\GoA\.claude\plans\1.14-button-hierarchy.md) - Button type concepts

**Why This Matters**:
If design guidelines change (e.g., theme colors updated), auth screen inherits the changes automatically by referencing the theme resource rather than hard-coding values.

---

## Part 1: Scene Structure

### 1.1 File Structure
**Files to create**:
- `level1/auth_screen.tscn` - Auth/loading screen scene (replaces old loading_screen.tscn)
- `level1/auth_screen.gd` - Auth/loading screen script
- `level1/google_signin.gd` - Clean Google OAuth implementation (web only)

**Files to reuse**:
- `level1/begin.jpg` - Click-to-start overlay image (stage 1)
- `level1/title.webm` - Background video for auth panel (stage 2)

**Files to delete** (v1 spaghetti cleanup):
- `login_popup.tscn`
- `login_popup.gd`
- `godot_web_auth.gd` (old web auth, rebuild clean)
- `google_auth.js` (old OAuth JS, rebuild clean)

**Note**: Auth screen is the ONLY loading screen. No separate loading_screen.tscn.

### 1.2 Node Hierarchy
```
AuthScreen (Control, anchors fill)
├── BeginOverlay (Control, full rect, initially visible, z-index: 10)
│   └── BeginButton (TextureButton, full rect, shows level1/begin.jpg)
│       └── (TextureButton stretch_mode: STRETCH_KEEP_ASPECT_COVERED for cover behavior)
├── Background (VideoStreamPlayer, shows level1/title.webm, initially hidden/paused, expand = true)
├── CenterContainer (centers auth panel, initially hidden, z-index: 5)
│   └── AuthPanel (Panel, uses default_theme.tres, fixed width: 800px)
│       └── MarginContainer (20px margins)
│           └── MainVBox (VBoxContainer, spacing: 10px)
│               ├── TitleLabel (Label, "Welcome to GoA")
│               ├── SubtitleLabel (Label, "Sign in to save your progress")
│               ├── Separator1 (HSeparator)
│               ├── GoogleButton (Button, "Sign in with Google")
│               ├── Separator2 (HSeparator)
│               ├── OrLabel (Label, "or")
│               ├── UsernameContainer (HBoxContainer)
│               │   ├── UsernameLabel (Label, "Username:")
│               │   └── UsernameInput (LineEdit, max 20 chars)
│               ├── PasswordContainer (HBoxContainer)
│               │   ├── PasswordLabel (Label, "Password:")
│               │   └── PasswordInput (LineEdit, secret, max 50 chars)
│               ├── ButtonContainer (HBoxContainer, spacing: 15px)
│               │   ├── CreateAccountButton (Button, "Create Account", theme_type_variation = "AffirmativeButton")
│               │   └── LoginButton (Button, "Login", theme_type_variation = "AffirmativeButton")
│               ├── Separator3 (HSeparator)
│               ├── DeviceAccountButton (Button, "Device Account")
│               ├── StatusLabel (Label, dynamic feedback, centered)
│               └── LoadingIndicator (optional, shows "Loading..." during background load)
```

**Note**: Auth panel is 800px wide (landscape only, from 1.11-responsive-layout-guide.md).

### 1.3 Theme Integration
**All UI elements use default_theme.tres** (from 1.10-default-theme.md):
- Panel: Orange 30% opacity background, 4px corner radius
- Labels: White text, 25px base font (auto-scales with ResponsiveLayout)
- Buttons: Reference theme variations

**Button Theme Variations**:
- GoogleButton: Default (orange) - third-party auth
- CreateAccountButton: `theme_type_variation = "AffirmativeButton"` (blue) - positive action
- LoginButton: `theme_type_variation = "AffirmativeButton"` (blue) - positive action
- GuestButton: Default (orange) - anonymous play

**Why These Themes?**:
- Affirmative (blue) = Positive action (create account, login with persistent account)
- Standard (orange) = Neutral/anonymous actions (Google OAuth, guest play)
- Follows button type philosophy from 1.14-button-hierarchy.md

**Status Label Colors** (referenced from default_theme.tres):
- Success: Light blue `Color(0.529, 0.808, 0.922, 1.0)` (sky blue, matches affirmative button text)
- Error: Light orange/yellow `Color(1, 1, 0.8, 1)` (matches button hover text)
- Loading: White `Color(1, 1, 1, 1)` (normal text)

### 1.4 Two-Stage Flow

**Stage 1: Click-to-Start (begin.jpg)**
- Full-screen begin.jpg overlay (TextureButton with cover behavior)
- Player clicks anywhere on the image to proceed
- Satisfies browser autoplay policies (user interaction required)
- Background loading starts immediately (furnace.tscn + title.webm preload)

**Stage 2: Auth Selection (title.webm + auth panel)**
- begin.jpg overlay hides
- title.webm video starts playing (now allowed due to user interaction)
- Auth panel appears with login options
- Player chooses auth method while loading continues

**Implementation**:
```gdscript
var has_clicked_begin = false

func _ready():
    # Connect signals
    NakamaClient.authentication_succeeded.connect(_on_auth_success)
    NakamaClient.authentication_failed.connect(_on_auth_failed)

    # Initial state: Show begin.jpg, hide auth UI
    begin_overlay.visible = true
    begin_button.pressed.connect(_on_begin_clicked)
    background_video.visible = false
    background_video.paused = true
    center_container.visible = false

    # Start background loading immediately
    _start_background_load()

func _on_begin_clicked():
    if has_clicked_begin:
        return
    has_clicked_begin = true

    # Hide begin.jpg overlay
    begin_overlay.visible = false

    # Show and play video (user interaction already happened)
    background_video.visible = true
    background_video.paused = false
    background_video.play()

    # Show auth panel
    center_container.visible = true
```

**BeginButton Configuration**:
```gdscript
# TextureButton properties for cover behavior
begin_button.texture_normal = preload("res://level1/begin.jpg")
begin_button.stretch_mode = TextureButton.STRETCH_KEEP_ASPECT_COVERED
begin_button.ignore_texture_size = true
# Anchors: Full Rect (preset 15)
```

**Benefits**:
- begin.jpg loads instantly (static image)
- Maximum loading time (loading happens during both stages)
- Browser autoplay compliance (click enables video/audio)
- Beautiful UX (static image transitions to video)
- Player controls when to proceed

---

## Part 2: Authentication Methods

Three authentication methods, all required (no skip option):

### 2.1 Google OAuth (Web Only)
**UI**: "Sign in with Google" button at top

**Purpose**: Third-party authentication for web builds via Google accounts

**Flow**:
1. User clicks "Sign in with Google"
2. Show status: "Opening Google sign-in..."
3. Trigger clean Google OAuth flow (new implementation, no v1 code)
4. JavaScript OAuth returns token
5. Call `NakamaClient.authenticate_google(token)`
6. Wait for `authentication_succeeded` or `authentication_failed` signal

**Implementation** (`google_signin.gd`, clean rebuild):
```gdscript
extends Node

# Clean Google OAuth implementation for web builds
func start_google_auth() -> void:
    if not OS.has_feature("web"):
        push_error("Google auth only works in web builds")
        return

    # Trigger Google OAuth flow via JavaScript
    # (New clean implementation, not reusing v1 spaghetti)
    JavaScriptBridge.eval("""
        // Inline Google OAuth initialization
        // TODO: Implement clean OAuth flow
    """)
```

**Note**: Clean rebuild, NO reuse of godot_web_auth.gd or google_auth.js

### 2.2 Username/Password (Create Account)
**UI**: Two input fields + "Create Account" button

**Validation**:
- Username: Min 3 chars, max 20 chars
- Password: Min 6 chars, max 50 chars

**Flow**:
1. User enters username and password
2. User clicks "Create Account"
3. Validate inputs (show error if invalid)
4. Call `NakamaClient.authenticate_email(username, password, create_account=true)`
5. Wait for signal

**Implementation**:
```gdscript
func _on_create_account_pressed():
    var username = username_input.text.strip_edges()
    var password = password_input.text

    if not _validate_credentials(username, password):
        return

    _disable_all_buttons()
    show_status("Creating account...", true)

    var success = await NakamaClient.authenticate_email(username, password, true)
    # Handle response via signals
```

### 2.3 Username/Password (Login)
**UI**: Same input fields + "Login" button

**Flow**:
1. User enters username and password
2. User clicks "Login"
3. Validate inputs
4. Call `NakamaClient.authenticate_email(username, password, create_account=false)`
5. Wait for signal

### 2.4 Play as Guest (Device ID)
**UI**: "Play as Guest" button at bottom

**Purpose**: Anonymous authentication using device ID - creates cloud save linked to this PC without username/password

**Flow**:
1. User clicks "Play as Guest"
2. Show status: "Creating guest account..."
3. Call `NakamaClient.authenticate_device()` (uses OS.get_unique_id())
4. Wait for `authentication_succeeded` or `authentication_failed` signal
5. Cloud save created, linked to this device

**Implementation**:
```gdscript
func _on_guest_button_pressed():
    _disable_all_buttons()
    show_status("Creating guest account...", true)

    var success = await NakamaClient.authenticate_device()
    # Response handled via signals
```

**Note**: Guest accounts are persistent (device ID doesn't change), but not portable (can't access from other devices)

---

## Part 3: Signal Integration

### 3.1 Connect to NakamaClient Signals
```gdscript
func _ready():
    # Connect to NakamaClient signals (from 1.19-nakama-server.md)
    NakamaClient.authentication_succeeded.connect(_on_auth_success)
    NakamaClient.authentication_failed.connect(_on_auth_failed)
```

### 3.2 Auth Success Handler
```gdscript
func _on_auth_success(session_data: Dictionary):
    # Show success status (light blue color)
    show_status("Login successful! Welcome, %s" % session_data.username, "success")

    # Try to load cloud save
    var save_loaded = await NakamaClient.load_game()

    # Try to load user settings (UI scale, volume, etc.)
    var settings_loaded = await NakamaClient.load_settings()

    # Transition to first scene (furnace.tscn)
    _transition_to_game()
```

### 3.3 Auth Failed Handler
```gdscript
func _on_auth_failed(error: String):
    # Parse error message for user-friendly display
    var friendly_error = _parse_error_message(error)

    # Show error status (light orange/yellow color)
    show_status(friendly_error, "error")

    # Re-enable buttons for retry
    _enable_all_buttons()
```

### 3.4 Status Display Function
```gdscript
func show_status(message: String, status_type: String = "loading"):
    status_label.text = message

    # Apply colors from default_theme.tres
    match status_type:
        "success":
            # Light blue (matches affirmative button text)
            status_label.add_theme_color_override("font_color", Color(0.529, 0.808, 0.922, 1.0))
        "error":
            # Light orange/yellow (matches hover text)
            status_label.add_theme_color_override("font_color", Color(1, 1, 0.8, 1))
        "loading", _:
            # White (normal text)
            status_label.add_theme_color_override("font_color", Color(1, 1, 1, 1))
```

---

## Part 4: Loading Flow & Scene Transition

**Key Concept**: Auth screen IS the loading screen. No separate loading_screen.tscn.

### 4.1 Loading Flow
```
Game Start
    ↓
Auth Screen appears (level1/auth_screen.tscn)
    ↓
STAGE 1: begin.jpg overlay displays
    ↓
[Background loading starts immediately:]
    - ResourceLoader.load_threaded_request(Global.last_scene)
    - ResourceLoader.load_threaded_request(title.webm) if needed
    - Initialize Global stats
    - Initialize Level1Vars
    ↓
Player clicks begin.jpg
    ↓
STAGE 2: Auth panel appears, title.webm plays
    ↓
User authenticates (Google/Username/Guest)
    ↓
[Loading continues during auth selection]
    ↓
Auth completes (success or failure)
    ↓
IF Global.last_scene loaded:
    - Transition to Global.last_scene immediately
ELSE:
    - Show "Loading..." status (video continues playing)
    - Wait for Global.last_scene to finish loading
    - Transition to Global.last_scene
```

### 4.2 Background Loading Implementation
```gdscript
var loaded_scene: PackedScene = null
var is_loading_scene = false

func _ready():
    # Connect signals
    NakamaClient.authentication_succeeded.connect(_on_auth_success)
    NakamaClient.authentication_failed.connect(_on_auth_failed)

    # Start background loading player's last scene
    _start_background_load()

func _start_background_load():
    # Get scene path from Global (defaults to furnace for new players)
    var scene_path = Global.last_scene if Global.has("last_scene") else "res://level1/furnace.tscn"

    is_loading_scene = true
    # Load scene in background thread
    ResourceLoader.load_threaded_request(scene_path)

func _process(_delta):
    if is_loading_scene:
        var scene_path = Global.last_scene if Global.has("last_scene") else "res://level1/furnace.tscn"

        # Check load progress
        var status = ResourceLoader.load_threaded_get_status(scene_path)
        if status == ResourceLoader.THREAD_LOAD_LOADED:
            loaded_scene = ResourceLoader.load_threaded_get(scene_path)
            is_loading_scene = false
```

### 4.3 Transition Logic
```gdscript
func _transition_to_game():
    var scene_path = Global.last_scene if Global.has("last_scene") else "res://level1/furnace.tscn"

    if loaded_scene:
        # Scene already loaded - transition immediately
        Global.change_scene_with_check(scene_path)
    else:
        # Scene still loading - show loading indicator
        show_status("Loading game...", "loading")
        # Wait for scene to finish loading
        while is_loading_scene:
            await get_tree().process_frame
        Global.change_scene_with_check(scene_path)
```

### 4.4 Global.last_scene Variable
**Add to Global.gd**:
```gdscript
# Scene tracking for auth screen loading
var last_scene: String = "res://level1/furnace.tscn"  # Default to furnace for new players
```

**Update when changing scenes** (in Global.change_scene_with_check() or equivalent):
```gdscript
func change_scene_to(scene_path: String):
    # Save current scene before changing
    last_scene = scene_path
    # ... rest of scene change logic
```

**Save/load with game state**:
- Add `last_scene` to `_get_global_data()` in NakamaClient
- Load `last_scene` from cloud save in `_set_global_data()`

**Benefit**: Player loads into their last visited scene (furnace, level2, level3, etc.) automatically

---

## Part 5: Layout & Styling

### 5.1 Panel Sizing
**Fixed width**: 800px (landscape-only game per 1.11-responsive-layout-guide.md)
- Height: Auto-fit content
- Centered via CenterContainer
- No mobile/portrait support needed

**Implementation**:
```gdscript
# In auth_screen.tscn or _ready()
auth_panel.custom_minimum_size.x = 800
```

### 5.2 Font Scaling
Uses ResponsiveLayout.calculate_scale() to scale fonts based on resolution:
- Base: 25px (1280x720)
- 1920x1080: 37px (automatically scaled)
- Respects user's UI scale setting

### 5.3 Background Video
**File**: `level1/title.webm`
- Full-screen background video (same video used in old loading screen)
- VideoStreamPlayer with `expand = true` (maintains aspect ratio, covers screen, crops overflow)
- Provides cinematic visual context during authentication
- Loops during authentication process

---

## Part 6: Error Handling

### 6.1 Network Errors
**Scenarios**:
- Server unreachable
- No internet connection
- Timeout

**Handling**:
```gdscript
func _on_auth_failed(error: String):
    var friendly_message = _parse_error_message(error)
    show_status(friendly_message, "error")
    _enable_all_buttons()  # Allow retry

func _parse_error_message(error: String) -> String:
    if "unreachable" in error or "timeout" in error:
        return "Server unavailable. Please try again."
    elif "already exists" in error:
        return "Username already taken. Try a different one."
    elif "not found" in error or "invalid" in error:
        return "Invalid username or password."
    else:
        return "Login failed. Please try again."
```

**Note**: NO offline fallback - all three auth methods require server connection. If server is down, game cannot start.

### 6.2 Validation Errors
**Client-side validation before sending to server**:
```gdscript
func _validate_credentials(username: String, password: String) -> bool:
    if username.length() < 3:
        show_status("Username must be at least 3 characters", "error")
        return false
    if username.length() > 20:
        show_status("Username cannot exceed 20 characters", "error")
        return false
    if password.length() < 6:
        show_status("Password must be at least 6 characters", "error")
        return false
    if password.length() > 50:
        show_status("Password cannot exceed 50 characters", "error")
        return false
    return true
```

---

## Implementation Steps

### Step 1: Delete Old Files
- [ ] Delete `login_popup.tscn`
- [ ] Delete `login_popup.gd`
- [ ] Delete `godot_web_auth.gd`
- [ ] Delete `google_auth.js`
- [ ] Delete old `loading_screen.tscn` (if exists)

### Step 2: Create Auth Screen Scene
- [ ] Create `level1/auth_screen.tscn` with node hierarchy
- [ ] Add BeginOverlay (Control, full rect, z-index: 10)
- [ ] Add BeginButton (TextureButton, full rect) with begin.jpg texture
- [ ] Set BeginButton properties: stretch_mode = STRETCH_KEEP_ASPECT_COVERED, ignore_texture_size = true
- [ ] Add Background (VideoStreamPlayer) pointing to `level1/title.webm`
- [ ] Set VideoStreamPlayer properties: expand = true, loop = true, paused = true (starts paused)
- [ ] Set Background initially hidden (visible = false)
- [ ] Add CenterContainer with z-index: 5, initially hidden (visible = false)
- [ ] Apply `default_theme.tres` to AuthPanel
- [ ] Set AuthPanel width to 800px
- [ ] Set button theme variations (AffirmativeButton for create/login buttons)
- [ ] Configure input fields (max 20/50 chars, secret for password)

### Step 3: Create Auth Screen Script
- [ ] Create `level1/auth_screen.gd`
- [ ] Implement two-stage flow: `_on_begin_clicked()` handler
- [ ] On begin click: hide overlay, show video, show auth panel
- [ ] Connect to NakamaClient signals (authentication_succeeded, authentication_failed)
- [ ] Implement button press handlers (Google, Create, Login, Guest)
- [ ] Implement validation function
- [ ] Implement status display function (with color support)
- [ ] Implement background loading for furnace.tscn (starts immediately in _ready)
- [ ] Implement transition logic

### Step 4: Integrate with NakamaClient
- [ ] Call `NakamaClient.authenticate_device()` for guest play
- [ ] Call `NakamaClient.authenticate_email()` for username/password
- [ ] Call `NakamaClient.authenticate_google()` for web OAuth
- [ ] Handle authentication_succeeded signal (load game + settings)
- [ ] Handle authentication_failed signal (show error, re-enable buttons)

### Step 5: Web OAuth Setup (Latest Google Identity Services)
- [ ] Create `level1/google_signin.gd` (clean implementation)
- [ ] Implement Google Identity Services (GIS) - NOT deprecated Sign-In JavaScript
- [ ] Use latest `https://accounts.google.com/gsi/client` library
- [ ] Implement token callback via `google.accounts.id.initialize()`
- [ ] Test JavaScript bridge communication
- [ ] Handle token callback

**Important**: Use Google Identity Services (GIS), not the old deprecated "Sign-In with Google" JavaScript platform. V1 used old API that got deprecation warnings.

### Step 6: Background Loading & Scene Tracking
- [ ] Add `Global.last_scene` variable to Global.gd (defaults to "res://level1/furnace.tscn")
- [ ] Implement ResourceLoader.load_threaded_request() for `Global.last_scene`
- [ ] Poll loading status in _process()
- [ ] Implement transition logic (immediate if loaded, wait if not)
- [ ] Update Global.change_scene_with_check() to track `last_scene`
- [ ] Add `last_scene` to NakamaClient save/load functions

### Step 7: Error Handling & Polish
- [ ] Test two-stage flow: begin.jpg displays, clickable, transitions to video + auth panel
- [ ] Test begin.jpg cover behavior (fills screen, maintains aspect, crops overflow)
- [ ] Test video playback after click (autoplay policy compliance)
- [ ] Test background loading during both stages
- [ ] Test all three auth methods
- [ ] Test all error scenarios (network, validation, server errors)
- [ ] Test keyboard navigation (tab between fields)
- [ ] Test font scaling at different resolutions
- [ ] Polish status messages
- [ ] Ensure smooth transition from begin.jpg to video (no flicker)
- [ ] Ensure title.webm background video displays and loops correctly

---

## Integration with Other Systems

### NakamaClient (1.19)
- Uses authentication functions: `authenticate_device()` (guest), `authenticate_email()` (username/password), `authenticate_google()` (web OAuth)
- Listens to signals: `authentication_succeeded`, `authentication_failed`
- Calls `load_game()` and `load_settings()` after successful auth

### Scene Loading System
- Auth screen background-loads `Global.last_scene` starting from _ready() (stage 1)
- Loading continues during both stages (begin.jpg display + auth selection)
- `Global.last_scene` = path to player's last visited scene
- Defaults to `"res://level1/furnace.tscn"` for new players
- Saved to cloud/local storage with game state
- Transitions to `Global.last_scene` immediately after auth completes
- If loading not complete, shows brief "Loading..." status (video continues playing)

### Project Entry Point
- `project.godot` main scene set to `level1/auth_screen.tscn`
- Auth screen is the first thing player sees
- Stage 1 (begin.jpg) displays immediately
- Stage 2 (auth panel + video) appears after player clicks begin.jpg

---

## Dependencies

**Before This Plan**:
- [x] Nakama Server (1.19) - Authentication functions exist
- [x] Default Theme (1.10) - Theme resource with button variations
- [x] Responsive Layout Guide (1.11) - Font scaling system
- [x] Global.gd (1.3) - Stats system for cloud save loading
- [x] Level1Vars (1.4) - Level vars for cloud save loading

**After This Plan**:
- [ ] First Game Scene (future) - Scene loaded by auth screen (furnace.tscn initially, then tracked in Global.last_scene)
- [ ] Scene Management Updates - Global.change_scene_with_check() tracks last_scene
- [ ] Save System Local Storage (future) - Would need to integrate with device ID auth

---

## Files Created

- `level1/auth_screen.tscn` - Auth/loading screen scene
- `level1/auth_screen.gd` - Auth/loading screen script
- `level1/google_signin.gd` - Clean Google OAuth implementation (web only)

**Files Reused**:
- `level1/begin.jpg` - Click-to-start overlay image (stage 1)
- `level1/title.webm` - Background video for auth panel (stage 2)

**Files Deleted**:
- `login_popup.tscn` - Old v1 auth popup
- `login_popup.gd` - Old v1 auth script
- `godot_web_auth.gd` - Old v1 web auth (spaghetti)
- `google_auth.js` - Old v1 OAuth JS (spaghetti)
- `loading_screen.tscn` (if exists) - Replaced by auth_screen.tscn

**Files Modified**:
- `project.godot` - Set main scene to `level1/auth_screen.tscn`
- `global.gd` - Add `last_scene` variable, update `change_scene_with_check()` to track it
- `nakama_client.gd` - Add `last_scene` to save/load functions

---

## Success Criteria

**Two-Stage Flow**:
- [ ] Stage 1: begin.jpg displays immediately on game start with cover behavior
- [ ] begin.jpg clickable (TextureButton covers full screen)
- [ ] Background loading starts immediately (furnace.tscn + title.webm)
- [ ] Stage 2: Clicking begin.jpg hides overlay, shows video, shows auth panel
- [ ] title.webm plays after click (satisfies browser autoplay policies)
- [ ] Auth panel appears after click with all buttons functional

**Auth System**:
- [ ] Auth screen IS the loading screen (no separate loading screen)
- [ ] All three auth methods work (Google OAuth, username/password, guest/device ID)
- [ ] Theme variations applied correctly (blue affirmative buttons for create/login)
- [ ] Status label colors correct (light blue success, light orange/yellow error, white loading)
- [ ] Fixed 800px width auth panel (landscape-only)
- [ ] Font scaling follows ResponsiveLayout system
- [ ] Error messages are clear and helpful
- [ ] All three auth methods required (no skip button)

**Loading & Transitions**:
- [ ] Background loading happens during both stages (begin.jpg display + auth selection)
- [ ] Global.last_scene defaults to "res://level1/furnace.tscn" for new players
- [ ] Immediate transition to Global.last_scene after auth completes (if loaded)
- [ ] Global.change_scene_with_check() updates last_scene on scene changes
- [ ] last_scene saved/loaded with game state (cloud + local)
- [ ] Cloud saves load after successful auth
- [ ] User settings load after successful auth

**Visual Polish**:
- [ ] begin.jpg displays with proper cover behavior (fills screen, maintains aspect, crops overflow)
- [ ] title.webm background video displays and loops correctly (expand = true maintains aspect)
- [ ] Smooth transition from begin.jpg to video (no flicker)
- [ ] Clean rebuild - no v1 spaghetti code reused

---

## Design Values Referenced from Guidelines

### From 1.10-default-theme.md
- **Panel background**: Orange 30% opacity (`Color(0.58, 0.247, 0.012, 0.3)`)
- **Base font size**: 25px
- **Button theme variations**: AffirmativeButton (blue), Standard (orange)
- **Corner radius**: 4px for panels, 3px for buttons
- **Text colors**: White normal, light yellow hover

### From 1.14-button-hierarchy.md
- **Button type philosophy**: Affirmative (blue) for positive actions, Standard (orange) for neutral
- **Not using automatic sorting**: Auth screen has manual layout, doesn't use Menu container pattern

### From 1.13-scene-template.md
- **ResponsiveLayout patterns**: Font scaling, responsive sizing
- **Why not inheriting**: Auth screen is pre-game special case, not standard gameplay scene

---

## Notes

**Decision 1**: Reference design guidelines, not hard-code values
- **Rationale**: If theme colors change, auth screen inherits changes automatically
- **Implementation**: Use `theme_type_variation` and default_theme.tres
- **Benefit**: Cohesive visual design across all UI

**Decision 2**: Auth screen IS the loading screen
- **Rationale**: Simplifies architecture, hides loading behind auth UX
- **Benefit**: Perceived faster loading, fewer files, cleaner structure
- **Implementation**: Auth screen background-loads furnace.tscn, transitions immediately after auth

**Decision 3**: No skip button - three required auth methods
- **Rationale**: Web-only game requires server connection, all methods create cloud account
- **Three methods**: Google OAuth (web), username/password (manual account), guest (device ID)
- **Trade-off**: No true offline mode, but guest is friction-free

**Decision 4**: Guest play uses device ID authentication
- **Rationale**: Creates persistent cloud save without username/password
- **Benefits**: Low friction, cloud save benefits, no account management
- **Limitation**: Not portable across devices
- **Label**: "Play as Guest" (clearer than "offline" for web game)

**Decision 5**: Load settings separately from game saves
- **Rationale**: Settings persist across save wipes (from 1.19-nakama-server.md)
- **Implementation**: Call both `load_game()` and `load_settings()` on auth success

**Decision 6**: Clean rebuild - NO v1 code reuse
- **Rationale**: V1 auth code was frankensteined/spaghetti
- **Files deleted**: login_popup, godot_web_auth.gd, google_auth.js, loading_screen
- **Files created**: auth_screen (clean rebuild), google_signin.gd (clean OAuth)
- **Benefit**: Maintainable code, easier to understand and modify

**Decision 7**: Status label color system
- **Success**: Light blue (matches affirmative button, not green)
- **Error**: Light orange/yellow (matches theme hover text)
- **Loading**: White (normal text)
- **Rationale**: Consistent with theme, no new colors introduced

**Decision 8**: Fixed 800px width, landscape-only
- **Rationale**: Game is landscape-only per 1.11-responsive-layout-guide.md
- **Benefit**: No complex responsive logic, simpler implementation
- **Removed**: Mobile/portrait support

**Decision 9**: Load Global.last_scene (tracked scene system)
- **Rationale**: Player should resume where they left off, not always start at furnace
- **Implementation**: Global.last_scene tracks last visited scene, defaults to furnace for new players
- **Benefit**: Seamless continuation, works across level1/level2/level3 scenes
- **Save integration**: last_scene saved/loaded with game state

**Decision 10**: No graceful degradation / offline fallback
- **Rationale**: Web game requires server, complex save merging not worth it
- **Simplified**: Auth fails = retry, no offline mode
- **Future**: Could add save merge logic if needed

**Decision 11**: Two-stage UX (begin.jpg click-to-start, then auth panel with video)
- **Rationale**: Combines best of both approaches - instant visual feedback + beautiful video background
- **Stage 1**: begin.jpg loads instantly, player clicks when ready, satisfies browser autoplay policies
- **Stage 2**: Video plays (now allowed), auth panel appears, player chooses auth method
- **Benefits**:
  - Maximum loading time (both stages used for background loading)
  - Browser compliance (click enables audio/video)
  - Beautiful UX (static image transitions to video)
  - Player controls pacing (clicks when ready to proceed)
- **Implementation**: TextureButton with cover behavior for begin.jpg, VideoStreamPlayer starts paused

---

**Last Updated**: 2025-12-01
**Plan Created By**: Claude
**Revised**: Two-stage UX with begin.jpg click-to-start + title.webm video background
