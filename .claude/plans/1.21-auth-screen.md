# 1.21 Auth Screen Plan

**IMPORTANT**: This plan focuses ONLY on UI/UX for authentication. For Nakama implementation details, see plan [1.19-nakama-server.md](1.19-nakama-server.md).

## Overview
Create authentication/loading screen with two-stage UX: (1) click-to-start overlay showing begin.jpg, (2) auth panel with title.webm video background. The auth screen IS the loading screen - authentication happens during initial load, then transitions directly to the first game scene. Handles migration between device ID and username/Google accounts with conflict resolution UI.

## Purpose
- Two-stage UX: begin.jpg click-to-start overlay, then auth panel with video background
- Authenticate players via NakamaClient (from plan 1.19)
- Background load first scene (Global.last_scene) during both stages
- Satisfy browser autoplay policies via click-to-start interaction
- Handle account migration automatically (device ID → username/Google)
- Resolve save conflicts when migrating accounts
- Use design system from guideline docs for consistent look and feel
- Clean rebuild - no reuse of v1 spaghetti code

---

## Design Philosophy

**Reference Guidelines, Don't Rebuild**
This plan references design values from:
- [1.10-default-theme.md](1.10-default-theme.md) - Colors, button styles, typography
- [1.13-scene-template.md](1.13-scene-template.md) - ResponsiveLayout patterns
- [1.14-button-hierarchy.md](1.14-button-hierarchy.md) - Button type concepts

**Why This Matters**:
If design guidelines change (e.g., theme colors updated), auth screen inherits the changes automatically by referencing the theme resource rather than hard-coding values.

---

## Part 1: Scene Structure

### 1.1 File Structure
**Files to create**:
- `level1/auth_screen.tscn` - Auth/loading screen scene (replaces old loading_screen.tscn)
- `level1/auth_screen.gd` - Auth/loading screen script
- `level1/google_signin.gd` - Clean Google OAuth implementation (web only)

**Files to reuse**:
- `level1/begin.jpg` - Click-to-start overlay image (stage 1)
- `level1/title.webm` - Background video for auth panel (stage 2)

**Files to delete** (v1 spaghetti cleanup):
- `login_popup.tscn`
- `login_popup.gd`
- `godot_web_auth.gd` (old web auth, rebuild clean)
- `google_auth.js` (old OAuth JS, rebuild clean)

**Note**: Auth screen is the ONLY loading screen. No separate loading_screen.tscn.

### 1.2 Node Hierarchy
```
AuthScreen (Control, anchors fill)
├── BeginOverlay (Control, full rect, initially visible, z-index: 10)
│   └── BeginButton (TextureButton, full rect, shows level1/begin.jpg)
│       └── (TextureButton stretch_mode: STRETCH_KEEP_ASPECT_COVERED for cover behavior)
├── Background (VideoStreamPlayer, shows level1/title.webm, initially hidden/paused, expand = true)
├── CenterContainer (centers auth panel, initially hidden, z-index: 5)
│   └── AuthPanel (Panel, uses default_theme.tres, fixed width: 800px)
│       └── MarginContainer (20px margins)
│           └── MainVBox (VBoxContainer, spacing: 10px)
│               ├── TitleLabel (Label, "Welcome to GoA")
│               ├── SubtitleLabel (Label, "Sign in to save your progress")
│               ├── Separator1 (HSeparator)
│               ├── GoogleButton (Button, "Sign in with Google")
│               ├── Separator2 (HSeparator)
│               ├── OrLabel (Label, "or")
│               ├── UsernameContainer (HBoxContainer)
│               │   ├── UsernameLabel (Label, "Username:")
│               │   └── UsernameInput (LineEdit, max 20 chars)
│               ├── PasswordContainer (HBoxContainer)
│               │   ├── PasswordLabel (Label, "Password:")
│               │   └── PasswordInput (LineEdit, secret, max 50 chars)
│               ├── ButtonContainer (HBoxContainer, spacing: 15px)
│               │   ├── CreateAccountButton (Button, "Create Account", theme_type_variation = "AffirmativeButton")
│               │   └── LoginButton (Button, "Login", theme_type_variation = "AffirmativeButton")
│               ├── Separator3 (HSeparator)
│               ├── DeviceIDButton (Button, "Save by Device ID")
│               ├── StatusLabel (Label, dynamic feedback, centered)
│               └── LoadingIndicator (optional, shows "Loading..." during background load)
```

**Note**: Auth panel is 800px wide (landscape only).

### 1.3 Theme Integration
**All UI elements use default_theme.tres**:
- Panel: Orange 30% opacity background, 4px corner radius
- Labels: White text, 25px base font (auto-scales with ResponsiveLayout)
- Buttons: Reference theme variations

**Button Theme Variations**:
- GoogleButton: Default (orange) - third-party auth
- CreateAccountButton: `theme_type_variation = "AffirmativeButton"` (blue) - positive action
- LoginButton: `theme_type_variation = "AffirmativeButton"` (blue) - positive action
- DeviceIDButton: Default (orange) - anonymous play

**Status Label Colors**:
- Success: Light blue `Color(0.529, 0.808, 0.922, 1.0)` (matches affirmative button text)
- Error: Light orange/yellow `Color(1, 1, 0.8, 1)` (matches button hover text)
- Loading: White `Color(1, 1, 1, 1)` (normal text)

### 1.4 Two-Stage Flow
**Stage 1: Click-to-Start (begin.jpg)**
- Full-screen begin.jpg overlay (TextureButton with cover behavior)
- Player clicks anywhere on the image to proceed
- Satisfies browser autoplay policies (user interaction required)
- Background loading starts immediately (Global.last_scene + title.webm preload)

**Stage 2: Auth Selection (title.webm + auth panel)**
- begin.jpg overlay hides
- title.webm video starts playing (now allowed due to user interaction)
- Auth panel appears with login options
- Player chooses auth method while loading continues

**Implementation**:
```gdscript
var has_clicked_begin = false
var previous_auth_method = ""  # Track for migration
var previous_user_id = ""  # Track for migration

func _ready():
	# Connect signals from NakamaClient
	NakamaClient.authentication_succeeded.connect(_on_auth_success)
	NakamaClient.authentication_failed.connect(_on_auth_failed)
	NakamaClient.save_conflict_detected.connect(_on_save_conflict_detected)

	# Initial state: Show begin.jpg, hide auth UI
	begin_overlay.visible = true
	begin_button.pressed.connect(_on_begin_clicked)
	background_video.visible = false
	background_video.paused = true
	center_container.visible = false

	# Start background loading immediately
	_start_background_load()

func _on_begin_clicked():
	if has_clicked_begin:
		return
	has_clicked_begin = true

	# Hide begin.jpg overlay
	begin_overlay.visible = false

	# Show and play video (user interaction already happened)
	background_video.visible = true
	background_video.paused = false
	background_video.play()

	# Show auth panel
	center_container.visible = true
```

---

## Part 2: Authentication Methods

All three methods call NakamaClient functions from plan 1.19. No implementation details here - just UI integration.

### 2.1 Google OAuth (Web Only)
**UI**: "Sign in with Google" button at top

**Flow**:
```gdscript
func _on_google_button_pressed():
	_disable_all_buttons()
	show_status("Opening Google sign-in...", "loading")

	# Call NakamaClient (implementation in plan 1.19)
	GoogleSignin.start_google_auth()  # This will eventually call NakamaClient.authenticate_google()
```

### 2.2 Username/Password (Create Account)
**UI**: Username/password inputs + "Create Account" button

**Validation**:
- Username: Min 3 chars, max 20 chars
- Password: Min 6 chars, max 50 chars

**Flow**:
```gdscript
func _on_create_account_pressed():
	var username = username_input.text.strip_edges()
	var password = password_input.text

	if not _validate_credentials(username, password):
		return

	_disable_all_buttons()
	show_status("Creating account...", "loading")

	# Call NakamaClient (implementation in plan 1.19)
	var success = await NakamaClient.authenticate_email(username, password, true)
```

### 2.3 Username/Password (Login)
**UI**: Same inputs + "Login" button

**Flow**:
```gdscript
func _on_login_pressed():
	var username = username_input.text.strip_edges()
	var password = password_input.text

	if not _validate_credentials(username, password):
		return

	_disable_all_buttons()
	show_status("Logging in...", "loading")

	# Call NakamaClient (implementation in plan 1.19)
	var success = await NakamaClient.authenticate_email(username, password, false)
```

### 2.4 Device ID Authentication
**UI**: "Save by Device ID" button at bottom

**Note**: Button label is "Save by Device ID" (NOT "Play as Guest") to make it clear that progress IS saved.

**Flow**:
```gdscript
func _on_device_id_button_pressed():
	_disable_all_buttons()
	show_status("Creating device account...", "loading")

	# Track that we're using device ID (for migration detection)
	previous_auth_method = "device_id"

	# Call NakamaClient (implementation in plan 1.19)
	var success = await NakamaClient.authenticate_device()
```

---

## Part 3: Signal Handling

### 3.1 Connect to NakamaClient Signals
```gdscript
func _ready():
	# Connect to NakamaClient signals (implementation in plan 1.19)
	NakamaClient.authentication_succeeded.connect(_on_auth_success)
	NakamaClient.authentication_failed.connect(_on_auth_failed)
	NakamaClient.save_conflict_detected.connect(_on_save_conflict_detected)
	NakamaClient.migration_completed.connect(_on_migration_completed)
```

### 3.2 Auth Success Handler
```gdscript
func _on_auth_success(session_data: Dictionary):
	# Show success status
	show_status("Login successful! Welcome, %s" % session_data.username, "success")

	# Check if migrating from device ID (automatic migration)
	if previous_auth_method == "device_id" and previous_user_id != session_data.user_id:
		await _handle_account_migration(previous_user_id, session_data.user_id)
	else:
		# No migration needed - load game state
		await _load_game_and_settings()

	# Transition to game
	_transition_to_game()

func _load_game_and_settings():
	# Try to load cloud save (implementation in plan 1.19)
	var save_loaded = await NakamaClient.load_game()

	# Try to load user settings (implementation in plan 1.19)
	var settings_loaded = await NakamaClient.load_settings()
```

### 3.3 Auth Failed Handler
```gdscript
func _on_auth_failed(error: String):
	# Parse error message for user-friendly display
	var friendly_error = _parse_error_message(error)

	# Show error status
	show_status(friendly_error, "error")

	# Re-enable buttons for retry
	_enable_all_buttons()

func _parse_error_message(error: String) -> String:
	if "unreachable" in error or "timeout" in error:
		return "Server unavailable. Please try again."
	elif "already exists" in error:
		return "Username already taken. Try a different one."
	elif "not found" in error or "invalid" in error:
		return "Invalid username or password."
	else:
		return "Login failed. Please try again."
```

### 3.4 Status Display Function
```gdscript
func show_status(message: String, status_type: String = "loading"):
	status_label.text = message

	# Apply colors from default_theme.tres
	match status_type:
		"success":
			# Light blue (matches affirmative button text)
			status_label.add_theme_color_override("font_color", Color(0.529, 0.808, 0.922, 1.0))
		"error":
			# Light orange/yellow (matches hover text)
			status_label.add_theme_color_override("font_color", Color(1, 1, 0.8, 1))
		"loading", _:
			# White (normal text)
			status_label.add_theme_color_override("font_color", Color(1, 1, 1, 1))
```

---

## Part 4: Account Migration UI

Migration happens automatically when user switches from device ID to username/Google authentication. See plan 1.19 Part 5 for implementation details.

### 4.1 Handle Account Migration
Called when user switches authentication methods.

```gdscript
func _handle_account_migration(old_user_id: String, new_user_id: String):
	# Check if migration needed (implementation in plan 1.19)
	var migration_result = await NakamaClient.check_for_migration_needed(old_user_id, new_user_id)

	if not migration_result.needs_migration:
		# No device ID save to migrate
		await _load_game_and_settings()
		return

	if migration_result.has_conflict:
		# Both accounts have saves - show conflict resolution UI
		_show_save_conflict_dialog(migration_result.old_save, migration_result.new_save)
		# Wait for user choice (handled by dialog)
	else:
		# No conflict - simple migration prompt
		var confirm = await _show_migration_confirmation_dialog(new_user_id)
		if confirm:
			show_status("Uploading device progress...", "loading")
			var success = await NakamaClient.migrate_save_to_account(old_user_id, new_user_id)
			if success:
				show_status("Progress uploaded successfully!", "success")
			else:
				show_status("Upload failed. Starting fresh.", "error")

		# Load game state (either migrated or fresh)
		await _load_game_and_settings()
```

### 4.2 Migration Confirmation Dialog (No Conflict)
Simple yes/no dialog for uploading device ID progress.

```gdscript
func _show_migration_confirmation_dialog(new_username: String) -> bool:
	# Show dialog: "Upload your device ID progress to [username]?"
	# Return: true if user clicks "Yes", false if "No"
	# Implementation: Use ConfirmationDialog or custom popup
	pass  # TODO: Implement dialog UI
```

### 4.3 Save Conflict Resolution Dialog
Shows both saves with timestamps + total play time, lets user choose which to keep.

```gdscript
func _show_save_conflict_dialog(device_save: Dictionary, account_save: Dictionary):
	# Get summaries from NakamaClient (implementation in plan 1.19)
	var device_summary = NakamaClient.get_save_summary(device_save)
	var account_summary = NakamaClient.get_save_summary(account_save)

	# Show conflict resolution UI
	# TODO: Create conflict resolution dialog scene
	# Dialog should show:
	# - Last played timestamp (formatted)
	# - Total play time in hours
	# - Key stats (strength, constitution, etc.)
	# - Currency totals
	# - Two buttons: "Keep Device ID Progress" and "Keep Account Progress"

	# Pseudo-code for dialog:
	var dialog = ConflictResolutionDialog.new()
	dialog.set_device_save_summary(device_summary)
	dialog.set_account_save_summary(account_summary)
	add_child(dialog)

	# Wait for user choice
	var chosen_save = await dialog.user_choice_made

	# Migrate chosen save
	if chosen_save == "device":
		await NakamaClient.migrate_save_to_account(previous_user_id, NakamaClient.user_id)
	# If "account" chosen, do nothing (account save stays)

	# Load game state
	await _load_game_and_settings()
```

### 4.4 Conflict Resolution Dialog Scene
**File**: `level1/conflict_resolution_dialog.tscn`

**Structure**:
```
ConflictResolutionDialog (Popup, modal)
└── Panel (uses default_theme.tres)
    └── MarginContainer
        └── VBox
            ├── TitleLabel ("Which save do you want to keep?")
            ├── HBox (side-by-side comparison)
            │   ├── DeviceSavePanel
            │   │   ├── Label ("Device ID Progress")
            │   │   ├── LastPlayedLabel ("Last played: [timestamp]")
            │   │   ├── PlayTimeLabel ("Total play time: [hours]")
            │   │   ├── StatsLabel ("Stats: Str 10, Con 8...")
            │   │   └── CurrencyLabel ("Currency: 1000 copper")
            │   └── AccountSavePanel
            │       ├── Label ("Account Progress")
            │       ├── LastPlayedLabel ("Last played: [timestamp]")
            │       ├── PlayTimeLabel ("Total play time: [hours]")
            │       ├── StatsLabel ("Stats: Str 15, Con 12...")
            │       └── CurrencyLabel ("Currency: 2000 copper")
            └── ButtonContainer
                ├── KeepDeviceButton ("Keep Device ID Progress")
                └── KeepAccountButton ("Keep Account Progress")
```

**Note**: Format timestamps as human-readable (e.g., "2 hours ago", "Yesterday at 3:45 PM").

---

## Part 5: Loading Flow & Scene Transition

**Key Concept**: Auth screen IS the loading screen. No separate loading_screen.tscn.

### 5.1 Loading Flow
```
Game Start
    ↓
Auth Screen appears (level1/auth_screen.tscn)
    ↓
STAGE 1: begin.jpg overlay displays
    ↓
[Background loading starts immediately:]
    - ResourceLoader.load_threaded_request(Global.last_scene)
    - ResourceLoader.load_threaded_request(title.webm) if needed
    - Initialize Global stats
    - Initialize Level1Vars
    ↓
Player clicks begin.jpg
    ↓
STAGE 2: Auth panel appears, title.webm plays
    ↓
User authenticates (Google/Username/Device ID)
    ↓
[Migration happens if switching from device ID]
    ↓
Auth completes (success or failure)
    ↓
IF Global.last_scene loaded:
    - Transition to Global.last_scene immediately
ELSE:
    - Show "Loading..." status (video continues playing)
    - Wait for Global.last_scene to finish loading
    - Transition to Global.last_scene
```

### 5.2 Background Loading Implementation
```gdscript
var loaded_scene: PackedScene = null
var is_loading_scene = false

func _ready():
	# Connect signals
	NakamaClient.authentication_succeeded.connect(_on_auth_success)
	NakamaClient.authentication_failed.connect(_on_auth_failed)

	# Start background loading player's last scene
	_start_background_load()

func _start_background_load():
	# Get scene path from Global (defaults to furnace for new players)
	var scene_path = Global.last_scene if Global.has("last_scene") else "res://level1/furnace.tscn"

	is_loading_scene = true
	# Load scene in background thread
	ResourceLoader.load_threaded_request(scene_path)

func _process(_delta):
	if is_loading_scene:
		var scene_path = Global.last_scene if Global.has("last_scene") else "res://level1/furnace.tscn"

		# Check load progress
		var status = ResourceLoader.load_threaded_get_status(scene_path)
		if status == ResourceLoader.THREAD_LOAD_LOADED:
			loaded_scene = ResourceLoader.load_threaded_get(scene_path)
			is_loading_scene = false
```

### 5.3 Transition Logic
```gdscript
func _transition_to_game():
	var scene_path = Global.last_scene if Global.has("last_scene") else "res://level1/furnace.tscn"

	if loaded_scene:
		# Scene already loaded - transition immediately
		Global.change_scene_with_check(scene_path)
	else:
		# Scene still loading - show loading indicator
		show_status("Loading game...", "loading")
		# Wait for scene to finish loading
		while is_loading_scene:
			await get_tree().process_frame
		Global.change_scene_with_check(scene_path)
```

### 5.4 Global.last_scene Variable
**Add to Global.gd** (coordinate with plan 1.3):
```gdscript
# Scene tracking for auth screen loading
var last_scene: String = "res://level1/furnace.tscn"  # Default to furnace for new players
```

**Update when changing scenes** (in Global.change_scene_with_check() or equivalent):
```gdscript
func change_scene_to(scene_path: String):
	# Save current scene before changing
	last_scene = scene_path
	# ... rest of scene change logic
```

**Save/load with game state**:
- Add `last_scene` to `_get_global_data()` in NakamaClient (plan 1.19)
- Load `last_scene` from cloud save in `_set_global_data()` (plan 1.19)

---

## Part 6: Error Handling

### 6.1 Network Errors
**Scenarios**: Server unreachable, no internet, timeout

**Handling**:
- Show friendly error message via `_parse_error_message()`
- Re-enable authentication buttons
- Let user retry

**No offline fallback** - all auth methods require server connection.

### 6.2 Validation Errors
**Client-side validation before sending to server**:
```gdscript
func _validate_credentials(username: String, password: String) -> bool:
	if username.length() < 3:
		show_status("Username must be at least 3 characters", "error")
		return false
	if username.length() > 20:
		show_status("Username cannot exceed 20 characters", "error")
		return false
	if password.length() < 6:
		show_status("Password must be at least 6 characters", "error")
		return false
	if password.length() > 50:
		show_status("Password cannot exceed 50 characters", "error")
		return false
	return true
```

---

## Implementation Checklist

### Phase 1: Delete Old Files
- [ ] Delete `login_popup.tscn`
- [ ] Delete `login_popup.gd`
- [ ] Delete `godot_web_auth.gd`
- [ ] Delete `google_auth.js`
- [ ] Delete old `loading_screen.tscn` (if exists)

### Phase 2: Create Auth Screen Scene
- [ ] Create `level1/auth_screen.tscn` with node hierarchy
- [ ] Add BeginOverlay with BeginButton (TextureButton, cover behavior)
- [ ] Add Background (VideoStreamPlayer) pointing to `level1/title.webm`
- [ ] Add CenterContainer with AuthPanel
- [ ] Apply `default_theme.tres` to AuthPanel
- [ ] Set AuthPanel width to 800px
- [ ] Set button theme variations (AffirmativeButton for create/login)
- [ ] Configure input fields (max 20/50 chars, secret for password)
- [ ] Label Device ID button as "Save by Device ID"

### Phase 3: Create Auth Screen Script
- [ ] Create `level1/auth_screen.gd`
- [ ] Implement two-stage flow: `_on_begin_clicked()` handler
- [ ] Connect to NakamaClient signals
- [ ] Implement button press handlers (Google, Create, Login, Device ID)
- [ ] Implement validation function
- [ ] Implement status display function (with color support)
- [ ] Implement background loading for Global.last_scene
- [ ] Implement transition logic

### Phase 4: Implement Migration UI
- [ ] Create conflict resolution dialog scene
- [ ] Implement `_handle_account_migration()`
- [ ] Implement `_show_migration_confirmation_dialog()` (simple yes/no)
- [ ] Implement `_show_save_conflict_dialog()` (compare saves)
- [ ] Format timestamps as human-readable
- [ ] Display total play time in hours
- [ ] Show key stats and currency in dialog

### Phase 5: Integrate with NakamaClient
- [ ] Call `NakamaClient.authenticate_device()` for device ID button
- [ ] Call `NakamaClient.authenticate_email()` for username/password
- [ ] Call `NakamaClient.authenticate_google()` for Google OAuth
- [ ] Handle authentication_succeeded signal (load game + settings)
- [ ] Handle authentication_failed signal (show error, re-enable buttons)
- [ ] Handle save_conflict_detected signal (show conflict dialog)

### Phase 6: Web OAuth Setup
- [ ] Create `level1/google_signin.gd` (clean implementation)
- [ ] Implement Google Identity Services (GIS) - NOT deprecated Sign-In JavaScript
- [ ] Use latest `https://accounts.google.com/gsi/client` library
- [ ] Implement token callback via `google.accounts.id.initialize()`
- [ ] Test JavaScript bridge communication

### Phase 7: Background Loading & Scene Tracking
- [ ] Add `Global.last_scene` variable to Global.gd (coordinate with plan 1.3)
- [ ] Implement ResourceLoader.load_threaded_request() for `Global.last_scene`
- [ ] Poll loading status in _process()
- [ ] Implement transition logic (immediate if loaded, wait if not)
- [ ] Update Global.change_scene_with_check() to track `last_scene`
- [ ] Add `last_scene` to NakamaClient save/load functions (plan 1.19)

### Phase 8: Testing & Polish
- [ ] Test two-stage flow: begin.jpg displays, clickable, transitions to video + auth panel
- [ ] Test begin.jpg cover behavior (fills screen, maintains aspect, crops overflow)
- [ ] Test video playback after click (autoplay policy compliance)
- [ ] Test background loading during both stages
- [ ] Test all three auth methods
- [ ] Test migration without conflict (device ID → username)
- [ ] Test migration with conflict (shows both saves, user chooses)
- [ ] Test all error scenarios (network, validation, server errors)
- [ ] Test keyboard navigation (tab between fields)
- [ ] Test font scaling at different resolutions
- [ ] Polish status messages
- [ ] Ensure smooth transition from begin.jpg to video (no flicker)

---

## Integration with Other Systems

### NakamaClient (Plan 1.19)
- Uses authentication functions: `authenticate_device()`, `authenticate_email()`, `authenticate_google()`
- Listens to signals: `authentication_succeeded`, `authentication_failed`, `save_conflict_detected`
- Calls `load_game()` and `load_settings()` after successful auth
- Calls migration functions: `check_for_migration_needed()`, `migrate_save_to_account()`, `get_save_summary()`

### Scene Loading System
- Auth screen background-loads `Global.last_scene` starting from _ready() (stage 1)
- Loading continues during both stages (begin.jpg display + auth selection)
- `Global.last_scene` = path to player's last visited scene
- Defaults to `"res://level1/furnace.tscn"` for new players
- Saved to cloud storage with game state (plan 1.19)
- Transitions to `Global.last_scene` immediately after auth completes

### Project Entry Point
- `project.godot` main scene set to `level1/auth_screen.tscn`
- Auth screen is the first thing player sees
- Stage 1 (begin.jpg) displays immediately
- Stage 2 (auth panel + video) appears after player clicks begin.jpg

---

## Dependencies

**Before This Plan**:
- [x] Nakama Server (plan 1.19) - Authentication functions exist
- [x] Default Theme (plan 1.10) - Theme resource with button variations
- [x] Responsive Layout Guide (plan 1.11) - Font scaling system
- [x] Global.gd (plan 1.3) - Stats system, needs `last_scene` and `total_play_length` added
- [x] Level1Vars (plan 1.4) - Level vars for cloud save loading

**After This Plan**:
- [ ] First Game Scene (future) - Scene loaded by auth screen (furnace.tscn initially)
- [ ] Scene Management Updates - Global.change_scene_with_check() tracks last_scene

---

## Files Created

- `level1/auth_screen.tscn` - Auth/loading screen scene
- `level1/auth_screen.gd` - Auth/loading screen script
- `level1/google_signin.gd` - Clean Google OAuth implementation (web only)
- `level1/conflict_resolution_dialog.tscn` - Save conflict resolution dialog
- `level1/conflict_resolution_dialog.gd` - Conflict dialog script

**Files Reused**:
- `level1/begin.jpg` - Click-to-start overlay image (stage 1)
- `level1/title.webm` - Background video for auth panel (stage 2)

**Files Deleted**:
- `login_popup.tscn` - Old v1 auth popup
- `login_popup.gd` - Old v1 auth script
- `godot_web_auth.gd` - Old v1 web auth (spaghetti)
- `google_auth.js` - Old v1 OAuth JS (spaghetti)
- `loading_screen.tscn` (if exists) - Replaced by auth_screen.tscn

**Files Modified**:
- `project.godot` - Set main scene to `level1/auth_screen.tscn`
- `global.gd` - Add `last_scene` and `total_play_length` variables, update `change_scene_with_check()` to track last_scene (coordinate with plan 1.3)

---

## Success Criteria

**Two-Stage Flow**:
- [ ] Stage 1: begin.jpg displays immediately on game start with cover behavior
- [ ] begin.jpg clickable (TextureButton covers full screen)
- [ ] Background loading starts immediately (furnace.tscn + title.webm)
- [ ] Stage 2: Clicking begin.jpg hides overlay, shows video, shows auth panel
- [ ] title.webm plays after click (satisfies browser autoplay policies)
- [ ] Auth panel appears after click with all buttons functional

**Auth System**:
- [ ] Auth screen IS the loading screen (no separate loading screen)
- [ ] All three auth methods work (Google OAuth, username/password, device ID)
- [ ] Device ID button labeled "Save by Device ID" (NOT "Play as Guest")
- [ ] Theme variations applied correctly (blue affirmative buttons for create/login)
- [ ] Status label colors correct (light blue success, light orange/yellow error, white loading)
- [ ] Fixed 800px width auth panel (landscape-only)
- [ ] Font scaling follows ResponsiveLayout system
- [ ] Error messages are clear and helpful

**Migration System**:
- [ ] Migration happens automatically when switching from device ID to username/Google
- [ ] No conflict: Shows simple confirmation dialog
- [ ] Conflict: Shows both saves with timestamps + total play time
- [ ] User can choose which save to keep
- [ ] Chosen save migrates correctly

**Loading & Transitions**:
- [ ] Background loading happens during both stages
- [ ] Global.last_scene defaults to "res://level1/furnace.tscn" for new players
- [ ] Immediate transition to Global.last_scene after auth completes (if loaded)
- [ ] Global.change_scene_with_check() updates last_scene on scene changes
- [ ] last_scene saved/loaded with game state (plan 1.19)
- [ ] Cloud saves load after successful auth
- [ ] User settings load after successful auth

**Visual Polish**:
- [ ] begin.jpg displays with proper cover behavior (fills screen, maintains aspect, crops overflow)
- [ ] title.webm background video displays and loops correctly
- [ ] Smooth transition from begin.jpg to video (no flicker)
- [ ] Clean rebuild - no v1 spaghetti code reused

---

## Notes

### Clean Rebuild Philosophy
- NO v1 code reuse (login_popup, godot_web_auth, google_auth.js all deleted)
- Build from scratch with clean architecture
- Reference design guidelines (theme, responsive layout, button hierarchy)

### Cloud-Only Architecture
- All auth methods create cloud accounts
- Device ID = cloud account linked to this device (NOT "offline mode")
- Button labeled "Save by Device ID" to clarify progress IS saved
- No local save fallback

### Migration System
- Happens automatically when switching auth methods
- No conflict: Simple yes/no prompt
- Conflict: Show comparison UI with timestamps, play time, stats, currency
- User chooses which save to keep, system migrates accordingly

### Two-Stage UX Benefits
- begin.jpg loads instantly (static image)
- Maximum loading time (both stages used for background loading)
- Browser autoplay compliance (click enables video/audio)
- Beautiful UX (static image transitions to video)
- Player controls pacing (clicks when ready to proceed)

### Account Types
- **Device ID**: Cloud account linked to this device (convenient, no login required)
- **Username/Password**: Cloud account accessible from any device (portable)
- **Google OAuth**: Cloud account via Google SSO (web builds only)

---

**Last Updated**: 2025-12-02
**Plan Created By**: Claude
**Status**: References plan 1.19 for Nakama implementation, focuses on UI/UX and migration flow
